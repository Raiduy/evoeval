{"eval": {"HumanEval/68": [{"task_id": "HumanEval/68", "solution": "\ndef pluck(arr):\n    if not arr:\n        return []\n    even_nodes = [(i, x) for (i, x) in enumerate(arr) if x % 2 == 0]\n    if not even_nodes:\n        return []\n    smallest_even_node = min(even_nodes, key=lambda x: (x[1], x[0]))\n    return [smallest_even_node[1], smallest_even_node[0]]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/47": [{"task_id": "HumanEval/47", "solution": "\n\ndef median(l: list):\n    n = len(l)\n    s = sorted(l)\n    return (s[n // 2] + s[-(n + 1) // 2]) / 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 1, 2, 4, 5]]], "plus_fail_tests": [[[10, 20, 30, 40, 50]]]}], "HumanEval/124": [{"task_id": "HumanEval/124", "solution": "\ndef valid_date(date):\n    import re\n    if not date:\n        return False\n    if not re.match('^\\\\d{2}-\\\\d{2}-\\\\d{4}$', date):\n        return False\n    (month, day, year) = map(int, date.split('-'))\n    if month in (1, 3, 5, 7, 8, 10, 12) and (day < 1 or day > 31):\n        return False\n    elif month in (4, 6, 9, 11) and (day < 1 or day > 30):\n        return False\n    elif month == 2 and (day < 1 or day > 29):\n        return False\n    if month < 1 or month > 12:\n        return False\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["06-04-2020\n"]]}], "HumanEval/72": [{"task_id": "HumanEval/72", "solution": "\ndef will_it_fly(q, w):\n    if q != q[::-1]:\n        return False\n    if sum(q) <= w:\n        return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/4": [{"task_id": "HumanEval/4", "solution": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the Mean Absolute Deviation (MAD) for a provided list of numbers.\n\n    The Mean Absolute Deviation is a measure of statistical dispersion. It is calculated as the average absolute difference \n    between each value in a dataset and the mean of the dataset.\n\n    This function takes as input a list of floating point numbers, calculates the mean of these numbers, then finds the absolute \n    difference between each number in the list and the calculated mean. The average of these absolute differences is returned \n    as the Mean Absolute Deviation.\n\n    The formula for Mean Absolute Deviation is: MAD = average | x - x_mean |\n\n    Args:\n        numbers (List[float]): A list of floating point numbers.\n\n    Returns:\n        float: The Mean Absolute Deviation of the numbers in the input list.\n\n    Example:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n\n    Note that the Mean Absolute Deviation gives equal weight to all values in the input list, irrespective of their magnitude. \n    This makes it a robust measure of dispersion, resistant to outliers in the data.    \n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    abs_diffs = [abs(x - mean) for x in numbers]\n    mad = sum(abs_diffs) / len(abs_diffs)\n    return mad", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/71": [{"task_id": "HumanEval/71", "solution": "\ndef triangle_area(a, b, c):\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1\n    s = (a + b + c) / 2\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    return round(area, 2)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/105": [{"task_id": "HumanEval/105", "solution": "\ndef by_length(arr):\n    num2words = {1: 'One', 2: 'Two', 3: 'Three', 4: 'Four', 5: 'Five', 6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine'}\n    filtered_arr = [i for i in arr if 1 <= i <= 9]\n    filtered_arr.sort()\n    filtered_arr = filtered_arr[::-1]\n    result = [num2words[i] for i in filtered_arr]\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/107": [{"task_id": "HumanEval/107", "solution": "\ndef even_odd_palindrome(n):\n\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    even_count = 0\n    odd_count = 0\n    for i in range(1, n):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[777]]}], "HumanEval/82": [{"task_id": "HumanEval/82", "solution": "\ndef prime_length(string):\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n ** 0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    return is_prime(len(string))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/104": [{"task_id": "HumanEval/104", "solution": "\ndef unique_digits(x):\n    odd_digits_only = [num for num in x if all((int(digit) % 2 != 0 for digit in str(num)))]\n    sorted_list = sorted(odd_digits_only)\n    return sorted_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/101": [{"task_id": "HumanEval/101", "solution": "\ndef words_string(s):\n    return s.replace(',', '').split()", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["Elephant,giraffe,,lion,zebra"]]}], "HumanEval/75": [{"task_id": "HumanEval/75", "solution": "\ndef is_multiply_prime(a):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [i for i in range(2, a) if is_prime(i)]\n    for i in range(len(primes)):\n        for j in range(i + 1, len(primes)):\n            for k in range(j + 1, len(primes)):\n                if primes[i] * primes[j] * primes[k] == a:\n                    return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[8]], "plus_fail_tests": [[99]]}], "HumanEval/119": [{"task_id": "HumanEval/119", "solution": "\ndef match_parens(lst):\n    (s1, s2) = lst\n    if s1.count('(') == s1.count(')'):\n        if s2.count('(') == s2.count(')'):\n            return 'Yes'\n        else:\n            return 'No'\n    else:\n        return 'No'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["()(", ")"]]], "plus_fail_tests": [[["(())", ")()("]]]}], "HumanEval/87": [{"task_id": "HumanEval/87", "solution": "\ndef get_row(lst, x):\n    coordinates = []\n    for (row_index, row) in enumerate(lst):\n        for (column_index, element) in enumerate(row):\n            if element == x:\n                coordinates.append((row_index, column_index))\n    coordinates.sort(key=lambda a: (a[0], -a[1]))\n    return coordinates", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/96": [{"task_id": "HumanEval/96", "solution": "\ndef count_up_to(n):\n    if n < 2:\n        return []\n    primes = []\n    for i in range(2, n):\n        if is_prime(i):\n            primes.append(i)\n        if len(primes) == n - 2:\n            break\n    return primes", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[3]]}], "HumanEval/93": [{"task_id": "HumanEval/93", "solution": "\ndef encode(message):\n    vowels = 'aeiouAEIOU'\n    encoded_message = ''\n    for char in message:\n        if char in vowels:\n            if char.islower():\n                encoded_message += chr(ord(char) + 2)\n            else:\n                encoded_message += chr(ord(char) - 2)\n        else:\n            encoded_message += char.swapcase()\n    return encoded_message", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["TEST"]], "plus_fail_tests": [["abcdefghijklmnopqrstuvwxyz"]]}], "HumanEval/156": [{"task_id": "HumanEval/156", "solution": "\ndef int_to_mini_roman(number):\n    roman_numerals = {1: 'i', 4: 'iv', 5: 'v', 9: 'ix', 10: 'x', 40: 'xl', 50: 'l', 90: 'xc', 100: 'c', 400: 'cd', 500: 'd', 900: 'cm', 1000: 'm'}\n    result = ''\n    for value in sorted(roman_numerals.keys(), reverse=True):\n        while number >= value:\n            result += roman_numerals[value]\n            number -= value\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/66": [{"task_id": "HumanEval/66", "solution": "\ndef digitSum(s):\n    return sum((ord(ch) for ch in s if ch.isupper()))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/102": [{"task_id": "HumanEval/102", "solution": "\ndef choose_num(x, y):\n    if x > y or x < 0 or y < 0:\n        return -1\n    if x % 2 == 0 and y % 2 == 0:\n        return y\n    elif y % 2 == 0:\n        return y\n    else:\n        return y - 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[7, 7]], "plus_fail_tests": [[35, 35]]}], "HumanEval/86": [{"task_id": "HumanEval/86", "solution": "\ndef anti_shuffle(s):\n    words = s.split(' ')\n    result = []\n    for word in words:\n        chars = sorted(word)\n        result.append(''.join(chars))\n    return ' '.join(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/125": [{"task_id": "HumanEval/125", "solution": "\ndef split_words(txt):\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for c in txt if c.islower() and (ord(c) - ord('a')) % 2 == 1))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/44": [{"task_id": "HumanEval/44", "solution": "\n\ndef change_base(x: int, base: int):\n    \"\"\"\n    Convert and change the numerical base of a given input number 'x' into a different base 'base'.\n    \"\"\"\n    if x < 0:\n        raise ValueError('Negative numbers are not supported.')\n    if base < 2 or base > 9:\n        raise ValueError('Only bases between 2 and 9 are supported.')\n    convertString = '0123456789'\n    result = ''\n    while x > 0:\n        result = convertString[x % base] + result\n        x = x // base\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0, 3]]}], "HumanEval/120": [{"task_id": "HumanEval/120", "solution": "\ndef maximum(arr, k):\n    arr_sorted = sorted(arr, reverse=True)\n    return arr_sorted[:k]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-3, -4, 5], 3]], "plus_fail_tests": [[[1, 2, 3, 4, 5], 3]]}], "HumanEval/100": [{"task_id": "HumanEval/100", "solution": "\ndef make_a_pile(n):\n    pile = [n]\n    while n < 1000:\n        if n % 2 == 0:\n            n = n + 2\n        else:\n            n = n + 2\n        pile.append(n)\n    return pile", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[1]]}], "HumanEval/14": [{"task_id": "HumanEval/14", "solution": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    return [string[:i] for i in range(1, len(string) + 1)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/88": [{"task_id": "HumanEval/88", "solution": "\ndef sort_array(array):\n    if not array:\n        return []\n    elif len(array) == 1:\n        return array\n    elif (array[0] + array[-1]) % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/97": [{"task_id": "HumanEval/97", "solution": "\ndef multiply(a, b):\n    a = abs(a) % 10\n    b = abs(b) % 10\n    return a * b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/84": [{"task_id": "HumanEval/84", "solution": "\ndef solve(N):\n    str_N = str(N)\n    sum_of_digits = sum((int(digit) for digit in str_N))\n    return bin(sum_of_digits)[2:]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/23": [{"task_id": "HumanEval/23", "solution": "\n\ndef strlen(string: str) -> int:\n    if not isinstance(string, str):\n        raise TypeError('Input should be a string')\n    return len(string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/35": [{"task_id": "HumanEval/35", "solution": "\n\ndef max_element(l: list):\n    max_val = l[0]\n    for num in l:\n        if num > max_val:\n            max_val = num\n    return max_val", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/13": [{"task_id": "HumanEval/13", "solution": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    while b != 0:\n        (a, b) = (b, a % b)\n    return abs(a)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/157": [{"task_id": "HumanEval/157", "solution": "\ndef right_angle_triangle(a, b, c):\n    return a * a + b * b == c * c or a * a + c * c == b * b or b * b + c * c == a * a", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/43": [{"task_id": "HumanEval/43", "solution": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    The function pairs_sum_to_zero takes a single argument, l, which is expected to be a list of integers. The function\n    performs an operation to determine if there are any two distinct elements within the provided list that, when added\n    together, equal zero.\n\n    The function will return True if such a pair is found. If no such pair exists within the list, the function will return \n    False. It's worth noting that the pair of numbers must be distinct, which means the same number cannot be used twice.\n\n    This function is useful in cases where you need to check if a list of numbers contains two numbers that can offset \n    each other. For example, in a financial application, you might want to check if there are any transactions that \n    offset each other.\n    \"\"\"\n    l = set(l)\n    for num in l:\n        if -num in l:\n            return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 3, 5, 0]]], "plus_fail_tests": [[[0]]]}], "HumanEval/110": [{"task_id": "HumanEval/110", "solution": "\ndef exchange(lst1, lst2):\n    even_count = 0\n    odd_count = 0\n    for num1 in lst1:\n        if num1 % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    for num2 in lst2:\n        if num2 % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    if odd_count > even_count:\n        return 'NO'\n    else:\n        return 'YES'", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 4, 6], [1, 3, 5, 7]]]}], "HumanEval/95": [{"task_id": "HumanEval/95", "solution": "\ndef check_dict_case(dict):\n    if not dict:\n        return False\n    for key in dict:\n        if not isinstance(key, str):\n            return False\n        if not key.islower() and (not key.isupper()):\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"p": "pineapple", "A": "banana", "B": "banana"}]], "plus_fail_tests": [[{"PI": 1.7300435058060522, "new yorrk": 2.2762868739904514}]]}], "HumanEval/98": [{"task_id": "HumanEval/98", "solution": "\ndef count_upper(s):\n    upper_vowels = 'AEIOU'\n    count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in upper_vowels:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/73": [{"task_id": "HumanEval/73", "solution": "\ndef smallest_change(arr: List[int]) -> int:\n    n = len(arr)\n    changes = 0\n    i = 0\n    j = n - 1\n    while i < j:\n        if arr[i] != arr[j]:\n            changes += 1\n        i += 1\n        j -= 1\n    return changes", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/81": [{"task_id": "HumanEval/81", "solution": "\ndef numerical_letter_grade(grades):\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/108": [{"task_id": "HumanEval/108", "solution": "\ndef count_nums(arr):\n    count = 0\n    for num in arr:\n        if num < 0:\n            num = -(-num // 10 * 10 + num % 10)\n        digits_sum = sum((int(digit) for digit in str(num)))\n        if digits_sum > 0:\n            count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, -2, 0]]], "plus_fail_tests": [[[-1, 0, 1]]]}], "HumanEval/146": [{"task_id": "HumanEval/146", "solution": "def specialFilter(nums):\n    count = 0\n    for num in nums:\n        if num > 10 and num % 2 == 1:\n            str_num = str(abs(num))\n            if len(str_num) > 1 and str_num[0] in '13579' and (str_num[-1] in '13579'):\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/147": [{"task_id": "HumanEval/147", "solution": "\ndef get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1]]}], "HumanEval/60": [{"task_id": "HumanEval/60", "solution": "\n\ndef sum_to_n(n: int):\n    return n * (n + 1) // 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/144": [{"task_id": "HumanEval/144", "solution": "\ndef simplify(x, n):\n    \"\"\"\n    This function is designed to perform the simplification of an expression that's a multiplication of two fractions. \n    The function takes two arguments, x and n, both of which are string representations of fractions. Each fraction is \n    formatted as \"<numerator>/<denominator>\", where both the numerator and the denominator are positive whole numbers. \n    The function does not handle cases where the denominator is zero, as this is assumed to be an invalid input.\n    \n    The simplification process involves multiplying the two fractions and then checking if the result is a whole number. \n    If the result of the multiplication is a whole number, then the function returns True. Otherwise, it will return False. \n\n    It's crucial to notice that the function doesn't actually perform the multiplication operation on the fractions. \n    Instead, it relies on Python's built-in arithmetic operations to evaluate the expression. So, it will behave according \n    to the rules of arithmetic operations in Python.\n\n    For example, simplify(\"1/5\", \"5/1\") will return True, because the multiplication of these two fractions results \n    in the whole number 1. On the other hand, simplify(\"1/6\", \"2/1\") will return False, because the multiplication of \n    these two fractions results in the non-whole number 1/3. Similarly, simplify(\"7/10\", \"10/2\") = False because the result \n    of the multiplication operation doesn't yield a whole number.\n    \"\"\"\n    (x_num, x_den) = map(int, x.split('/'))\n    (n_num, n_den) = map(int, n.split('/'))\n    new_num = x_num * n_num\n    new_den = x_den * n_den\n    if new_num % new_den == 0:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/26": [{"task_id": "HumanEval/26", "solution": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    unique_numbers = []\n    for num in numbers:\n        if num not in unique_numbers:\n            unique_numbers.append(num)\n    return unique_numbers", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 2, 4, 3, 5]]], "plus_fail_tests": [[[1, 1, 2, 2, 3, 3, 4, 4]]]}], "HumanEval/20": [{"task_id": "HumanEval/20", "solution": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    This function takes as input a list of numbers (floats), of length at least two, and finds the pair of numbers that are the closest to each other. \n    The function returns this pair of numbers in order, with the smaller number first and the larger number second. \n    \n    If there are multiple pairs with the same smallest difference, the function will return the first pair it encounters.\n\n    The main purpose of this function is to aid in numerical analysis, where finding the smallest difference between pairs of numbers can be useful for things like error detection, curve fitting, and other analysis tasks.\n\n    Args:\n    numbers (List[float]): A list of floating point numbers. The list should contain at least two elements. \n\n    Returns:\n    Tuple[float, float]: A tuple containing two floating point numbers that have the smallest difference among all possible pairs in the input list. The smaller number is returned first.\n\n    Examples:\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    smallest_difference = float('inf')\n    closest_pair = (None, None)\n    for i in range(len(sorted_numbers) - 1):\n        difference = sorted_numbers[i + 1] - sorted_numbers[i]\n        if difference < smallest_difference:\n            smallest_difference = difference\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    return closest_pair", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/6": [{"task_id": "HumanEval/6", "solution": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n\n    def max_depth(s: str) -> int:\n        max_d = d = 0\n        for c in s:\n            if c == '(':\n                d += 1\n                max_d = max(max_d, d)\n            elif c == ')':\n                d -= 1\n        return max_d\n    return [max_depth(s) for s in paren_string.split()]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/51": [{"task_id": "HumanEval/51", "solution": "\n\ndef remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/45": [{"task_id": "HumanEval/45", "solution": "\n\ndef triangle_area(a, h):\n    \"\"\"\n    Calculates and returns the area of a triangle based on the length of one side and the height from that side to the opposite vertex.\n\n    This function takes two parameters: the length of a side (a) and the height (h). The length of a side and the height must be non-negative numbers. If other types of inputs are given, the function may behave unpredictably.\n\n    The area of the triangle is calculated with the formula '0.5 * a * h'. This formula is derived from the geometric characteristics of the triangle.\n\n    Args:\n    a (float): The length of a side of the triangle. Must be a non-negative number.\n    h (float): The height from one side to the opposite vertex. Must be a non-negative number.\n\n    Returns:\n    float: The area of the triangle. Returns a floating point number that represents the calculated area.\n\n    Example:\n    >>> triangle_area(5, 3)\n    7.5\n\n    The example demonstrates that if the length of a side of the triangle is 5 and the height from that side to the opposite vertex is 3, the function returns the area of the triangle, which is 7.5.\n    \"\"\"\n    return 0.5 * a * h", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/89": [{"task_id": "HumanEval/89", "solution": "\ndef encrypt(s):\n    result = ''\n    for char in s:\n        if char.isalpha():\n            shift = 4\n            if char.islower():\n                start = ord('a')\n                result += chr((ord(char) - start + shift) % 26 + start)\n            else:\n                start = ord('A')\n                result += chr((ord(char) - start + shift) % 26 + start)\n        else:\n            result += char\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/114": [{"task_id": "HumanEval/114", "solution": "import math\n\ndef minSubArraySum(nums):\n    current_sum = nums[0]\n    min_sum = nums[0]\n    for i in range(1, len(nums)):\n        current_sum = min(nums[i], current_sum + nums[i])\n        min_sum = min(min_sum, current_sum)\n    return min_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/55": [{"task_id": "HumanEval/55", "solution": "\n\ndef fib(n: int):\n    if n <= 0:\n        raise ValueError('Input should be a positive integer.')\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        (a, b) = (1, 1)\n        for _ in range(n - 2):\n            (a, b) = (b, a + b)\n        return b", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0]]}], "HumanEval/92": [{"task_id": "HumanEval/92", "solution": "\ndef any_int(x, y, z):\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        if x == y + z or y == x + z or z == x + y:\n            return True\n        else:\n            return False\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/77": [{"task_id": "HumanEval/77", "solution": "\ndef iscube(a):\n    cube_root = round(a ** (1.0 / 3))\n    return cube_root ** 3 == abs(a)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[-1]], "plus_fail_tests": [[-8]]}], "HumanEval/46": [{"task_id": "HumanEval/46", "solution": "\n\ndef fib4(n: int):\n    if n < 0:\n        raise ValueError('Input value should be a positive integer.')\n    elif n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    else:\n        fib4_sequence = [0, 0, 2, 0]\n        for i in range(4, n + 1):\n            fib4_sequence.append(fib4_sequence[i - 1] + fib4_sequence[i - 2] + fib4_sequence[i - 3] + fib4_sequence[i - 4])\n        return fib4_sequence[n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/16": [{"task_id": "HumanEval/16", "solution": "\n\ndef count_distinct_characters(string: str) -> int:\n    string = string.lower()\n    distinct_chars = set(string)\n    return len(distinct_chars)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/7": [{"task_id": "HumanEval/7", "solution": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/141": [{"task_id": "HumanEval/141", "solution": "\ndef file_name_check(file_name):\n    if len(re.findall('\\\\d', file_name)) > 3:\n        return 'No'\n    if file_name.count('.') != 1:\n        return 'No'\n    if not re.match('^[a-zA-Z]', file_name.split('.')[0]):\n        return 'No'\n    if file_name.split('.')[0] == '':\n        return 'No'\n    if file_name.split('.')[1] not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["example.txt"]], "plus_fail_tests": [["example.py"]]}], "HumanEval/67": [{"task_id": "HumanEval/67", "solution": "\ndef fruit_distribution(s, n):\n    apples = int(s.split()[0])\n    oranges = int(s.split()[3])\n    mangoes = n - (apples + oranges)\n    return mangoes", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/29": [{"task_id": "HumanEval/29", "solution": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [string for string in strings if string.startswith(prefix)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/36": [{"task_id": "HumanEval/36", "solution": "\n\ndef fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/54": [{"task_id": "HumanEval/54", "solution": "\n\ndef same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/129": [{"task_id": "HumanEval/129", "solution": "\ndef minPath(grid, k):\n    n = len(grid)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    heap = [(grid[0][0], 0, 0, [grid[0][0]])]\n    visited = {(0, 0): grid[0][0]}\n    while heap:\n        (cost, x, y, path) = heapq.heappop(heap)\n        if len(path) == k:\n            return path\n        for (dx, dy) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < n and ((nx, ny) not in visited):\n                visited[nx, ny] = grid[nx][ny]\n                heapq.heappush(heap, (cost + grid[nx][ny], nx, ny, path + [grid[nx][ny]]))\n    return []", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3]], "plus_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1]]}], "HumanEval/145": [{"task_id": "HumanEval/145", "solution": "def order_by_points(nums):\n    return sorted(nums, key=lambda x: (sum((int(digit) for digit in str(abs(x)))), nums.index(x)))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 11, -1, -11, -12]]], "plus_fail_tests": [[[-5, -12, 9, 15]]]}], "HumanEval/59": [{"task_id": "HumanEval/59", "solution": "\n\ndef largest_prime_factor(n: int):\n    factor = 2\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n    return n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/153": [{"task_id": "HumanEval/153", "solution": "\ndef Strongest_Extension(class_name, extensions):\n    strongest_ext = extensions[0]\n    strongest_strength = sum([1 if c.isupper() else -1 for c in extensions[0]])\n    for ext in extensions[1:]:\n        strength = sum([1 if c.isupper() else -1 for c in ext])\n        if strength > strongest_strength:\n            strongest_ext = ext\n            strongest_strength = strength\n    return f'{class_name}.{strongest_ext}'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Watashi", ["tEN", "niNE", "eIGHt8OKe"]]], "plus_fail_tests": [["Test4", ["ALLUPPERcaseletters", "ALLlowercaseletters", "Nolettersatall123", "12345"]]]}], "HumanEval/78": [{"task_id": "HumanEval/78", "solution": "\ndef hex_key(num):\n    prime_hexes = set('2357BD')\n    count = 0\n    for char in num:\n        if char in prime_hexes:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/69": [{"task_id": "HumanEval/69", "solution": "\ndef search(lst):\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    result = -1\n    for (num, freq) in freq_dict.items():\n        if num > 0 and freq >= num and (num > result):\n            result = num\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/122": [{"task_id": "HumanEval/122", "solution": "\ndef add_elements(arr, k):\n    total = 0\n    for i in range(k):\n        if arr[i] >= 0 and arr[i] <= 99:\n            total += arr[i]\n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, -2, -3, 41, 57, 76, 87, 88, 99], 3]], "plus_fail_tests": [[[-4, 5, 67, 34, 56, 12, 89, 23, 45], 7]]}], "HumanEval/11": [{"task_id": "HumanEval/11", "solution": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    if len(a) != len(b):\n        raise ValueError('Input strings must be of equal length')\n    result = ''\n    for (char_a, char_b) in zip(a, b):\n        if char_a not in '01' or char_b not in '01':\n            raise ValueError(\"Input strings must contain only '1's and '0's\")\n        result += str(int(char_a) ^ int(char_b))\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/2": [{"task_id": "HumanEval/2", "solution": "\n\ndef truncate_number(number: float) -> float:\n    return number - int(number)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/103": [{"task_id": "HumanEval/103", "solution": "\ndef rounded_avg(n, m):\n    if n > m:\n        return -1\n    else:\n        total = sum(range(n, m + 1))\n        avg = total / (m - n + 1)\n        rounded_avg = round(avg)\n        return bin(rounded_avg)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/138": [{"task_id": "HumanEval/138", "solution": "\ndef is_equal_to_sum_even(n):\n    if n % 2 == 1:\n        return False\n    elif n < 10:\n        return False\n    else:\n        return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[8]], "plus_fail_tests": [[8]]}], "HumanEval/5": [{"task_id": "HumanEval/5", "solution": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    result = []\n    for number in numbers:\n        result += [number, delimeter]\n    return result[:-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/161": [{"task_id": "HumanEval/161", "solution": "\ndef solve(s):\n    has_letter = any((c.isalpha() for c in s))\n    if has_letter:\n        return ''.join((c.upper() if c.islower() else c.lower() if c.isupper() else c for c in s))\n    else:\n        return s[::-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/61": [{"task_id": "HumanEval/61", "solution": "\n\ndef correct_bracketing(brackets: str) -> bool:\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif bracket == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/127": [{"task_id": "HumanEval/127", "solution": "\ndef intersection(interval1, interval2):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    if start <= end:\n        length = end - start\n        if is_prime(length):\n            return 'YES'\n    return 'NO'", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/30": [{"task_id": "HumanEval/30", "solution": "\n\ndef get_positive(l: list):\n    return [num for num in l if num > 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/160": [{"task_id": "HumanEval/160", "solution": "\ndef do_algebra(operator, operand):\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += ' ' + operator[i] + ' ' + str(operand[i + 1])\n    return eval(expression)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/27": [{"task_id": "HumanEval/27", "solution": "\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/85": [{"task_id": "HumanEval/85", "solution": "\ndef add(lst):\n    total = 0\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/151": [{"task_id": "HumanEval/151", "solution": "\ndef double_the_difference(lst):\n    sum_of_squares = 0\n    for num in lst:\n        if isinstance(num, int) and num > 0 and (num % 2 != 0):\n            sum_of_squares += num ** 2\n    return sum_of_squares", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/113": [{"task_id": "HumanEval/113", "solution": "\ndef odd_count(lst):\n    output = []\n    for (i, s) in enumerate(lst):\n        count = sum((1 for c in s if int(c) % 2 != 0))\n        result_string = 'the number of odd elements {0}n the str{0}ng {0} of the {0}nput.'.format(count)\n        output.append(result_string)\n    return output", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/142": [{"task_id": "HumanEval/142", "solution": "def sum_squares(lst):\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            lst[i] = lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            lst[i] = lst[i] ** 3\n    return sum(lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/134": [{"task_id": "HumanEval/134", "solution": "\ndef check_if_last_char_is_a_letter(txt):\n    if not txt or txt.split()[-1] == '':\n        return False\n    elif txt.split()[-1][-1].isalpha():\n        return True\n    else:\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["apple"]], "plus_fail_tests": [["pUMPKIN PIE"]]}], "HumanEval/28": [{"task_id": "HumanEval/28", "solution": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    return ''.join(strings)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/38": [{"task_id": "HumanEval/38", "solution": "\ndef encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n    \ndef decode_cyclic(s: str):\n    \"\"\"\n    returns decoded string by reversing the cycling groups of three characters.\n    \"\"\"\n    groups = [s[3 * i:min(3 * i + 3, len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [group[-1] + group[:-1] if len(group) == 3 else group for group in groups]\n    return ''.join(groups)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/42": [{"task_id": "HumanEval/42", "solution": "\n\ndef incr_list(l: list):\n    return [x + 1 for x in l]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/12": [{"task_id": "HumanEval/12", "solution": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    longest_string = strings[0]\n    for string in strings[1:]:\n        if len(string) > len(longest_string):\n            longest_string = string\n    return longest_string", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/18": [{"task_id": "HumanEval/18", "solution": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    count = 0\n    start = 0\n    while start < len(string):\n        pos = string.find(substring, start)\n        if pos != -1:\n            start = pos + 1\n            count += 1\n        else:\n            break\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/53": [{"task_id": "HumanEval/53", "solution": "\n\ndef add(x: int, y: int):\n    \"\"\"\n    The function 'add' takes in two arguments, 'x' and 'y', both of which are integers.\n    It calculates the sum of these two integers and returns the result.\n    It demonstrates the basic operation of addition in Python, and is a fundamental building block in many more complex algorithms.\n    \n    Args:\n    x (int): The first integer to be added.\n    y (int): The second integer to be added.\n\n    Returns:\n    The result of the addition operation, which is the sum of 'x' and 'y'.\n\n    Examples:\n    >>> add(2, 3)\n    5\n    This means that if we input 2 and 3 into the function, it will return 5.\n\n    >>> add(5, 7)\n    12\n    This means that if we input 5 and 7 into the function, it will return 12.\n    \"\"\"\n    return x + y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/139": [{"task_id": "HumanEval/139", "solution": "\ndef special_factorial(n):\n    if n < 0:\n        raise ValueError('Input should be a non-negative integer.')\n    if n == 0:\n        return 1\n    else:\n        result = 1\n        for i in range(n, 0, -1):\n            result *= factorial(i)\n        return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[4]], "plus_fail_tests": [[2]]}], "HumanEval/111": [{"task_id": "HumanEval/111", "solution": "\ndef histogram(test):\n    frequency = {}\n    for letter in test:\n        if letter != ' ':\n            if letter in frequency:\n                frequency[letter] += 1\n            else:\n                frequency[letter] = 1\n    max_freq = max(frequency.values()) if frequency else 0\n    frequency = {key: value for (key, value) in frequency.items() if value == max_freq}\n    return frequency", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/106": [{"task_id": "HumanEval/106", "solution": "\ndef f(n):\n\n    def factorial(i):\n        if i == 0 or i == 1:\n            return 1\n        else:\n            return i * factorial(i - 1)\n\n    def sum_numbers(i):\n        return i * (i + 1) // 2\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(sum_numbers(i))\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/32": [{"task_id": "HumanEval/32", "solution": "\nimport math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n    \ndef find_zero(xs: list):\n    \"\"\"\n    This function, find_zero, processes a list, xs, which contains the coefficients of a polynomial. The order of the coefficients\n    should align with the degree of the terms of the polynomial, from the constant term to the highest degree term.\n\n    The purpose of find_zero is to determine a value x such that when it is substituted into the polynomial, the result of the resulting calculation equals 0.\n    This represents one of the roots of the polynomial expression, where the curve represented by the polynomial intersects the x-axis.\n\n    Despite polynomials potentially having multiple roots (zero points), this function will return only one of them. This is due to its intended purpose,\n    which is to quickly identify a single root rather than find all of them.\n\n    For the function to guarantee a valid root or zero point, it only accepts input lists, xs, that contain an even number of coefficients. These coefficients\n    should include a largest non-zero coefficient. As these features would assure the polynomial has at least one root.\n\n    Thus, this function helps to find a root for polynomial functions in a simple and quick manner with certain assumptions about the polynomial's properties\n    based on the input coefficient list.\n\n    Examples:\n    >>> round(find_zero([1, 2]), 2) # For the polynomial f(x) = 1 + 2x, one of the roots is x = -0.5\n    -0.5\n\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # For the polynomial f(x) = -6 + 11x - 6x^2 + x^3 which expands to (x - 1) * (x - 2) * (x - 3), one of the roots is x = 1.0\n    1.0\n    \"\"\"\n    degree = len(xs) - 1\n    x = 0\n    while abs(poly(xs, x)) > 1e-06:\n        derivative_at_x = sum([i * coeff * math.pow(x, i - 1) for (i, coeff) in enumerate(xs)])\n        x -= poly(xs, x) / derivative_at_x\n    return x", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-10, -2]]], "plus_fail_tests": [[[5, 10, -3, 1]]]}], "HumanEval/143": [{"task_id": "HumanEval/143", "solution": "\ndef words_in_sentence(sentence):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/91": [{"task_id": "HumanEval/91", "solution": "\ndef is_bored(S):\n    termination_marks = ['.', '?', '!']\n    boredom_count = 0\n    start_index = 0\n    for i in range(len(S)):\n        if S[i] in termination_marks:\n            next_word = S[i + 1:].lstrip(' ').split(' ')[0]\n            if next_word == 'I':\n                boredom_count += 1\n            start_index = i + 1\n    return boredom_count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["I love It !"]], "plus_fail_tests": [["I am very happy today. I love spending time with my friends."]]}], "HumanEval/121": [{"task_id": "HumanEval/121", "solution": "\ndef solution(lst):\n    return sum((value for (index, value) in enumerate(lst) if index % 2 == 0 and value % 2 != 0))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/24": [{"task_id": "HumanEval/24", "solution": "def largest_divisor(n: int) -> int:\n    for i in range(n - 1, 1, -1):\n        if n % i == 0:\n            return i\n    return 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/9": [{"task_id": "HumanEval/9", "solution": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    result = []\n    max_num = float('-inf')\n    for num in numbers:\n        max_num = max(max_num, num)\n        result.append(max_num)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/49": [{"task_id": "HumanEval/49", "solution": "\n\ndef modp(n: int, p: int):\n    \"\"\"\n    This function calculates the modulus of the power of 2 raised to a given integer, n, by another given integer, p. \n    The operation performed is 2^n modulo p. This function can be used for calculations involving large powers and moduli,\n    but it's important to keep numerical stability in mind.\n\n    Parameters:\n    n (int): This is the exponent to which 2 is raised. This must be a non-negative integer.\n    p (int): This is the modulus. It must be a positive integer.\n\n    Returns:\n    int: The result of the operation 2^n modulo p is returned as an integer.\n    \"\"\"\n    return pow(2, n, p)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/22": [{"task_id": "HumanEval/22", "solution": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" \n    This function filters a given list of any type of Python values and returns a list of integers only. \n\n    The input to the function is a list that can contain any type of Python values such as numbers, strings, dictionaries, lists, etc. The function will go through each element in the list and keep only those that are integers. The output will be a new list with the integers from the input list. Any non-integer values in the input list will be discarded. \n\n    If the input list is empty, the function will return an empty list. If the input list contains no integer values, the function will also return an empty list. \n\n    Parameters:\n    values (List[Any]): A list of any Python values\n\n    Returns:\n    List[int]: A list containing only integers from the input list\n\n    Examples:\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n\n    Note: The function does not modify the original list, it returns a new list.\n    \"\"\"\n    return [value for value in values if type(value) == int]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/21": [{"task_id": "HumanEval/21", "solution": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/80": [{"task_id": "HumanEval/80", "solution": "\ndef is_happy(s):\n    if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/136": [{"task_id": "HumanEval/136", "solution": "\ndef largest_smallest_integers(lst):\n    negative_numbers = sorted([i for i in lst if i < 0], reverse=True)\n    positive_numbers = sorted([i for i in lst if i > 0])\n    a = negative_numbers[0] if negative_numbers else None\n    b = positive_numbers[0] if positive_numbers else None\n    return (a, b)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/0": [{"task_id": "HumanEval/0", "solution": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/140": [{"task_id": "HumanEval/140", "solution": "\ndef fix_spaces(text):\n    result = ''\n    consecutive_spaces = 0\n    for char in text:\n        if char != ' ':\n            if consecutive_spaces == 0:\n                result += char\n            else:\n                result += '-'\n                consecutive_spaces = 0\n        else:\n            consecutive_spaces += 1\n    return result.replace(' ', '_')", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Mudasir Hanif "]], "plus_fail_tests": [["Hello,   world!"]]}], "HumanEval/40": [{"task_id": "HumanEval/40", "solution": "def triples_sum_to_zero(l: list):\n    l.sort()\n    for i in range(len(l) - 2):\n        if i > 0 and l[i] == l[i - 1]:\n            continue\n        left = i + 1\n        right = len(l) - 1\n        while left < right:\n            current_sum = l[i] + l[left] + l[right]\n            if current_sum < 0:\n                left += 1\n            elif current_sum > 0:\n                right -= 1\n            else:\n                return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/109": [{"task_id": "HumanEval/109", "solution": "\ndef move_one_ball(arr):\n    if not arr:\n        return True\n    n = len(arr)\n    inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inversions += 1\n    return inversions % 2 == 0", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[8, 7, 6, 5, 4, 3, 2, 1]]]}], "HumanEval/58": [{"task_id": "HumanEval/58", "solution": "\n\ndef common(l1: list, l2: list):\n    common_set = set(l1) & set(l2)\n    common_list = sorted(list(common_set))\n    return common_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/41": [{"task_id": "HumanEval/41", "solution": "\n\ndef car_race_collision(n: int):\n    return n * n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/123": [{"task_id": "HumanEval/123", "solution": "\ndef get_odd_collatz(n):\n\n    def collatz(n):\n        while n != 1:\n            if n % 2 == 0:\n                n = n // 2\n            else:\n                n = 3 * n + 1\n        return [1]\n    collatz_sequence = collatz(n)\n    odd_numbers = [i for i in collatz_sequence if i % 2 != 0]\n    return sorted(odd_numbers)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[14]], "plus_fail_tests": [[3]]}], "HumanEval/52": [{"task_id": "HumanEval/52", "solution": "\n\ndef below_threshold(l: list, t: int) -> bool:\n    for num in l:\n        if num >= t:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/33": [{"task_id": "HumanEval/33", "solution": "\n\ndef sort_third(l: list):\n    sorted_elements = sorted((element for (index, element) in enumerate(l) if index % 3 == 0))\n    return [sorted_elements.pop(0) if index % 3 == 0 else element for (index, element) in enumerate(l)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/3": [{"task_id": "HumanEval/3", "solution": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/128": [{"task_id": "HumanEval/128", "solution": "\ndef prod_signs(arr):\n    if len(arr) == 0:\n        return None\n    else:\n        sum_abs = sum([abs(x) for x in arr])\n        prod_sign = 1\n        for x in arr:\n            if x < 0:\n                prod_sign *= -1\n            elif x > 0:\n                prod_sign *= 1\n        return sum_abs * prod_sign", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[0, 1]]], "plus_fail_tests": [[[-1, 0, 1, 2]]]}], "HumanEval/1": [{"task_id": "HumanEval/1", "solution": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    groups = []\n    count = 0\n    start = 0\n    for (index, char) in enumerate(paren_string):\n        if char == '(':\n            if count == 0:\n                start = index\n            count += 1\n        elif char == ')':\n            count -= 1\n            if count == 0:\n                groups.append(paren_string[start:index + 1])\n    return groups", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/115": [{"task_id": "HumanEval/115", "solution": "\ndef max_fill(grid, capacity):\n    total_water = sum((row.count(1) for row in grid))\n    return total_water // capacity + (total_water % capacity > 0)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 1, 1, 1], [1, 1, 1, 1]], 9]], "plus_fail_tests": [[[[1, 0, 0, 1], [0, 1, 1, 1], [0, 0, 0, 0], [1, 0, 1, 1]], 2]]}], "HumanEval/62": [{"task_id": "HumanEval/62", "solution": "\n\ndef derivative(xs: list):\n    \"\"\"\n    This function computes the derivative of a polynomial represented by its coefficients.\n    \n    The input argument 'xs' is a list that contains the coefficients of a polynomial. Each element in the\n    list corresponds to the coefficient of a polynomial term. The index of the coefficient in the list \n    determines the power of the term it is associated with. \n\n    In other words, the polynomial is represented as follows: xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    \n    The function will return a list of coefficients that represents the derivative of this polynomial. The \n    derivative is represented in the same form as the input polynomial. \n\n    Here are a couple of examples to illustrate the functionality of this function.\n\n    If the input is [3, 1, 2, 4, 5], the function will return [1, 4, 12, 20]. This is because the original \n    polynomial is 3 + x + 2x^2 + 4x^3 + 5x^4, and its derivative is 1 + 4x + 12x^2 + 20x^3\n\n    If the input is [1, 2, 3], the function will return [2, 6]. This is because the original polynomial is \n    1 + 2x + 3x^2, and its derivative is 2 + 6x.\n\n    Args:\n    xs: A list of numbers representing the coefficients of a polynomial.\n\n    Returns:\n    A list of numbers representing the coefficients of the derivative of the input polynomial.\n    \"\"\"\n    return [i * xs[i] for i in range(1, len(xs))]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/131": [{"task_id": "HumanEval/131", "solution": "\ndef digits(n):\n    product = 1\n    has_odd = False\n    for digit in str(n):\n        if int(digit) % 2 != 0:\n            product *= int(digit)\n            has_odd = True\n    return product if has_odd else 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/112": [{"task_id": "HumanEval/112", "solution": "\ndef reverse_delete(s, c):\n    for char in c:\n        s = s.replace(char, '')\n    is_palindrome = s == s[::-1]\n    return (s, is_palindrome)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/148": [{"task_id": "HumanEval/148", "solution": "\ndef bf(planet1, planet2):\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    else:\n        planet1_index = planets.index(planet1)\n        planet2_index = planets.index(planet2)\n        if planet1_index < planet2_index:\n            return tuple(planets[planet1_index + 1:planet2_index])\n        else:\n            return tuple(planets[planet2_index + 1:planet1_index])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/57": [{"task_id": "HumanEval/57", "solution": "\n\ndef monotonic(l: list):\n    if len(l) < 2:\n        return True\n    increasing = None\n    for i in range(len(l) - 1):\n        diff = l[i + 1] - l[i]\n        if diff == 0:\n            continue\n        if increasing is None:\n            increasing = diff > 0\n        elif (diff > 0) != increasing:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/65": [{"task_id": "HumanEval/65", "solution": "\ndef circular_shift(x, shift):\n    str_x = str(x)\n    if shift >= len(str_x):\n        return str_x[::-1]\n    if shift == len(str_x):\n        return str_x\n    return str_x[-shift:] + str_x[:-shift]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[12, 2]], "plus_fail_tests": [[987654321, 9]]}], "HumanEval/137": [{"task_id": "HumanEval/137", "solution": "def compare_one(a, b):\n    a = float(str(a).replace(',', '.'))\n    b = float(str(b).replace(',', '.'))\n    if a > b:\n        return a if isinstance(a, str) else b\n    elif b > a:\n        return b if isinstance(b, str) else a\n    else:\n        return None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, 2]], "plus_fail_tests": [[-2.5, 2.5]]}], "HumanEval/118": [{"task_id": "HumanEval/118", "solution": "\ndef get_closest_vowel(word):\n    vowels = 'AEIOUaeiou'\n    candidate_vowels = []\n    for i in range(len(word) - 2, -1, -1):\n        if word[i] in vowels and word[i + 1] not in vowels and (word[i + 2] not in vowels):\n            candidate_vowels.append(word[i])\n    if candidate_vowels:\n        return candidate_vowels[0]\n    else:\n        return ''", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["easy"]], "plus_fail_tests": [["cup"]]}], "HumanEval/116": [{"task_id": "HumanEval/116", "solution": "\ndef sort_array(arr):\n    arr.sort()\n    arr.sort(key=lambda x: bin(x).count('1'))\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/34": [{"task_id": "HumanEval/34", "solution": "\n\ndef unique(l: list):\n    \"\"\"\n    This function is responsible for returning a sorted list of unique elements present in the input list. \n\n    It receives a list, 'l', as an input argument. This list can contain any number of elements and these elements may or may not be unique.\n\n    The function iterates over the elements of the input list and identifies the unique elements. Once all the unique elements are identified, they are sorted in ascending order.\n\n    The sorted list of unique elements is then returned as the output of the function.\n\n    Here is an example to demonstrate the usage of the function:\n\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    The function will return the following output:\n    [0, 2, 3, 5, 9, 123]\n\n    As it can be observed in the above example, the function has removed all the duplicate values from the list (for example, 3 and 5 that were present multiple times) and returned a sorted list of the unique values.\n    \"\"\"\n    return sorted(set(l))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/162": [{"task_id": "HumanEval/162", "solution": "\ndef string_to_md5(text):\n    if text == '':\n        return None\n    else:\n        hash_object = hashlib.md5(text.encode())\n        return hash_object.hexdigest()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Hello world"]], "plus_fail_tests": [["5873hajsdklh"]]}], "HumanEval/79": [{"task_id": "HumanEval/79", "solution": "\ndef decimal_to_binary(decimal):\n    binary = bin(decimal)[2:]\n    return f'db{binary}db'", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/50": [{"task_id": "HumanEval/50", "solution": "\ndef encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    returns decoded string by shifting every character by -5 in the alphabet.\n    \"\"\"\n    return ''.join([chr((ord(ch) - 5 - ord('a')) % 26 + ord('a')) for ch in s])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/31": [{"task_id": "HumanEval/31", "solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[123456791]]}], "HumanEval/83": [{"task_id": "HumanEval/83", "solution": "\ndef starts_one_ends(n):\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    else:\n        return 2 * 10 ** (n - 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[6]]}], "HumanEval/63": [{"task_id": "HumanEval/63", "solution": "\ndef fibfib(n: int):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        (a, b, c) = (0, 0, 1)\n        for _ in range(3, n + 1):\n            (a, b, c) = (b, c, a + b + c)\n        return c", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/64": [{"task_id": "HumanEval/64", "solution": "def vowels_count(s):\n    vowels = 'aeiou'\n    s = s.lower()\n    count = sum((1 for char in s if char in vowels))\n    if s[-1] == 'y':\n        count += 1\n    return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "HumanEval/158": [{"task_id": "HumanEval/158", "solution": "\ndef find_max(words):\n    max_unique_chars = 0\n    max_word = ''\n    for word in words:\n        if len(set(word)) > max_unique_chars:\n            max_unique_chars = len(set(word))\n            max_word = word\n        elif len(set(word)) == max_unique_chars:\n            max_word = min(word, max_word)\n    return max_word", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/19": [{"task_id": "HumanEval/19", "solution": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    number_map = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    numeric_values = [number_map[number] for number in numbers.split()]\n    numeric_values.sort()\n    sorted_names = [key for (key, value) in number_map.items() if value in numeric_values]\n    return ' '.join(sorted_names)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["two two three three four five six"]]}], "HumanEval/155": [{"task_id": "HumanEval/155", "solution": "\ndef even_odd_count(num):\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(num)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/17": [{"task_id": "HumanEval/17", "solution": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    beat_mapping = {'o': 4, 'o|': 2, '.|': 1}\n    beats = []\n    i = 0\n    while i < len(music_string):\n        if music_string[i:i + 2] in beat_mapping:\n            beats.append(beat_mapping[music_string[i:i + 2]])\n            i += 2\n        elif music_string[i] in beat_mapping:\n            beats.append(beat_mapping[music_string[i]])\n            i += 1\n        else:\n            i += 1\n    return beats", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/74": [{"task_id": "HumanEval/74", "solution": "\ndef total_match(lst1, lst2):\n    count_lst1 = sum((len(s) for s in lst1))\n    count_lst2 = sum((len(s) for s in lst2))\n    if count_lst1 <= count_lst2:\n        return lst1\n    else:\n        return lst2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/163": [{"task_id": "HumanEval/163", "solution": "\ndef generate_integers(a, b):\n    lower = min(a, b)\n    upper = max(a, b)\n    even_integers = [i for i in range(lower, upper + 1) if i % 2 == 0]\n    return even_integers", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2, 10]], "plus_fail_tests": [[6, 12]]}], "HumanEval/8": [{"task_id": "HumanEval/8", "solution": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers:\n        return (0, 1)\n    else:\n        sum_num = sum(numbers)\n        product_num = 1\n        for num in numbers:\n            product_num *= num\n        return (sum_num, product_num)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/154": [{"task_id": "HumanEval/154", "solution": "\ndef cycpattern_check(a, b):\n    for i in range(len(b)):\n        if b in a:\n            return True\n        else:\n            b = b[-1] + b[:-1]\n    return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["", ""]]}], "HumanEval/133": [{"task_id": "HumanEval/133", "solution": "\n\ndef sum_squares(lst):\n    sum_of_squares = 0\n    for i in lst:\n        sum_of_squares += math.ceil(i) ** 2\n    return sum_of_squares", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3]]], "plus_fail_tests": [[[-3, 4, 5, 6, 7]]]}], "HumanEval/149": [{"task_id": "HumanEval/149", "solution": "\ndef sorted_list_sum(lst):\n    lst[:] = [s for s in lst if len(s) % 2 == 0]\n    lst.sort(key=lambda s: (len(s), s))\n    return lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/135": [{"task_id": "HumanEval/135", "solution": "def can_arrange(arr):\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            return i\n    return -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[4, 8, 5, 7, 3]]], "plus_fail_tests": [[[5, 4, 3, 2, 1]]]}], "HumanEval/48": [{"task_id": "HumanEval/48", "solution": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Function to determine whether a given string ('text') is a palindrome or not.\n\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward\n\n    This function takes a string as an argument and returns a boolean value. If the 'text' string is a palindrome, the function returns True. If the 'text' string is not a palindrome, the function returns False.\n\n    Parameters:\n    text (str): The string to check for palindrome properties. This should be a sequence of characters. It could be a single word, a phrase, or a number as a string.\n\n    Returns:\n    bool: True if the 'text' is a palindrome. False otherwise.\n\n    Examples:\n    >>> is_palindrome('')\n    True\n    This is because an empty string is considered a palindrome as there are no characters to compare.\n\n    >>> is_palindrome('aba')\n    True\n    This is because 'aba' is a palindrome as it reads the same forward and backward.\n\n    >>> is_palindrome('aaaaa')\n    True\n    This is because 'aaaaa' is a palindrome as all the characters are the same.\n\n    >>> is_palindrome('zbcd')\n    False\n    This is because 'zbcd' is not a palindrome as it does not read the same forward and backward.\n    \"\"\"\n    return text == text[::-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/39": [{"task_id": "HumanEval/39", "solution": "\n\ndef prime_fib(n):\n    (a, b) = (0, 1)\n    count = 0\n    while count < n:\n        (a, b) = (b, a + b)\n        if is_prime(b):\n            count += 1\n    return b", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1]], "plus_fail_tests": [[11]]}], "HumanEval/152": [{"task_id": "HumanEval/152", "solution": "\ndef compare(game, guess):\n    result = []\n    for i in range(len(game)):\n        result.append(abs(game[i] - guess[i]))\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/99": [{"task_id": "HumanEval/99", "solution": "\ndef closest_integer(value):\n    value = float(value)\n    if value >= 0:\n        return int(value + 0.5)\n    else:\n        return int(value - 0.5)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/132": [{"task_id": "HumanEval/132", "solution": "\ndef is_nested(string):\n    stack = []\n    for bracket in string:\n        if bracket == '[':\n            stack.append(bracket)\n        else:\n            if len(stack) == 0 or stack[-1] != '[':\n                return False\n            stack.pop()\n    return len(stack) > 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["[[]]"]], "plus_fail_tests": [["[[]][]"]]}], "HumanEval/70": [{"task_id": "HumanEval/70", "solution": "\ndef strange_sort_list(lst):\n    lst.sort()\n    result = []\n    pop_from_end = False\n    while lst:\n        if pop_from_end:\n            result.append(lst.pop())\n        else:\n            result.append(lst.pop(0))\n        pop_from_end = not pop_from_end\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/10": [{"task_id": "HumanEval/10", "solution": "\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that can be formed beginning with a supplied string.\n\n    This function uses a simple algorithm to determine how to make the given string into a palindrome, which\n    is a string that reads the same forward and backward. The algorithm proceeds through the following steps:\n    1. It first finds the longest suffix (ending segment) of the supplied string that itself is a palindrome.\n    2. It then appends to the end of the original string the reversed string of the prefix \n       (beginning segment) that comes before this palindromic suffix. \n\n    As a result, the returning string is the shortest possible palindrome that starts with the given string.\n    Should the input string already be a palindrome, the function will simply return the original string.\n\n    This function is case-sensitive and does not alter the case of the lettering in the original string.\n\n    Parameters:\n    string (str): The string to be made into a palindrome.\n\n    Returns:\n    str: The shortest possible palindrome that starts with the input string.\n\n    Doctest:\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    if is_palindrome(string):\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string + string[::-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/159": [{"task_id": "HumanEval/159", "solution": "\ndef eat(number, need, remaining):\n    if remaining >= need:\n        return [number + need, remaining - need]\n    else:\n        return [number + remaining, 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/56": [{"task_id": "HumanEval/56", "solution": "\n\ndef correct_bracketing(brackets: str) -> bool:\n    stack = []\n    for bracket in brackets:\n        if bracket == '<':\n            stack.append(bracket)\n        else:\n            if len(stack) == 0 or stack[-1] != '<':\n                return False\n            stack.pop()\n    return len(stack) == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/126": [{"task_id": "HumanEval/126", "solution": "def is_sorted(lst):\n    if lst != sorted(lst):\n        return False\n    else:\n        for i in range(len(lst)):\n            if lst.count(lst[i]) > 1:\n                return False\n        return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 2, 3, 3, 4]]], "plus_fail_tests": [[[1, 1, 2, 2, 3, 3, 4]]]}], "HumanEval/117": [{"task_id": "HumanEval/117", "solution": "\ndef select_words(s, n):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    words = s.split()\n    selected_words = []\n    for word in words:\n        consonants = [letter for letter in word if letter.lower() not in vowels]\n        if len(consonants) == n:\n            selected_words.append(word)\n    return selected_words", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/150": [{"task_id": "HumanEval/150", "solution": "\ndef x_or_y(n, x, y):\n    if n > 1:\n        for i in range(2, n):\n            if n % i == 0:\n                return y\n        else:\n            return x\n    else:\n        return y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/76": [{"task_id": "HumanEval/76", "solution": "\ndef is_simple_power(x, n):\n    if n == 1:\n        return x == 1\n    else:\n        i = 0\n        while n ** i < x:\n            i += 1\n        return n ** i == x", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-2, -2]]}], "HumanEval/37": [{"task_id": "HumanEval/37", "solution": "\n\ndef sort_even(l: list):\n    even_indices_elements = [l[i] for i in range(0, len(l), 2)]\n    even_indices_elements.sort()\n    sorted_list = l.copy()\n    for i in range(0, len(sorted_list), 2):\n        sorted_list[i] = even_indices_elements[i // 2]\n    return sorted_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/90": [{"task_id": "HumanEval/90", "solution": "\ndef next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    else:\n        min1 = min(lst)\n        lst = [i for i in lst if i != min1]\n        if len(lst) < 2:\n            return None\n        else:\n            return min(lst)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[4, 4, 4, 5, 4, 4, 4]]]}], "HumanEval/130": [{"task_id": "HumanEval/130", "solution": "\ndef tri(n):\n    if n < 0:\n        raise ValueError('Input must be a non-negative integer.')\n    elif n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    elif n == 2:\n        return [1, 3, 2]\n    else:\n        sequence = [1, 3, 2]\n        for i in range(3, n + 1):\n            if i % 2 == 0:\n                sequence.append(1 + i // 2)\n            else:\n                sequence.append(sequence[i - 1] + sequence[i - 2] + sequence[i + 1])\n        return sequence", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[2]]}], "HumanEval/94": [{"task_id": "HumanEval/94", "solution": "\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/15": [{"task_id": "HumanEval/15", "solution": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\"\n    This function, string_sequence, takes an integer 'n' as an input and returns a string.\n    \n    The function generates a sequence of integers within the range of 0 to n (inclusive of both). \n    The sequence is then converted to a string format with each number separated by a space.\n    \n    The purpose of this function is to create a string representation of a sequence of numbers, \n    which could be useful in a variety of applications where such formatted numerical data is required.\n    \n    Parameters:\n    n (int): A non-negative integer that defines the upper limit of the sequence. \n    \n    Returns:\n    str: A string representing a sequence of space-separated numbers from 0 to n inclusive.\n    \n    Examples:\n    If the function is called with an argument of 0, it will return a string '0'. \n    >>> string_sequence(0)\n    '0'\n    \n    If the function is called with an argument of 5, it will return a string '0 1 2 3 4 5'. \n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n    return ' '.join((str(i) for i in range(n + 1)))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/25": [{"task_id": "HumanEval/25", "solution": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1 if divisor == 2 else 2\n    return factors", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[123456791]]}]}}