{"eval": {"EvoEval/83": [{"task_id": "EvoEval/83", "solution": "\ndef starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start with 1 or end with 2.\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        return 10 ** (n - 1) + 10 ** (n - 2)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1]], "plus_fail_tests": []}], "EvoEval/55": [{"task_id": "EvoEval/55", "solution": "\ndef fib(n: int):\n    if n <= 0:\n        return 'Input should be a positive integer.'\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        (a, b) = (0, 1)\n        for _ in range(2, n):\n            (a, b) = (b, a + b)\n        return b", "base_status": "fail", "plus_status": null, "base_fail_tests": [[10]], "plus_fail_tests": []}], "EvoEval/31": [{"task_id": "EvoEval/31", "solution": "\n\ndef is_prime(n):\n    if n < 2:\n        return 'Invalid Input'\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/76": [{"task_id": "EvoEval/76", "solution": "\ndef is_simple_power(x, n):\n    if n == 1:\n        return (False, None)\n    power = 0\n    while n ** power < x:\n        power += 1\n    if n ** power == x:\n        return (True, power)\n    else:\n        return (False, None)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1, 1]], "plus_fail_tests": []}], "EvoEval/82": [{"task_id": "EvoEval/82", "solution": "\ndef prime_length(string):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    return is_prime(len(string.replace(' ', '')))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/92": [{"task_id": "EvoEval/92", "solution": "\ndef any_int(x, y, z):\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        if x == abs(y) + abs(z) or y == abs(x) + abs(z) or z == abs(x) + abs(y):\n            return True\n        else:\n            return False\n    else:\n        return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/25": [{"task_id": "EvoEval/25", "solution": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    factors = []\n    for i in range(2, n + 1):\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n    return factors", "base_status": "fail", "plus_status": null, "base_fail_tests": [[57]], "plus_fail_tests": []}], "EvoEval/35": [{"task_id": "EvoEval/35", "solution": "\ndef min_element(l: list):\n    \"\"\"Return minimum element in the list.\n    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/89": [{"task_id": "EvoEval/89", "solution": "\ndef encrypt(s):\n    result = ''\n    for i in s:\n        if i.isalpha():\n            shift = 2\n            char_code = ord(i) + shift\n            if i.isupper():\n                if char_code > ord('Z'):\n                    char_code -= 26\n            elif char_code > ord('z'):\n                char_code -= 26\n            result += chr(char_code)\n        else:\n            result += i\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["hi"]], "plus_fail_tests": []}], "EvoEval/57": [{"task_id": "EvoEval/57", "solution": "\n\ndef monotonic(l: list):\n    if len(l) == 0:\n        return False\n    if len(l) == 1:\n        return True\n    if l[0] <= l[1]:\n        for i in range(2, len(l)):\n            if l[i - 1] > l[i]:\n                return False\n        return True\n    else:\n        for i in range(2, len(l)):\n            if l[i - 1] < l[i]:\n                return False\n        return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[5, 5, 1, 1, -7, -7]]], "plus_fail_tests": []}], "EvoEval/65": [{"task_id": "EvoEval/65", "solution": "\ndef circular_shift(x, shift):\n    digits = [int(d) for d in str(x)]\n    if shift >= len(digits):\n        return str(x)[::-1]\n    else:\n        return str(digits[shift:] + digits[:shift])", "base_status": "fail", "plus_status": null, "base_fail_tests": [[100, 2]], "plus_fail_tests": []}], "EvoEval/91": [{"task_id": "EvoEval/91", "solution": "\ndef is_bored(S):\n    sentences = []\n    temp_sentence = ''\n    for char in S:\n        if char not in '.?!':\n            temp_sentence += char\n        else:\n            sentences.append(temp_sentence.strip())\n            temp_sentence = ''\n    sentences.append(temp_sentence.strip())\n    boredom_count = 0\n    for sentence in sentences:\n        if sentence.startswith('I') and sentence.endswith('boredom'):\n            boredom_count += 1\n    return boredom_count", "base_status": "fail", "plus_status": null, "base_fail_tests": [["The sky is blue. The sun is shining. Iris is experiencing boredom"]], "plus_fail_tests": []}], "EvoEval/16": [{"task_id": "EvoEval/16", "solution": "\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (case-sensitive) does it consist of.\n    >>> count_distinct_characters('xyzXYZ')\n    6\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/32": [{"task_id": "EvoEval/32", "solution": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"xs are coefficients of a polynomial xs[0] + xs[1] * x^1 + xs[2] * x^3 + .... xs[n] * x^(2*n-1)\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having at least two coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-2, -3, 1]), 2) # (x + 1) (x + 1) (x - 2) = -2 - 3x + x^3\n    -1.0\n    \"\"\"\n    derivative = [i * coeff for (i, coeff) in enumerate(xs)][1:]\n    x = 0\n    while abs(poly(xs, x)) > 1e-06:\n        f_x = poly(xs, x)\n        f_prime_x = poly(derivative, x)\n        if f_prime_x == 0:\n            return None\n        x = x - f_x / f_prime_x\n    return x", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[-3, -6, -7, 7]]], "plus_fail_tests": []}], "EvoEval/81": [{"task_id": "EvoEval/81", "solution": "\ndef numerical_letter_grade(grades):\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[4.0, 3, 1.7, 2, 3.5]]], "plus_fail_tests": []}], "EvoEval/94": [{"task_id": "EvoEval/94", "solution": "\ndef skjkasdkd(lst):\n    primes = [i for i in lst if is_prime(i)]\n    if not primes:\n        return 0\n    smallest_prime = min(primes)\n    return sum((int(digit) for digit in str(smallest_prime)))", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]]], "plus_fail_tests": []}], "EvoEval/44": [{"task_id": "EvoEval/44", "solution": "\n\ndef change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return integer representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    22\n    >>> change_base(8, 2)\n    1000\n    >>> change_base(7, 2)\n    111\n    \"\"\"\n    if x == 0:\n        return 0\n    else:\n        return x % base + 10 * change_base(x // base, base)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/24": [{"task_id": "EvoEval/24", "solution": "\ndef smallest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the smallest number that divides n evenly, larger than 1\n    >>> smallest_divisor(15)\n    3\n    \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n            return i\n    return -1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[3]], "plus_fail_tests": []}], "EvoEval/75": [{"task_id": "EvoEval/75", "solution": "\ndef is_multiply_prime(a):\n    factors = []\n    for i in range(2, a):\n        if a % i == 0 and is_prime(i):\n            factors.append(i)\n            a //= i\n            if len(factors) > 4:\n                return False\n    return len(factors) == 4", "base_status": "fail", "plus_status": null, "base_fail_tests": [[30]], "plus_fail_tests": []}], "EvoEval/19": [{"task_id": "EvoEval/19", "solution": "\nfrom typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    number_map = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    numbers_list = numbers.split()\n    numbers_list.sort(key=lambda x: number_map[x], reverse=True)\n    return ' '.join(numbers_list)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/40": [{"task_id": "EvoEval/40", "solution": "\ndef triples_sum_to_ten(l: list):\n    n = len(l)\n    if n < 3:\n        return False\n    l.sort()\n    for i in range(n - 2):\n        if i > 0 and l[i] == l[i - 1]:\n            continue\n        j = i + 1\n        k = n - 1\n        while j < k:\n            s = l[i] + l[j] + l[k]\n            if s == 10:\n                return True\n            elif s < 10:\n                j += 1\n            else:\n                k -= 1\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/10": [{"task_id": "EvoEval/10", "solution": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that ends with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest prefix of supplied string that is a palindrome.\n    - Append to the start of the string reverse of a string suffix that comes after the palindromic prefix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'tacat'\n    >>> make_palindrome('cata')\n    'atacata'\n    \"\"\"\n    palindromic_prefix = ''\n    for i in range(len(string)):\n        if is_palindrome(string[:i + 1]):\n            palindromic_prefix = string[:i + 1]\n    suffix = string[len(palindromic_prefix):]\n    return string + suffix[::-1]", "base_status": "fail", "plus_status": null, "base_fail_tests": [["xyz"]], "plus_fail_tests": []}], "EvoEval/22": [{"task_id": "EvoEval/22", "solution": "\nfrom typing import List, Any\n\n\ndef filter_even_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for even integers\n    >>> filter_even_integers(['a', 3.14, 5, 6])\n    [6]\n    >>> filter_even_integers([1, 2, 3, 'abc', {}, []])\n    [2]\n    \"\"\"\n    even_integers = []\n    for value in values:\n        if isinstance(value, int):\n            if value % 2 == 0:\n                even_integers.append(value)\n    return even_integers", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[true, false, null, 0, -10, "test", [], {}, 3.14]]], "plus_fail_tests": []}], "EvoEval/70": [{"task_id": "EvoEval/70", "solution": "\ndef strange_sort_list(lst):\n    \"\"\"\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the maximum value,\n    then minimum of the remaining integers, then maximum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [4, 1, 3, 2]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    \"\"\"\n    lst.sort()\n    result = []\n    while lst:\n        result.append(lst.pop(-1))\n        if lst:\n            result.append(lst.pop(0))\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/50": [{"task_id": "EvoEval/50", "solution": "\ndef encode_shift(s: str, shift: int = 5):\n    \"\"\"\n    returns encoded string by shifting every character by 'shift' in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + shift - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str, shift: int=5):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string by reversing the shift.\n    \"\"\"\n    return encode_shift(s, -shift)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/61": [{"task_id": "EvoEval/61", "solution": "\n\ndef correct_bracketing(brackets: str):\n    stack = []\n    for bracket in brackets:\n        if bracket == '[':\n            stack.append(bracket)\n        elif len(stack) == 0:\n            return False\n        else:\n            stack.pop()\n    return len(stack) == 0", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/38": [{"task_id": "EvoEval/38", "solution": "\ndef encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of four characters.\n    \"\"\"\n    n = 4\n    # split string to groups. Each of length 4.\n    groups = [s[(n * i):min((n * i + n), len(s))] for i in range((len(s) + n - 1) // n)]\n    # cycle elements in each group. Unless group has fewer elements than 4.\n    groups = [(group[1:] + group[0]) if len(group) == n else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    n = 4\n    groups = [s[n * i:min(n * i + n, len(s))] for i in range((len(s) + n - 1) // n)]\n    groups = [group[-1] + group[:-1] if len(group) == n else group for group in groups]\n    return ''.join(groups)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/59": [{"task_id": "EvoEval/59", "solution": "\ndef smallest_prime_factor(n: int):\n    \"\"\"Return the smallest prime factor of n. Assume n > 1 and is not a prime.\n    >>> smallest_prime_factor(13195)\n    5\n    >>> smallest_prime_factor(2048)\n    2\n    \"\"\"\n    if n % 2 == 0:\n        return 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return i\n    return n", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/88": [{"task_id": "EvoEval/88", "solution": "\ndef sort_array(array):\n    if not array:\n        return []\n    else:\n        array = list(set(array))\n        if (array[0] + array[-1]) % 2 == 0:\n            return sorted(array, reverse=True)\n        else:\n            return sorted(array)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[30, 20, 10, 5]]], "plus_fail_tests": []}], "EvoEval/62": [{"task_id": "EvoEval/62", "solution": "\n\ndef derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form, but in descending order of the power of x.\n    >>> derivative([3, 1, 2, 4, 5])\n    [20, 12, 4, 1]\n    >>> derivative([1, 2, 3])\n    [6, 2]\n    \"\"\"\n    derivative_coefficients = [0]\n    for i in range(1, len(xs)):\n        derivative_coefficients.append(i * xs[i])\n    return derivative_coefficients", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 1, 2, 4, 5]]], "plus_fail_tests": []}], "EvoEval/26": [{"task_id": "EvoEval/26", "solution": "\nfrom typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Return the list in the reverse order of the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [4, 3, 1]\n    \"\"\"\n    freq = {}\n    for num in numbers:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    unique_numbers = []\n    for num in reversed(numbers):\n        if freq[num] == 1:\n            unique_numbers.append(num)\n            del freq[num]\n    return unique_numbers", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/78": [{"task_id": "EvoEval/78", "solution": "\ndef hex_key(num):\n    primes = ['2', '3', '5', '7', 'B', 'D', 'F']\n    count = 0\n    for char in num:\n        if char not in primes:\n            count += 1\n    return count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/71": [{"task_id": "EvoEval/71", "solution": "\ndef triangle_area(a, b, c):\n    if a + b > c and a + c > b and (b + c > a):\n        s = (a + b + c) / 2\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        return round(area, 3)\n    else:\n        return -1", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/2": [{"task_id": "EvoEval/2", "solution": "\ndef truncate_number(number: float) -> float:\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return (integer_part, decimal_part)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/85": [{"task_id": "EvoEval/85", "solution": "\ndef add(lst):\n    return sum((lst[i] for i in range(len(lst)) if i % 2 == 0 and lst[i] % 2 == 1))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/52": [{"task_id": "EvoEval/52", "solution": "\n\ndef below_threshold(l: list, t: int) -> bool:\n    for num in l:\n        if num > t:\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/47": [{"task_id": "EvoEval/47", "solution": "\ndef median(l: list):\n    if not l:\n        return 0\n    else:\n        l.sort()\n        n = len(l)\n        if n % 2 == 0:\n            return (l[n // 2 - 1] + l[n // 2]) / 2\n        else:\n            return l[n // 2]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/63": [{"task_id": "EvoEval/63", "solution": "\ndef fibfib(n: int):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        memo = [0] * (n + 1)\n        memo[0] = 0\n        memo[1] = 0\n        memo[2] = 1\n        for i in range(3, n + 1):\n            memo[i] = memo[i - 3] + memo[i - 2] - memo[i - 1]\n        return memo[n]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/96": [{"task_id": "EvoEval/96", "solution": "\ndef count_up_to(n):\n    prime_numbers = []\n    for i in range(n, 0, -1):\n        if is_prime(i):\n            prime_numbers.append(i)\n    return prime_numbers", "base_status": "fail", "plus_status": null, "base_fail_tests": [[5]], "plus_fail_tests": []}], "EvoEval/98": [{"task_id": "EvoEval/98", "solution": "\ndef count_upper(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in odd indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 0\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 1\n    \"\"\"\n    upper_vowels = 'AEIOU'\n    return sum((1 for i in range(len(s)) if i % 2 != 0 and s[i] in upper_vowels))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/74": [{"task_id": "EvoEval/74", "solution": "\ndef total_match(lst1, lst2):\n    len1 = sum((len(s) for s in lst1))\n    len2 = sum((len(s) for s in lst2))\n    if len1 > len2:\n        return lst1\n    else:\n        return lst2", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/20": [{"task_id": "EvoEval/20", "solution": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    closest_pair = None\n    smallest_diff = None\n    for i in range(len(numbers) - 1):\n        pair = (numbers[i], numbers[i + 1])\n        diff = pair[1] - pair[0]\n        if smallest_diff is None or diff < smallest_diff:\n            closest_pair = pair\n            smallest_diff = diff\n    return (closest_pair[1], closest_pair[0])", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3.9, 1.0, 2.2, 2.0, 4.0, 5.0]]], "plus_fail_tests": []}], "EvoEval/34": [{"task_id": "EvoEval/34", "solution": "\ndef unique(l: list):\n    \"\"\"Return sorted unique elements in a list in descending order\"\"\"\n    return sorted(set(l), reverse=True)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/14": [{"task_id": "EvoEval/14", "solution": "\nfrom typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from longest to shortest of the input string\n    >>> all_prefixes('abc')\n    ['abc', 'ab', 'a']\n    \"\"\"\n    return [string[:i] for i in range(len(string), 0, -1)]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/67": [{"task_id": "EvoEval/67", "solution": "def fruit_distribution(s, n):\n    (apples, oranges) = map(int, s.split()[:2])\n    return n + 1 - apples - oranges", "base_status": "fail", "plus_status": null, "base_fail_tests": [["100 apples, 1 oranges", 120]], "plus_fail_tests": []}], "EvoEval/33": [{"task_id": "EvoEval/33", "solution": "\ndef sort_third(l: list):\n    divisible_by_three = sorted([l[i] for i in range(len(l)) if (i + 1) % 3 == 0], reverse=True)\n    result = [divisible_by_three.pop(0) if (i + 1) % 3 == 0 else l[i] for i in range(len(l))]\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]]], "plus_fail_tests": []}], "EvoEval/90": [{"task_id": "EvoEval/90", "solution": "\ndef next_largest(lst):\n    (first, second) = (float('-inf'), float('-inf'))\n    for num in lst:\n        if num > first:\n            second = first\n            first = num\n        elif first > num > second:\n            second = num\n    if second == float('-inf'):\n        return None\n    else:\n        return second", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/42": [{"task_id": "EvoEval/42", "solution": "\n\ndef incr_list(l: list):\n    \"\"\"Return list with elements incremented by 2.\n    >>> incr_list([1, 2, 3])\n    [3, 4, 5]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [7, 5, 7, 4, 5, 5, 11, 2, 125]\n    \"\"\"\n    return [x + 2 for x in l]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/84": [{"task_id": "EvoEval/84", "solution": "\ndef solve(N):\n    digit_sum = sum((int(digit) for digit in str(N)))\n    return hex(digit_sum)[2:].upper()", "base_status": "fail", "plus_status": null, "base_fail_tests": [[147]], "plus_fail_tests": []}], "EvoEval/97": [{"task_id": "EvoEval/97", "solution": "\ndef multiply(a, b):\n    return abs(a % 10 * b % 10)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[148, 412]], "plus_fail_tests": []}], "EvoEval/37": [{"task_id": "EvoEval/37", "solution": "\n\ndef sort_even(l: list):\n    even_indices_elements = sorted([l[i] for i in range(0, len(l), 2)], reverse=True)\n    for i in range(0, len(l), 2):\n        l[i] = even_indices_elements[i // 2]\n    return l", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/30": [{"task_id": "EvoEval/30", "solution": "\ndef get_positive(l: list):\n    \"\"\"Return only positive numbers in the list in ascending order.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n    return sorted([i for i in l if i > 0])", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/46": [{"task_id": "EvoEval/46", "solution": "\ndef fib4(n: int):\n    if n < 2:\n        return '0'\n    elif n == 2:\n        return '2'\n    elif n == 3:\n        return '0'\n    else:\n        fib = [0, 0, 2, 0] + [0] * (n - 3)\n        for i in range(4, n + 1):\n            fib[i] = int(fib[i - 1]) + int(fib[i - 2]) + int(fib[i - 3]) + int(fib[i - 4])\n        return str(fib[n])", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/21": [{"task_id": "EvoEval/21", "solution": "\nfrom typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1. Return the list in descending order.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [1.0, 0.75, 0.5, 0.25, 0.0]\n    \"\"\"\n    min_val = min(numbers)\n    max_val = max(numbers)\n    scaled_numbers = [(x - min_val) / (max_val - min_val) for x in numbers]\n    return sorted(scaled_numbers, reverse=True)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/3": [{"task_id": "EvoEval/3", "solution": "\nfrom typing import List\n\n\ndef below_one(operations: List[int]) -> bool:\n    balance = 1\n    for operation in operations:\n        balance += operation\n        if balance < 1:\n            return True\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/68": [{"task_id": "EvoEval/68", "solution": "\ndef pluck(arr):\n    smallest_odd_value = float('inf')\n    smallest_odd_index = float('inf')\n    for (i, value) in enumerate(arr):\n        if value % 2 == 1 and value < smallest_odd_value:\n            smallest_odd_value = value\n            smallest_odd_index = i\n    if smallest_odd_index == float('inf'):\n        return []\n    else:\n        return [smallest_odd_index, smallest_odd_value]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/23": [{"task_id": "EvoEval/23", "solution": "\n\ndef strlen(string: str) -> int:\n    return len(string) + 1", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/99": [{"task_id": "EvoEval/99", "solution": "\ndef closest_integer(value):\n    value = float(value)\n    if value >= 0:\n        return int(value)\n    else:\n        return int(value) if value == int(value) else int(value) - 1", "base_status": "fail", "plus_status": null, "base_fail_tests": [["-15.5"]], "plus_fail_tests": []}], "EvoEval/11": [{"task_id": "EvoEval/11", "solution": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    xor_result = ''.join((str(int(x) ^ int(y)) for (x, y) in zip(a, b)))\n    return xor_result[::-1]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/8": [{"task_id": "EvoEval/8", "solution": "\nfrom typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    sum_num = 0\n    product_num = 1\n    for num in numbers:\n        if num >= 0:\n            sum_num += num\n            product_num *= num\n    return (sum_num, product_num)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/27": [{"task_id": "EvoEval/27", "solution": "\ndef flip_case(string: str, exclusive_case: str='lower') -> str:\n    result = ''\n    for char in string:\n        if char.isupper() and exclusive_case != 'upper':\n            result += char.lower()\n        elif char.islower() and exclusive_case != 'lower':\n            result += char.upper()\n        else:\n            result += char\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/95": [{"task_id": "EvoEval/95", "solution": "\ndef check_dict_case(dict):\n    if len(dict) < 3 or not dict:\n        return False\n    upper_case = 0\n    lower_case = 0\n    for key in dict.keys():\n        if isinstance(key, str):\n            if key.isupper():\n                upper_case += 1\n            elif key.islower():\n                lower_case += 1\n            else:\n                return False\n        else:\n            return False\n    return upper_case == len(dict) or lower_case == len(dict)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/6": [{"task_id": "EvoEval/6", "solution": "\nfrom typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n\n    def max_depth(s: str) -> int:\n        max_d = d = 0\n        for c in s:\n            if c == '(':\n                d += 1\n                max_d = max(max_d, d)\n            elif c == ')':\n                d -= 1\n        return max_d\n    return sorted([max_depth(s) for s in paren_string.split()], reverse=True)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/39": [{"task_id": "EvoEval/39", "solution": "\ndef prime_fib(n):\n    i = 0\n    while True:\n        fib_num = fib(i)\n        if is_prime(fib_num):\n            n -= 1\n            if n == 0:\n                return fib_num\n        i += 1\n    return None", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1]], "plus_fail_tests": []}], "EvoEval/1": [{"task_id": "EvoEval/1", "solution": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    result = []\n    count = 0\n    start = 0\n    for (index, char) in enumerate(paren_string):\n        if char == '(':\n            if count == 0:\n                start = index\n            count += 1\n        elif char == ')':\n            count -= 1\n            if count == 0:\n                result.append(paren_string[start:index + 1])\n    return sorted(result)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/56": [{"task_id": "EvoEval/56", "solution": "\ndef correct_bracketing(brackets: str) -> bool:\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        else:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/93": [{"task_id": "EvoEval/93", "solution": "\n\ndef encode(message):\n    result = ''\n    for char in message:\n        if char.isalpha():\n            if char.lower() in 'aeiou':\n                if char.islower():\n                    result += chr((ord(char) - ord('a') + 3) % 26 + ord('a'))\n                else:\n                    result += chr((ord(char) - ord('A') + 3) % 26 + ord('A'))\n            else:\n                result += char.swapcase()\n        else:\n            result += char\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["TEST"]], "plus_fail_tests": []}], "EvoEval/41": [{"task_id": "EvoEval/41", "solution": "\ndef car_race_collision(n: int):\n    return n", "base_status": "fail", "plus_status": null, "base_fail_tests": [[2]], "plus_fail_tests": []}], "EvoEval/43": [{"task_id": "EvoEval/43", "solution": "\ndef pairs_sum_to_one(l):\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 3, 5, 0]]], "plus_fail_tests": []}], "EvoEval/49": [{"task_id": "EvoEval/49", "solution": "\ndef modp(n: int, p: int, q: int):\n    \"\"\"Return 2^(n+q) modulo p (be aware of numerics).\n    >>> modp(3, 5, 1)\n    1\n    >>> modp(1101, 101, 2)\n    8\n    >>> modp(0, 101, 1)\n    2\n    >>> modp(3, 11, 2)\n    10\n    >>> modp(100, 101, 1)\n    2\n    \"\"\"\n    return pow(2, n + q, p)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/54": [{"task_id": "EvoEval/54", "solution": "\ndef same_chars(s0: str, s1: str) -> bool:\n    return sorted(s0) == sorted(s1)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["aaaaaaabcd", "dddddddabc"]], "plus_fail_tests": []}], "EvoEval/77": [{"task_id": "EvoEval/77", "solution": "\ndef iscube(a):\n    if a < 0:\n        return False\n    else:\n        return round(a ** (1.0 / 3)) ** 3 == a", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/29": [{"task_id": "EvoEval/29", "solution": "\nfrom typing import List\n\n\ndef filter_by_suffix(strings: List[str], suffix: str) -> List[str]:\n    return [string for string in strings if string.endswith(suffix)]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/7": [{"task_id": "EvoEval/7", "solution": "\nfrom typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring not in s]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/9": [{"task_id": "EvoEval/9", "solution": "\nfrom typing import List, Tuple\n\n\ndef rolling_min(numbers: List[int]) -> List[int]:\n    min_val = float('inf')\n    result = []\n    for num in numbers:\n        min_val = min(min_val, num)\n        result.append(min_val)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/64": [{"task_id": "EvoEval/64", "solution": "FIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    count = 0\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s = s.lower()\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s[-1] == 'y':\n        count += 1\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Alone"]], "plus_fail_tests": []}], "EvoEval/87": [{"task_id": "EvoEval/87", "solution": "def get_row(lst, x):\n    result = []\n    for (i, sub_list) in enumerate(lst):\n        for (j, val) in enumerate(sub_list):\n            if val == x:\n                result.append((i, j))\n    result.sort(key=lambda a: (a[0], a[1]), reverse=True)\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1]], "plus_fail_tests": []}], "EvoEval/17": [{"task_id": "EvoEval/17", "solution": "\nfrom typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    beat_values = []\n    for note in music_string.split():\n        if note == 'o':\n            beat_values.append(4)\n        elif note == 'o|':\n            beat_values.append(2)\n        elif note == '.|':\n            beat_values.append(1)\n    unique_beats = list(set(beat_values))\n    unique_beats.sort(reverse=True)\n    return unique_beats", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/73": [{"task_id": "EvoEval/73", "solution": "\ndef smallest_change(arr):\n    n = len(arr)\n    changes = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            changes += 1\n    return changes", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/5": [{"task_id": "EvoEval/5", "solution": "\nfrom typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    result = []\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        result.append(delimeter)\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[], 7]], "plus_fail_tests": []}], "EvoEval/51": [{"task_id": "EvoEval/51", "solution": "\ndef remove_consonants(text):\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    no_consonants = ''\n    for char in text:\n        if char not in consonants:\n            no_consonants += char\n    return no_consonants", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/28": [{"task_id": "EvoEval/28", "solution": "\nfrom typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string, separated by a comma.\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'a,b,c'\n    \"\"\"\n    return ','.join(strings)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/69": [{"task_id": "EvoEval/69", "solution": "\ndef search(lst):\n    freq = {}\n    for i in lst:\n        if i in freq:\n            freq[i] += 1\n        else:\n            freq[i] = 1\n    for i in range(1, max(freq.keys()) + 1):\n        if i in freq and freq[i] >= i:\n            return i\n    return -1", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/79": [{"task_id": "EvoEval/79", "solution": "\ndef decimal_to_binary(decimal):\n    binary = bin(decimal)[2:]\n    return 'db' + binary + 'bd'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/66": [{"task_id": "EvoEval/66", "solution": "\ndef digitSum(s):\n    return sum((ord(c) for c in s if c.islower()))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/72": [{"task_id": "EvoEval/72", "solution": "\ndef will_it_fly(q, w):\n    if q != q[::-1]:\n        return False\n    if sum(q) % 2 != 0:\n        return False\n    if sum(q) <= w:\n        return True\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/86": [{"task_id": "EvoEval/86", "solution": "\ndef anti_shuffle(s):\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word, key=lambda x: -ord(x))) for word in words]\n    return ' '.join(ordered_words)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/4": [{"task_id": "EvoEval/4", "solution": "\nfrom typing import List\n\n\ndef median_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Median Absolute Deviation\n    around the median of this dataset.\n    Median Absolute Deviation is the median absolute difference between each\n    element and a centerpoint (median in this case):\n    MAD = median | x - x_median |\n    >>> median_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    median = statistics.median(numbers)\n    abs_diffs = [abs(x - median) for x in numbers]\n    mad = statistics.median(abs_diffs)\n    return mad", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1.0, 2.0, 3.0]]], "plus_fail_tests": []}], "EvoEval/45": [{"task_id": "EvoEval/45", "solution": "\n\ndef triangle_perimeter(a, b, c):\n    \"\"\"Given length of three sides return perimeter for a triangle.\n    >>> triangle_perimeter(5, 3, 3)\n    11\n    \"\"\"\n    return a + b + c", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/48": [{"task_id": "EvoEval/48", "solution": "\n\ndef is_palindrome(text: str, case_sensitive: bool=True):\n    if not case_sensitive:\n        text = text.lower()\n    return text == text[::-1]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/58": [{"task_id": "EvoEval/58", "solution": "\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists in descending order.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [653, 5, 1]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [3, 2]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)), reverse=True)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/18": [{"task_id": "EvoEval/18", "solution": "\ndef how_many_times(string: str, substring: str) -> int:\n    count = start = 0\n    while start < len(string):\n        pos = string.find(substring, start)\n        if pos != -1:\n            start = pos + 1\n            count += 1\n        else:\n            break\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [["cacacacac", "cac"]], "plus_fail_tests": []}], "EvoEval/53": [{"task_id": "EvoEval/53", "solution": "\ndef add(x: int, y: int) -> int:\n    \"\"\"Add two numbers x and y and return the result increased by 1\"\"\"\n    return x + y + 1", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/12": [{"task_id": "EvoEval/12", "solution": "\nfrom typing import List, Optional\n\n\ndef shortest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    shortest_string = strings[0]\n    for string in strings:\n        if len(string) < len(shortest_string):\n            shortest_string = string\n    return shortest_string", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/60": [{"task_id": "EvoEval/60", "solution": "\ndef sum_to_n(n: int, m: int=1):\n    return sum(range(m, n + 1))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/80": [{"task_id": "EvoEval/80", "solution": "\ndef is_happy(s):\n    if len(s) < 4:\n        return False\n    for i in range(len(s) - 3):\n        if len(set(s[i:i + 4])) != 4:\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/0": [{"task_id": "EvoEval/0", "solution": "\nfrom typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two adjacent numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    >>> has_close_elements([], 0.3)\n    False\n    \"\"\"\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/36": [{"task_id": "EvoEval/36", "solution": "\ndef fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('8')\n    return count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/13": [{"task_id": "EvoEval/13", "solution": "\n\ndef least_common_multiple(a: int, b: int) -> int:\n    \"\"\" Return the least common multiple of two integers a and b\n    >>> least_common_multiple(3, 5)\n    15\n    >>> least_common_multiple(25, 15)\n    75\n    \"\"\"\n    if a == 0 or b == 0:\n        return 0\n    greater = max(a, b)\n    while True:\n        if greater % a == 0 and greater % b == 0:\n            return greater\n        greater += 1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[987654321, 123456789]], "plus_fail_tests": []}], "EvoEval/15": [{"task_id": "EvoEval/15", "solution": "\ndef string_sequence(n: int) -> str:\n    return ' '.join((str(i) for i in range(1, n + 1)))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}]}}