{"eval": {"EvoEval/71": [{"task_id": "EvoEval/71", "solution": "def letter_shift_cipher(s, n):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    vowels = 'aeiou'\n    encrypted_string = ''\n    vowel_count = 0\n    for char in s:\n        if char.lower() in alphabet:\n            index = (alphabet.index(char.lower()) + n) % 26\n            encrypted_char = alphabet[index]\n            encrypted_string += encrypted_char\n            if encrypted_char.lower() in vowels:\n                vowel_count += 1\n        else:\n            encrypted_string += char\n    return (encrypted_string, vowel_count)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["I love Python!", 13]], "plus_fail_tests": []}], "EvoEval/44": [{"task_id": "EvoEval/44", "solution": "def fairy_tale_transport(q, w, e):\n    total_capacity = w + 2 * e\n    total_weight = sum(q)\n    return total_capacity >= total_weight", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[5, 10, 15], 5, 20]], "plus_fail_tests": []}], "EvoEval/75": [{"task_id": "EvoEval/75", "solution": "def magical_string_transformer(input_str):\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    result = ''\n    for (i, char) in enumerate(input_str):\n        if char.lower() in vowels:\n            index = (vowels.index(char.lower()) + 1) % len(vowels)\n            result += vowels[index] if char.islower() else vowels[index].upper()\n        elif char.lower() in consonants:\n            index = (consonants.index(char.lower()) + 1) % len(consonants)\n            result += consonants[index] if char.islower() else consonants[index].upper()\n        elif char.isdigit():\n            result += str((int(char) + 1) % 10)\n        elif char in '!?':\n            if i % 2 == 0:\n                result += '!' if char == '?' else '?'\n            else:\n                result += char\n        else:\n            result += char\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["?!AEIOUaeiou"]], "plus_fail_tests": []}], "EvoEval/91": [{"task_id": "EvoEval/91", "solution": "def spaceship_trajectory(spaceship_data):\n    status = 'On Ground'\n    for (action, distance) in spaceship_data:\n        if action == 'Launch':\n            if status == 'On Ground':\n                status = 'In Space'\n            else:\n                return 'Invalid Action Sequence'\n        elif action == 'Move':\n            if status != 'In Space':\n                return 'Invalid Action Sequence'\n        elif action == 'Land':\n            if status == 'In Space':\n                status = 'On Ground'\n            else:\n                return 'Invalid Action Sequence'\n        else:\n            return 'Invalid Action Sequence'\n    return status", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/61": [{"task_id": "EvoEval/61", "solution": "def transform_string(s):\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyza'\n    transformed_string = ''\n    for (i, char) in enumerate(s):\n        if char.isalpha():\n            if i % 2 == 1:\n                if char.lower() in vowels:\n                    transformed_string += vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n                else:\n                    transformed_string += consonants[(consonants.index(char.lower()) - 1) % len(consonants)]\n            else:\n                transformed_string += char\n        else:\n            transformed_string += char\n    return transformed_string", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Hello World"]], "plus_fail_tests": []}], "EvoEval/2": [{"task_id": "EvoEval/2", "solution": "from typing import List, Union\n\ndef encrypt_message(words: List[str], key: Union[str, int]) -> List[Union[str, int]]:\n    \"\"\"\n    Given a list of words, first turn words into lowercase and then encrypt each word using a simple Caesar cipher. \n    The key for the cipher is either a string or an integer.\n    If the key is a string, convert it to an integer by summing the ASCII values \n    of its characters. If the key is an integer, use it as-is.\n\n    The Caesar cipher works by shifting each letter in the word by the \n    value of the key. If the letter after shifting exceeds 'z', it wraps \n    around to the start of the alphabet.\n\n    If the word contains any non-alphabetical characters, leave them as-is.\n\n    >>> encrypt_message([], \"abc\")\n    []\n    >>> encrypt_message([\"hello\", \"world\"], 3)\n    [\"khoor\", \"zruog\"]\n    >>> encrypt_message([\"hello\", \"world\"], \"abc\")\n    [\"pmttw\", \"ewztl\"]\n    \"\"\"\n\n    def caesar_cipher(word, shift):\n        encrypted_word = ''\n        for char in word:\n            if char.isalpha():\n                shift_amount = ord(key) - ord('a') if isinstance(key, str) else key\n                shifted_char = chr((ord(char.lower()) - ord('a') + shift_amount) % 26 + ord('a'))\n                encrypted_word += shifted_char if char.islower() else shifted_char.upper()\n            else:\n                encrypted_word += char\n        return encrypted_word\n    key = sum((ord(char) for char in str(key))) if isinstance(key, str) else key\n    return [caesar_cipher(word.lower(), key) for word in words]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["ant", "bat", "cat", "dog", "elephant"], -1]], "plus_fail_tests": []}], "EvoEval/65": [{"task_id": "EvoEval/65", "solution": "def food_order(menu, order):\n    if not order:\n        return menu\n    for (food, customization) in order.items():\n        if 'remove' in customization:\n            for ingredient in customization['remove']:\n                menu[food].remove(ingredient)\n        if 'add' in customization:\n            for ingredient in customization['add']:\n                menu[food].append(ingredient)\n    return menu", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/50": [{"task_id": "EvoEval/50", "solution": "def text_to_morse(text):\n    morse_code = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', ' ': '  '}\n    morse_text = []\n    for char in text:\n        if char.upper() in morse_code:\n            morse_text.append(morse_code[char.upper()])\n    return ' '.join(morse_text)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["HELLO WORLD"]], "plus_fail_tests": []}], "EvoEval/24": [{"task_id": "EvoEval/24", "solution": "def alien_language_translator(english_word: str):\n    alien_language = {'a': '+', 'b': '-', 'c': '*', 'd': '/', 'e': '%', 'f': '@', 'g': '!', 'h': '#', 'i': '$', 'j': '^', 'k': '&', 'l': '(', 'm': ')', 'n': '=', 'o': '?', 'p': ':', 'q': ';', 'r': '`', 's': '~', 't': '>', 'u': '<', 'v': '{', 'w': '}', 'x': '[', 'y': ']', 'z': '|'}\n    translated_word = ''\n    for letter in english_word:\n        if letter.lower() in alien_language:\n            translated_word += alien_language[letter.lower()]\n        else:\n            translated_word += letter\n    return translated_word", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/74": [{"task_id": "EvoEval/74", "solution": "def cipher_mapping(s, cipher):\n    if not s:\n        return ''\n    new_string = ''\n    for char in s:\n        if char in cipher:\n            new_string += cipher[char]\n        else:\n            new_string += char\n    return new_string", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/96": [{"task_id": "EvoEval/96", "solution": "def get_magic_indices(lst):\n\n    def product_of_digits(num):\n        product = 1\n        for digit in str(abs(num)):\n            product *= int(digit)\n        return product\n    magic_indices = []\n    for (i, num) in enumerate(lst):\n        if i != 0 and num % i == 0 and (product_of_digits(num) == i):\n            magic_indices.append(i)\n    return sorted(magic_indices)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[0, 7, -6, 12, -20, 5, -7]]], "plus_fail_tests": []}], "EvoEval/63": [{"task_id": "EvoEval/63", "solution": "def create_pyramid(p):\n    blocks_in_layers = [p]\n    while True:\n        if p % 2 == 0:\n            p -= 2\n        else:\n            p -= 3\n        if p <= 0:\n            break\n        blocks_in_layers.append(p)\n    return blocks_in_layers", "base_status": "fail", "plus_status": null, "base_fail_tests": [[0]], "plus_fail_tests": []}], "EvoEval/82": [{"task_id": "EvoEval/82", "solution": "def zodiac_element(birthdays):\n    if not birthdays:\n        return None\n    elements = {'Fire': 0, 'Water': 0, 'Air': 0, 'Earth': 0}\n    for birthday in birthdays:\n        month = int(birthday[5:7])\n        day = int(birthday[8:10])\n        if month == 3 and day >= 21 or (month == 4 and day <= 19):\n            elements['Fire'] += 1\n        elif month == 4 and day >= 20 or (month == 5 and day <= 20):\n            elements['Earth'] += 1\n        elif month == 5 and day >= 21 or (month == 6 and day <= 20):\n            elements['Air'] += 1\n        elif month == 6 and day >= 21 or (month == 7 and day <= 22):\n            elements['Water'] += 1\n        elif month == 7 and day >= 23 or (month == 8 and day <= 22):\n            elements['Fire'] += 1\n        elif month == 8 and day >= 23 or (month == 9 and day <= 22):\n            elements['Earth'] += 1\n        elif month == 9 and day >= 23 or (month == 10 and day <= 22):\n            elements['Air'] += 1\n        elif month == 10 and day >= 23 or (month == 11 and day <= 21):\n            elements['Water'] += 1\n        elif month == 11 and day >= 22 or (month == 12 and day <= 21):\n            elements['Fire'] += 1\n        elif month == 12 and day >= 22 or (month == 1 and day <= 19):\n            elements['Earth'] += 1\n        elif month == 1 and day >= 20 or (month == 2 and day <= 18):\n            elements['Air'] += 1\n        elif month == 2 and day >= 19 or (month == 3 and day <= 20):\n            elements['Water'] += 1\n    return {k: v for (k, v) in elements.items() if v > 0}", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/92": [{"task_id": "EvoEval/92", "solution": "def paint_fountain(n):\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    layers = []\n    for i in range(n):\n        layer = alphabet[i] * (2 * i + 1)\n        layer = layer.center(2 * n - 1)\n        layers.append(layer)\n    return '\\n'.join(layers)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[3]], "plus_fail_tests": []}], "EvoEval/32": [{"task_id": "EvoEval/32", "solution": "def playlist_shuffle(playlist: list, seed: int):\n    \"\"\"Return a new playlist order based on a numerical seed.\n\n    Given a list of song titles (strings) as 'playlist' and an odd integer 'seed',\n    implement an algorithm to shuffle the playlist to create a new order.\n    The same seed should always produce the same shuffled playlist.\n\n    The shuffling algorithm should use the seed to produce a series of swaps in the sorted list.\n    To produce the series, start at index 0 and swap with the element\n    at the index `seed % playlist_length`. It's important to note that if a song title contains the word \"Rock\", it should remain unmoved during the swapping process (the swap operation will be skipped). For the next index, update the\n    seed using the formula: seed = (seed * 16807) % 2147483647. Continue this process\n    from the next index until the end of the list. Note that the seed will be updated for every index (swapped or not).\n\n    \"\"\"\n    playlist_length = len(playlist)\n    sorted_playlist = sorted(playlist)\n    shuffled_playlist = sorted_playlist.copy()\n    for i in range(playlist_length):\n        if 'Rock' in shuffled_playlist[i]:\n            continue\n        swap_index = seed % playlist_length\n        if 'Rock' not in shuffled_playlist[swap_index]:\n            (shuffled_playlist[i], shuffled_playlist[swap_index]) = (shuffled_playlist[swap_index], shuffled_playlist[i])\n        seed = seed * 16807 % 2147483647\n    return shuffled_playlist", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["One More Time", "Around the World", "Harder Better Faster Stronger"], 7]], "plus_fail_tests": []}], "EvoEval/70": [{"task_id": "EvoEval/70", "solution": "def planet_path(planets, path):\n    \"\"\"Given a dictionary of planets where each planet is a key and its value is \n    a list of planets it directly connects to, and a list of planets forming a path, \n    return True if the path between those planets is valid (i.e. each planet connects \n    directly to the next), and False otherwise. If the planet does not exist in the \n    dictionary or the path list is empty, return False.\n\n    Example:\n    planet_path({'a': ['b', 'c'], 'b': ['a', 'c'], 'c': ['a', 'b']}, ['a', 'b', 'c']) \n    returns True\n    planet_path({'a': ['b', 'c'], 'b': ['a', 'c'], 'c': ['a', 'b']}, ['a', 'c', 'b']) \n    returns True\n    planet_path({'a': ['b', 'c'], 'b': ['a', 'c'], 'c': ['a', 'b']}, ['a', 'b', 'a']) \n    returns True\n    planet_path({'a': ['b'], 'b': ['a', 'c'], 'c': ['b']}, ['a', 'c', 'b']) \n    returns False\n    planet_path({'a': ['b'], 'b': ['a', 'c'], 'c': ['b']}, []) \n    returns False\n    planet_path({}, ['a', 'b', 'c']) \n    returns False\n    \"\"\"\n    if not path or not planets:\n        return False\n    for i in range(len(path) - 1):\n        current_planet = path[i]\n        next_planet = path[i + 1]\n        if current_planet not in planets or next_planet not in planets[current_planet]:\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/13": [{"task_id": "EvoEval/13", "solution": "\nfrom typing import List\n\ndef find_rarest_element(elems: List[str]) -> str:\n    \"\"\" Find the rarest element in a list of strings. If there are multiple rarest elements, return the one that appears first. \n    If the list is empty, return None.\n\n    >>> find_rarest_element(['apple', 'banana', 'apple', 'orange', 'banana', 'orange', 'apple'])\n    'banana'\n    >>> find_rarest_element(['cat', 'dog', 'bird', 'cat', 'dog', 'cat'])\n    'bird'\n    >>> find_rarest_element([])\n    None\n    \"\"\"\n    if not elems:\n        return None\n    element_counts = {}\n    for elem in elems:\n        if elem in element_counts:\n            element_counts[elem] += 1\n        else:\n            element_counts[elem] = 1\n    rarest_element = None\n    rarest_count = float('inf')\n    for (elem, count) in element_counts.items():\n        if count < rarest_count:\n            rarest_element = elem\n            rarest_count = count\n    return rarest_element", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/14": [{"task_id": "EvoEval/14", "solution": "def create_alias(name: str) -> str:\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    alias = ''\n    for char in name:\n        if char.isalpha():\n            if char.lower() in vowels:\n                if char.isupper():\n                    alias += vowels[(vowels.index(char.lower()) + 1) % len(vowels)].upper()\n                else:\n                    alias += vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n            elif char.isupper():\n                alias += consonants[(consonants.index(char.lower()) + 1) % len(consonants)].upper()\n            else:\n                alias += consonants[(consonants.index(char.lower()) + 1) % len(consonants)]\n        else:\n            alias += char\n    return alias", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/19": [{"task_id": "EvoEval/19", "solution": "def vampires_in_matrix(m: list):\n    \"\"\"\n    vampires_in_matrix takes a 2D list of integers as an input,\n    where 0 represents an empty cell, 1 represents a human, and 2 represents a vampire.\n    The function will return the number of humans that are in danger of being bitten.\n    A human is considered in danger if they share a row or a column with a vampire.\n\n    >>> vampires_in_matrix([[0, 1, 0], [2, 0, 1], [1, 1, 0]])\n    2\n    >>> vampires_in_matrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]])\n    0\n    >>> vampires_in_matrix([[1, 2, 1], [1, 1, 1], [2, 1, 1]])\n    6\n    >>> vampires_in_matrix([[1, 1, 1], [0, 0, 0], [2, 2, 2]])\n    3\n    >>> vampires_in_matrix([[2]])\n    0\n    \"\"\"\n    rows = len(m)\n    cols = len(m[0]) if rows > 0 else 0\n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if m[i][j] == 2:\n                for k in range(rows):\n                    if m[k][j] == 1:\n                        count += 1\n                for k in range(cols):\n                    if m[i][k] == 1:\n                        count += 1\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[1], [2, 1], [1, 1]]]], "plus_fail_tests": []}], "EvoEval/34": [{"task_id": "EvoEval/34", "solution": "def werewolf_transformation(n: int, m: int):\n    transformation = [0]\n    current_percentage = 0\n    for day in range(1, n):\n        if day < m:\n            current_percentage = min(current_percentage + 10, 100)\n        elif day == m:\n            current_percentage = min(current_percentage * 2, 100)\n        else:\n            current_percentage = max(current_percentage - 10, 0)\n        transformation.append(current_percentage)\n    return transformation", "base_status": "fail", "plus_status": null, "base_fail_tests": [[5, 3]], "plus_fail_tests": []}], "EvoEval/89": [{"task_id": "EvoEval/89", "solution": "def space_invaders(aliens, ray):\n    aliens.sort()\n    remaining_aliens = []\n    for alien in aliens:\n        if alien % 2 == 1 and abs(alien - ray) > 1:\n            remaining_aliens.append(alien)\n    return remaining_aliens", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 4, 5, 6], 4]], "plus_fail_tests": []}], "EvoEval/83": [{"task_id": "EvoEval/83", "solution": "def reverse_vowels(s):\n    \"\"\"Given a string s, return a new string with the vowels in reverse order, while keeping the position of other characters unchanged.\n    The string can contain uppercase and lowercase letters.\n    For example:\n    reverse_vowels('Hello') == 'Holle'\n    reverse_vowels('Python') == 'Python'\n    reverse_vowels('algorithm') == 'ilgorathm'\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    s_list = list(s)\n    (i, j) = (0, len(s_list) - 1)\n    while i < j:\n        if s_list[i] in vowels and s_list[j] in vowels:\n            (s_list[i], s_list[j]) = (s_list[j], s_list[i])\n            i += 1\n            j -= 1\n        elif s_list[i] in vowels:\n            j -= 1\n        elif s_list[j] in vowels:\n            i += 1\n        else:\n            i += 1\n            j -= 1\n    return ''.join(s_list)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/78": [{"task_id": "EvoEval/78", "solution": "def find_pattern(mat):\n    \"\"\"Given a 2D matrix of integers, return a list of all elements that form an \"X\" pattern. \n    The \"X\" pattern starts from the top left corner (0, 0) and ends at the bottom right corner (n, n), \n    and starts from the top right corner (0, n) and ends at the bottom left corner (n, 0).\n\n    Note: The matrix is square and the dimension is an odd number.\n\n    Examples\n    find_pattern([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) ==> [1, 5, 9, 3, 5, 7]\n    find_pattern([[11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25], [26, 27, 28, 29, 30], [31, 32, 33, 34, 35]]) ==>\n    [11, 17, 23, 29, 35, 15, 19, 23, 27, 31]\n    find_pattern([[10, 20, 30, 40, 50, 60, 70], [80, 90, 100, 110, 120, 130, 140], [150, 160, 170, 180, 190, 200, 210], [220, 230, 240, 250, 260, 270, 280], \n    [290, 300, 310, 320, 330, 340, 350], [360, 370, 380, 390, 400, 410, 420], [430, 440, 450, 460, 470, 480, 490]]) ==>\n    [10, 90, 170, 250, 330, 410, 490, 70, 130, 190, 250, 310, 370, 430]\n    \"\"\"\n    n = len(mat)\n    pattern = []\n    for i in range(n):\n        pattern.append(mat[i][i])\n    for i in range(n):\n        pattern.append(mat[i][n - i - 1])\n    return pattern", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/98": [{"task_id": "EvoEval/98", "solution": "def nature_sequence_generator(n, a, b):\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    sequence = [a, b]\n    for i in range(n - 2):\n        next_num = sequence[-1] + sequence[-2] + (i + 1)\n        if is_prime(next_num):\n            sequence.append('prime')\n        else:\n            sequence.append(next_num)\n    return sequence", "base_status": "fail", "plus_status": null, "base_fail_tests": [[5, 1, 2]], "plus_fail_tests": []}], "EvoEval/40": [{"task_id": "EvoEval/40", "solution": "", "base_status": "fail", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/16": [{"task_id": "EvoEval/16", "solution": "def fibonacci_sum(n):\n    \"\"\"\n    Given a positive integer n, return the sum of the first n numbers in the Fibonacci sequence.\n    The Fibonacci sequence is a series of numbers where a number is the sum of the two preceding ones, starting with 0 and 1.\n    \n    >>> fibonacci_sum(1)\n    0\n    >>> fibonacci_sum(2)\n    1\n    >>> fibonacci_sum(3)\n    2\n    >>> fibonacci_sum(10)\n    88\n    >>> fibonacci_sum(20)\n    10945\n    >>> fibonacci_sum(30)\n    1346268\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        fib_sequence = [0, 1]\n        for i in range(2, n):\n            fib_sequence.append(fib_sequence[i - 1] + fib_sequence[i - 2])\n        return sum(fib_sequence)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/55": [{"task_id": "EvoEval/55", "solution": "def treasure_map(message, shift):\n\n    def shift_char(char, shift):\n        if char.isalpha():\n            base = ord('A') if char.isupper() else ord('a')\n            return chr((ord(char) - base + shift) % 26 + base)\n        return char\n    encrypted_message = ''\n    for (i, char) in enumerate(message):\n        encrypted_message += shift_char(char, shift + i)\n    return encrypted_message", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/25": [{"task_id": "EvoEval/25", "solution": "def word_frequency_analysis(text: str, word: str):\n    sentences = text.split('.')\n    max_frequency = 0\n    max_sentence = ''\n    word_count = 0\n    for sentence in sentences:\n        count = sentence.strip().split().count(word)\n        if count > word_count:\n            word_count = count\n            max_sentence = sentence.strip()\n    return (word_count, max_sentence)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Hello world. I love this world.", "world"]], "plus_fail_tests": []}], "EvoEval/57": [{"task_id": "EvoEval/57", "solution": "def magical_cafe(menu, magic_spell):\n    new_menu = {}\n    spell_length = len(magic_spell)\n    for (dish, price) in menu.items():\n        transformed_dish = ''\n        dish_length = len(dish)\n        for i in range(dish_length):\n            transformed_dish += magic_spell[i % spell_length]\n        new_menu[transformed_dish] = price\n    return new_menu", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/62": [{"task_id": "EvoEval/62", "solution": "def recipe_converter(recipe, conversion_factor):\n    converted_recipe = {}\n    for (ingredient, quantity) in recipe.items():\n        converted_recipe[ingredient] = quantity * conversion_factor\n    return converted_recipe", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/94": [{"task_id": "EvoEval/94", "solution": "def spell_casting(strings):\n    sorted_spells = []\n    for spell in strings:\n        words = spell.split()\n        sorted_words = sorted(words, key=lambda x: (len(x), words.index(x)))\n        sorted_spells.append(' '.join(sorted_words))\n    return sorted_spells", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/52": [{"task_id": "EvoEval/52", "solution": "def magic_cookie_baker(n, m, orders):\n    \"\"\"\n    You are a magical baker who bakes cookies with an enchanted oven.\n\n    Your oven is special because it can bake exactly n cookies at once, and no more or less. Moreover, you can only bake m batches in a day. \n\n    Given a list of orders in the format of a list of positive integers where each integer represents an order for a specific number of cookies, return the maximum number of orders you can fulfill in a day.\n\n    The function magic_cookie_baker should take three parameters: \n    - n (a positive integer) represents the exact number of cookies your oven can bake at once.\n    - m (a positive integer) represents the maximum number of batches you can bake in a day.\n    - orders (a list of positive integers) represents all the orders for the day.\n\n    The function should assume that:\n    - You can only bake one batch at a time.\n    - You cannot split an order across multiple batches.\n    - You cannot combine multiple orders into a single batch.\n\n    The function should return an integer representing the maximum number of orders you can fulfill in a day.\n\n    Example:\n    assert magic_cookie_baker(3, 2, [4, 6, 8, 10]) == 0\n    assert magic_cookie_baker(5, 3, [7, 9, 11, 13, 15]) == 0\n    assert magic_cookie_baker(2, 4, [2, 4, 6, 8, 10]) == 1\n    assert magic_cookie_baker(1, 1, [1, 2, 3, 4, 5]) == 1\n    assert magic_cookie_baker(4, 2, [3, 5, 7, 9, 11]) == 1\n    \"\"\"\n    orders.sort()\n    max_orders = 0\n    for order in orders:\n        if order % n == 0 and m > 0:\n            max_orders += 1\n            m -= 1\n    return max_orders", "base_status": "fail", "plus_status": null, "base_fail_tests": [[3, 2, [4, 6, 8, 10]]], "plus_fail_tests": []}], "EvoEval/59": [{"task_id": "EvoEval/59", "solution": "def cooking_challenge(ingredient_dict):\n    if not ingredient_dict:\n        return []\n    sorted_ingredients = sorted(ingredient_dict.items(), key=lambda x: (-x[1], x[0]))\n    return sorted_ingredients", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/76": [{"task_id": "EvoEval/76", "solution": "def create_pyramid(lst):\n    pyramid = []\n    for num in reversed(lst):\n        level = '#' * num\n        pyramid.insert(0, level)\n    return pyramid", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 2, 1]]], "plus_fail_tests": []}], "EvoEval/88": [{"task_id": "EvoEval/88", "solution": "def planet_population(dict_of_planets):\n    result = {}\n    for (planet, data) in dict_of_planets.items():\n        (population, size) = data\n        if population is None or size is None:\n            continue\n        if population <= 0 or size <= 0:\n            continue\n        density = round(population / size, 2)\n        result[planet] = density\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"Earth": [7000000000, 15000000], "Mars": [0, 25000000]}]], "plus_fail_tests": []}], "EvoEval/38": [{"task_id": "EvoEval/38", "solution": "def translate_emoticons(sentence):\n    \"\"\"Convert text-based emoticons in a string to their corresponding Unicode emojis and return the result as a string.\n\n    If the sentence doesn't contain any text-based emoticons, return the original sentence.\n    Some examples of text-based emoticons and their corresponding emojis are \":)\" corresponds to \"\ud83d\ude0a\", \n    \":(\" corresponds to \"\u2639\ufe0f\", \":D\" corresponds to \"\ud83d\ude00\", \";)\" corresponds to \"\ud83d\ude09\". \n    \n    Examples:\n    >>> translate_emoticons(\"Hello :) Have a nice day! :D\")\n    \"Hello \ud83d\ude0a Have a nice day! \ud83d\ude00\"\n    >>> translate_emoticons(\"Oh no, it's raining! :(\")\n    \"Oh no, it's raining! \u2639\ufe0f\"\n    >>> translate_emoticons(\"No emoticons here\")\n    \"No emoticons here\"\n    \"\"\"\n    emoticons = {':)': '\ud83d\ude0a', ':(': '\u2639\ufe0f', ':D': '\ud83d\ude00', ';)': '\ud83d\ude09'}\n    for (emoticon, emoji) in emoticons.items():\n        sentence = sentence.replace(emoticon, emoji)\n    return sentence", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/85": [{"task_id": "EvoEval/85", "solution": "def princess_rescue(coord, grid):\n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = 0\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                continue\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1)\n    if dp[coord[0]][coord[1]] == float('inf'):\n        return -1\n    return dp[coord[0]][coord[1]]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/47": [{"task_id": "EvoEval/47", "solution": "def recipe_ingredients(recipe, available):\n    \"\"\"Checks if a particular recipe can be cooked with the available ingredients.\n\n    Args:\n        recipe (dict): A dictionary where the keys are the ingredient names and the values are the quantities.\n        available (dict): A dictionary where the keys are the ingredient names and the values are the quantities.\n\n    Returns:\n        bool: True if all ingredients needed for the recipe are available, False otherwise.\n    \"\"\"\n    for (ingredient, quantity) in recipe.items():\n        if ingredient not in available or available[ingredient] < quantity:\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/31": [{"task_id": "EvoEval/31", "solution": "def unique_paths(m: int, n: int):\n    \"\"\"\n    A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n    The robot can only move either down or right at any point in time. \n    The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n    How many possible unique paths are there from start to finish?\n    >>> unique_paths(3, 2)\n    3\n    >>> unique_paths(7, 3)\n    28\n    >>> unique_paths(3, 3)\n    6\n\n    :param m: the number of rows in the grid\n    :param n: the number of columns in the grid\n    :return: the number of possible unique paths from start to finish\n    \"\"\"\n    grid = [[0] * n for _ in range(m)]\n    for i in range(m):\n        grid[i][0] = 1\n    for j in range(n):\n        grid[0][j] = 1\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n    return grid[m - 1][n - 1]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/35": [{"task_id": "EvoEval/35", "solution": "def validate_email_structure(email: str):\n    \"\"\" email is a string.\n    return True if the email has a valid format (i.e., there is exactly one \"@\" character that is not the first or last character \n    and there is at least one \".\" character after the \"@\" character).\n\n    >>> validate_email_structure(\"myemail@\")\n    False\n    >>> validate_email_structure(\"myemail@domain\")\n    False\n    >>> validate_email_structure(\"myemail@domain.com\")\n    True\n    >>> validate_email_structure(\"myemail.domain.com\")\n    False\n    >>> validate_email_structure(\"myemail@domain@domain.com\")\n    False\n    \"\"\"\n    if email.count('@') == 1 and email.index('@') != 0 and (email.index('@') != len(email) - 1):\n        domain_part = email.split('@')[1]\n        if '.' in domain_part:\n            return True\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/81": [{"task_id": "EvoEval/81", "solution": "def alien_language(word_list, alien_dictionary):\n    if not word_list:\n        return 'CORRECT'\n    alien_dict = {char: i for (i, char) in enumerate(alien_dictionary)}\n    for i in range(len(word_list) - 1):\n        word1 = word_list[i]\n        word2 = word_list[i + 1]\n        for j in range(min(len(word1), len(word2))):\n            if alien_dict[word1[j]] < alien_dict[word2[j]]:\n                break\n            elif alien_dict[word1[j]] > alien_dict[word2[j]]:\n                return 'INCORRECT'\n        if len(word1) > len(word2):\n            return 'INCORRECT'\n    return 'CORRECT'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["zebra", "yak", "xenops"], "zyxwvutsrqponmlkjihgfedcba"]], "plus_fail_tests": []}], "EvoEval/10": [{"task_id": "EvoEval/10", "solution": "from typing import List\n\ndef count_animals(animal_string: str) -> List[int]:\n    animals = {'C': 'meow', 'D': 'woof', 'B': 'chirp'}\n    animal_counts = {}\n    result = []\n    total_animals = 0\n    for animal_sound_pair in animal_string.split():\n        if total_animals >= 5:\n            break\n        (animal, sound) = animal_sound_pair.split('|')\n        if animal in animals and animals[animal] == sound and (animal not in animal_counts):\n            animal_counts[animal] = animal_counts.get(animal, 0) + 1\n            result.append(animal_counts[animal])\n            total_animals += 1\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["C||| D|| B| C| K||| B|||"]], "plus_fail_tests": []}], "EvoEval/22": [{"task_id": "EvoEval/22", "solution": "", "base_status": "fail", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/42": [{"task_id": "EvoEval/42", "solution": "def find_legendary_item(player_input):\n    if not player_input:\n        return (False, None)\n    if 5 in player_input:\n        sorted_items = sorted(player_input, reverse=True)\n        legendary_index = sorted_items.index(5)\n        if legendary_index == 0:\n            return (True, -1)\n        else:\n            return (True, sorted_items[legendary_index - 1])\n    else:\n        return (False, None)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 4, 5]]], "plus_fail_tests": []}], "EvoEval/90": [{"task_id": "EvoEval/90", "solution": "def magical_multiply(s1, s2):\n    \"\"\"\n    In the mystical land of Pyth, numbers behave quite differently. Here, when two numbers are multiplied, the result is given by the sum of all possible unique combinations of their digits. \n\n    For example, if two numbers 24 and 13 are multiplied, the result would be the sum of all unique combinations of digits (2, 4) and (1, 3). The combinations would be (2, 1), (2, 3), (4, 1) and (4, 3) and their sums would be 3, 5, 5 and 7, and hence the result of the multiplication would be 3 + 5 + 5 + 7 = 20.\n\n    The function magical_multiply(s) would take in two positive integers as input (in string format) and should return their product according to the laws of the land of Pyth.\n\n    For example:\n    >>> magical_multiply('24', '13')\n    20\n    >>> magical_multiply('56', '79')\n    54\n    \"\"\"\n    product = 0\n    for digit1 in s1:\n        for digit2 in s2:\n            product += int(digit1) + int(digit2)\n    return product", "base_status": "fail", "plus_status": null, "base_fail_tests": [["999", "999"]], "plus_fail_tests": []}], "EvoEval/67": [{"task_id": "EvoEval/67", "solution": "def meal_calculator(customers, meals):\n    \"\"\"\n    Write a function meal_calculator which takes two arguments; a list of customer's names and a dictionary representing meals consumed by customers where the key is the customer's name and the value is a list of meals. Each meal is a dictionary with a 'dish' and 'calories' key. The function should return a dictionary where each key is a customer's name and the value is the total calories consumed by that customer.\n\n    If a customer's name does not exist in the meals dictionary, assume that the customer consumed 0 calories. The calories value for each meal will always be a positive integer.\n\n    Example:\n    >>> meal_calculator(['Alice', 'Bob', 'Charlie'], \n                        {'Alice': [{'dish':'Pizza', 'calories': 300}, {'dish':'Burger', 'calories': 500}], \n                         'Bob': [{'dish':'Salad', 'calories': 100}], \n                         'Charlie': [{'dish':'Fries', 'calories': 200}, {'dish':'Burger', 'calories': 500}, {'dish':'Ice Cream', 'calories': 250}]})\n    {'Alice': 800, 'Bob': 100, 'Charlie': 950}\n\n    >>> meal_calculator(['Tom', 'Jerry'], \n                        {'Tom': [{'dish':'Pizza', 'calories': 300}, {'dish':'Burger', 'calories': 500}], \n                         'Jerry': [{'dish':'Fries', 'calories': 200}]})\n    {'Tom': 800, 'Jerry': 200}\n    \"\"\"\n    total_calories = {}\n    for customer in customers:\n        if customer in meals:\n            total_calories[customer] = sum([meal['calories'] for meal in meals[customer]])\n        else:\n            total_calories[customer] = 0\n    return total_calories", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/33": [{"task_id": "EvoEval/33", "solution": "def magical_staircase(n: int, magic_stones: list):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for stone in magic_stones:\n            if i - stone >= 0:\n                dp[i] += dp[i - stone]\n    return dp[n]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/37": [{"task_id": "EvoEval/37", "solution": "def string_transform(s):\n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    transformed_sentence = ''\n    for char in s:\n        if char in vowels:\n            if char == 'a':\n                transformed_sentence += 'e'\n            elif char == 'e':\n                transformed_sentence += 'i'\n            elif char == 'i':\n                transformed_sentence += 'o'\n            elif char == 'o':\n                transformed_sentence += 'u'\n            elif char == 'u':\n                transformed_sentence += 'a'\n            elif char == 'A':\n                transformed_sentence += 'E'\n            elif char == 'E':\n                transformed_sentence += 'I'\n            elif char == 'I':\n                transformed_sentence += 'O'\n            elif char == 'O':\n                transformed_sentence += 'U'\n            elif char == 'U':\n                transformed_sentence += 'A'\n        elif char in consonants:\n            if char == 'z':\n                transformed_sentence += 'b'\n            elif char == 'Z':\n                transformed_sentence += 'B'\n            else:\n                transformed_sentence += chr(ord(char) + 1)\n        else:\n            transformed_sentence += char\n    return transformed_sentence", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Hello, World!"]], "plus_fail_tests": []}], "EvoEval/84": [{"task_id": "EvoEval/84", "solution": "def tree_traversal(tree):\n    paths = []\n    stack = [(tree, [])]\n    while stack:\n        (node, path) = stack.pop()\n        if not node:\n            continue\n        path.append(list(node.keys())[0])\n        if not node[list(node.keys())[0]]:\n            paths.append(path)\n        else:\n            stack.append((node[list(node.keys())[0]], path.copy()))\n            stack.append((node[list(node.keys())[1]], path.copy()))\n    return paths", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"1": {"2": {"4": {}, "5": {}}, "3": {"6": {}, "7": {}}}}]], "plus_fail_tests": []}], "EvoEval/15": [{"task_id": "EvoEval/15", "solution": "def evaluate_poker_hand(hand: list):\n    values = {'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13}\n    card_values = [values[card[:-1]] for card in hand]\n    card_counts = {value: card_values.count(value) for value in set(card_values)}\n    score = 0\n    for (value, count) in card_counts.items():\n        if count == 2:\n            score += value\n        elif count == 3:\n            score += 2 * value\n        elif count == 4:\n            score += 3 * value\n        elif count == 5:\n            score += 4 * value\n    return score", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/30": [{"task_id": "EvoEval/30", "solution": "from typing import List, Tuple\n\ndef find_path(maze: List[List[int]], start: Tuple[int], end: Tuple[int]) -> List[Tuple[int]]:\n    \"\"\"Returns the shortest path from start to end in a maze represented by a 2D array.\n\n    The maze is a 2D array where 0s represent walls and 1s represent open paths. The start and end points \n    are tuples representing coordinates in the 2D array. The function should return a list of points \n    representing the shortest path from start to end. If no path is possible, return an empty list.\n\n    >>> maze = [[1,0,1,1,1], [1,0,1,0,1], [1,1,1,0,1], [1,0,0,0,1], [1,1,1,1,1]]\n    >>> start = (0,0)\n    >>> end = (4, 4)\n    >>> find_path(maze, start, end)\n    [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4)]\n\n    >>> maze = [[1,0,1], [0,0,1], [1,1,1]]\n    >>> start = (0,0)\n    >>> end = (2, 2)\n    >>> find_path(maze, start, end)\n    []\n    \"\"\"\n    rows = len(maze)\n    cols = len(maze[0])\n    visited = [[False] * cols for _ in range(rows)]\n    path = []\n\n    def dfs(row: int, col: int) -> bool:\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or (maze[row][col] == 0) or visited[row][col]:\n            return False\n        visited[row][col] = True\n        path.append((row, col))\n        if (row, col) == end:\n            return True\n        if dfs(row + 1, col) or dfs(row - 1, col) or dfs(row, col + 1) or dfs(row, col - 1):\n            return True\n        path.pop()\n        return False\n    if dfs(start[0], start[1]):\n        return path\n    return []", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/20": [{"task_id": "EvoEval/20", "solution": "def generate_pattern(n: int):\n    if n <= 0:\n        return []\n    patterns = []\n    for i in range(1, n + 1):\n        pattern = ','.join((str(j) for j in range(1, i + 1)))\n        patterns.append(pattern)\n    for i in range(n, 0, -1):\n        pattern = ','.join((str(j) for j in range(1, i + 1)))\n        patterns.append(pattern)\n    return patterns", "base_status": "fail", "plus_status": null, "base_fail_tests": [[3]], "plus_fail_tests": []}], "EvoEval/68": [{"task_id": "EvoEval/68", "solution": "def magical_sorting(arr):\n    if len(arr) == 0:\n        return True\n    sorted_arr = sorted(arr)\n    if arr == sorted_arr:\n        return True\n    n = len(arr)\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            break\n    else:\n        return True\n    for i in range(n):\n        if arr[i] > arr[(i + 1) % n]:\n            (arr[i], arr[(i + 1) % n]) = (arr[(i + 1) % n], arr[i])\n            break\n    else:\n        return False\n    return arr == sorted_arr", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 4, 5, 1, 2]]], "plus_fail_tests": []}], "EvoEval/21": [{"task_id": "EvoEval/21", "solution": "def crossword_validator(grid: list, words: list):\n    \"\"\"\n    Consider a 2D grid representing a square crossword puzzle. Each cell of the grid contains a single character.\n\n    Determine if all the words from a provided list of words can be found in the grid.\n    Words can be found left-to-right (in a row), right-to-left (in a row),\n    top-to-bottom down (in a column), and bottom-to-top (in a column).\n\n    We assume that words are only found in contiguous cells and words do not 'wrap' around the grid.\n\n    Note: the grid is a square (N x N) and all words are lowercase.\n\n    Parameters:\n    grid: list of list of char - where each char is a lowercase letter.\n    words: list of str - where each str is a lowercase word.\n\n    Returns:\n    boolean - return True all words are found in the grid, False otherwise.\n\n    >>> crossword_validator([['c', 'a', 't'], ['d', 'o', 'g'], ['d', 'o', 'p']], ['cat', 'dog', 'pop'])\n    False\n    >>> crossword_validator([['c', 'a', 't'], ['d', 'o', 'g'], ['d', 'o', 'p']], ['cdd', 'dog', 'pod'])\n    True\n    \"\"\"\n\n    def search_word(word):\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if search_right(i, j, word) or search_left(i, j, word) or search_down(i, j, word) or search_up(i, j, word):\n                    return True\n        return False\n\n    def search_right(row, col, word):\n        if col + len(word) > len(grid):\n            return False\n        for k in range(len(word)):\n            if grid[row][col + k] != word[k]:\n                return False\n        return True\n\n    def search_left(row, col, word):\n        if col - len(word) < -1:\n            return False\n        for k in range(len(word)):\n            if grid[row][col - k] != word[k]:\n                return False\n        return True\n\n    def search_down(row, col, word):\n        if row + len(word) > len(grid):\n            return False\n        for k in range(len(word)):\n            if grid[row + k][col] != word[k]:\n                return False\n        return True\n\n    def search_up(row, col, word):\n        if row - len(word) < -1:\n            return False\n        for k in range(len(word)):\n            if grid[row - k][col] != word[k]:\n                return False\n        return True\n    for word in words:\n        if not search_word(word):\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/97": [{"task_id": "EvoEval/97", "solution": "def alien_invasion(alien, humans):\n    if not isinstance(alien, str) or not isinstance(humans, dict):\n        return []\n    continents = ['Asia', 'Africa', 'Europe', 'North America', 'South America']\n    encounter_order = []\n    if alien not in continents:\n        return []\n    for continent in continents:\n        for (human, location) in humans.items():\n            if location == continent:\n                encounter_order.append(human)\n    return encounter_order", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Xenomorph", {"John": "Asia", "Sarah": "Europe", "Michael": "North America", "Ana": "Africa"}]], "plus_fail_tests": []}], "EvoEval/3": [{"task_id": "EvoEval/3", "solution": "from typing import List\n\ndef magical_alphabet(input_string: str) -> List[int]:\n\n    def backtrack(index: int, path: str) -> None:\n        if index == len(input_string):\n            combinations.append(path)\n            return\n        if input_string[index] != '0':\n            char = chr(ord('a') + int(input_string[index]) - 1)\n            backtrack(index + 1, path + char)\n        if index + 1 < len(input_string) and input_string[index] != '0' and (int(input_string[index:index + 2]) <= 26):\n            char = chr(ord('a') + int(input_string[index:index + 2]) - 1)\n            backtrack(index + 2, path + char)\n    combinations = []\n    backtrack(0, '')\n    return combinations", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/46": [{"task_id": "EvoEval/46", "solution": "", "base_status": "fail", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/23": [{"task_id": "EvoEval/23", "solution": "def prime_cipher(s: str):\n    result = ''\n    for char in s:\n        if char.islower():\n            prime_num = get_prime_number(ord(char) - ord('a') + 1)\n            result += str(prime_num)\n        else:\n            result += char\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["hello"]], "plus_fail_tests": []}], "EvoEval/27": [{"task_id": "EvoEval/27", "solution": "def split_strings(s: str, n: int):\n    \"\"\"Return a list of n-character long strings created from the input string s.\n    If the length of s isn't a multiple of n, the remaining characters are added as the \n    last element of the returned list.\n\n    >>> split_strings('HelloWorld', 3)\n    ['Hel', 'loW', 'orl', 'd']\n    >>> split_strings('CodingIsFun', 5)\n    ['Codin', 'gIsFu', 'n']\n    \"\"\"\n    result = []\n    for i in range(0, len(s), n):\n        result.append(s[i:i + n])\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/8": [{"task_id": "EvoEval/8", "solution": "def transform_canvas(canvas: str) -> str:\n    if canvas.count('P') != 1:\n        return 'Invalid canvas'\n    painter_index = canvas.index('P')\n    empty_spaces = canvas.count('-')\n    if empty_spaces % 2 != 0:\n        return 'Invalid canvas'\n    updated_canvas = list(canvas)\n    updated_canvas[painter_index] = '*'\n    for i in range(painter_index + 1, len(canvas)):\n        if canvas[i] == '#':\n            break\n        if canvas[i] == '-':\n            updated_canvas[i] = '*'\n    for i in range(painter_index - 1, -1, -1):\n        if canvas[i] == '#':\n            break\n        if canvas[i] == '-':\n            updated_canvas[i] = '*'\n    return ''.join(updated_canvas)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["P----#-----#-----#-----"]], "plus_fail_tests": []}], "EvoEval/99": [{"task_id": "EvoEval/99", "solution": "def musical_chairs(n, rounds, music):\n    players = list(range(1, n + 1))\n    position = 0\n    for round_time in rounds:\n        position += round_time * music - 1\n        position %= len(players)\n        players.pop(position)\n    return players", "base_status": "fail", "plus_status": null, "base_fail_tests": [[5, [2, 3, 4], 1]], "plus_fail_tests": []}], "EvoEval/1": [{"task_id": "EvoEval/1", "solution": "from typing import List, Union\n\ndef calculate_shipping_cost(items: List[Union[str, float]], location: str) -> float:\n    \"\"\"\n    Given a list of items (represented by their weights in kg) and a location,\n    calculate the cost of shipping. Each item has a base shipping cost of $5.0.\n    The location multiplies the total cost by a certain factor:\n    - \"Local\": no additional factor\n    - \"National\": factor of 1.5\n    - \"International\": factor of 2.5\n    - other location: no additional factor\n    If the item's weight is more than 5kg, an additional charge of $10.0 is added.\n    \n    If an item is passed as a string instead of a float, consider its weight as 1kg.\n    \n    Return the total shipping cost rounded to two decimal places.\n    \n    >>> calculate_shipping_cost([3.0, 'Book', 7.0], 'National')\n    37.5\n    >>> calculate_shipping_cost([1.0, 2.0, 3.0, 4.0], 'Local')\n    20.0\n    >>> calculate_shipping_cost([5.5, 2.0, 3.0], 'International')\n    62.5\n    \"\"\"\n    total_cost = 0.0\n    for item in items:\n        if isinstance(item, str):\n            weight = 1.0\n        else:\n            weight = float(item)\n        if weight > 5.0:\n            total_cost += 10.0\n        total_cost += 5.0\n    if location == 'National':\n        total_cost *= 1.5\n    elif location == 'International':\n        total_cost *= 2.5\n    return round(total_cost, 2)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/11": [{"task_id": "EvoEval/11", "solution": "from typing import List\n\ndef fruity_messages(fruits: List[str], location: str) -> str:\n    if len(fruits) == 1:\n        return f'Oh, are those {fruits[0]} from {location}? Marvelous!'\n    elif len(fruits) == 2:\n        return f'Oh, are those {fruits[0]} and {fruits[1]} from {location}? Marvelous!'\n    else:\n        fruit_str = ', '.join(fruits[:-1]) + f', and {fruits[-1]}'\n        return f'Oh, are those {fruit_str} from {location}? Marvelous!'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["strawberries", "pineapples", "kiwis", "guavas", "papayas", "peaches", "grapes", "oranges", "apples"], "California"]], "plus_fail_tests": []}], "EvoEval/95": [{"task_id": "EvoEval/95", "solution": "def matrixMystery(m):\n    if len(m) != len(m[0]):\n        return 'Invalid Matrix'\n    diagonal1_sum = 0\n    diagonal2_sum = 0\n    for i in range(len(m)):\n        diagonal1_sum += m[i][i]\n        diagonal2_sum += m[i][len(m) - i - 1]\n    return abs(diagonal1_sum - diagonal2_sum)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/43": [{"task_id": "EvoEval/43", "solution": "def space_travel(distance, speed, fuel, planet_gravity, spaceship_weight):\n    fuel_consumption = spaceship_weight * planet_gravity * 0.1\n    trip_duration = distance / speed\n    if fuel >= trip_duration:\n        remaining_fuel = round(fuel - fuel_consumption, 2)\n        return remaining_fuel if remaining_fuel >= 0 else 'Insufficient fuel'\n    else:\n        return 'Insufficient fuel'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[2.5, 1, 2, 3.7, 1.5]], "plus_fail_tests": []}], "EvoEval/6": [{"task_id": "EvoEval/6", "solution": "from typing import List, Tuple\n\ndef minesweeper_clicked(grid: List[List[int]], position: Tuple[int, int]) -> List[List[int]]:\n    (x, y) = position\n    (rows, cols) = (len(grid), len(grid[0]))\n    if x < 0 or x >= rows or y < 0 or (y >= cols) or (grid[x][y] == 1):\n        return grid\n    if grid[x][y] == 0:\n        return grid\n\n    def is_valid_cell(i, j):\n        return 0 <= i < rows and 0 <= j < cols\n\n    def reveal_adjacent_cells(i, j):\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (new_x, new_y) = (i + dx, j + dy)\n                if is_valid_cell(new_x, new_y) and grid[new_x][new_y] != 1:\n                    grid[new_x][new_y] = 0\n                    if grid[new_x][new_y] == 0:\n                        reveal_adjacent_cells(new_x, new_y)\n    grid[x][y] = 0\n    reveal_adjacent_cells(x, y)\n    return grid", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[0, 1, -1], [1, -1, 0], [0, 1, 1]], [1, 1]]], "plus_fail_tests": []}], "EvoEval/39": [{"task_id": "EvoEval/39", "solution": "def asciiArt(n, s):\n    result = ''\n    for i in range(n):\n        result += '*' + s * n + '*\\n'\n    result += '*' * (len(s) * n + 2) + '\\n'\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1, "abc"]], "plus_fail_tests": []}], "EvoEval/56": [{"task_id": "EvoEval/56", "solution": "def str_to_morse_code(s):\n    morse_code_dict = {'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', 'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', 's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', 'y': '-.--', 'z': '--..'}\n    morse_code = []\n    for char in s:\n        if char == ' ':\n            morse_code.append('/')\n        else:\n            morse_code.append(morse_code_dict[char])\n    return ' '.join(morse_code)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["this has multiple   spaces"]], "plus_fail_tests": []}], "EvoEval/29": [{"task_id": "EvoEval/29", "solution": "def find_palindrome_substrings(s: str):\n    \"\"\"\n    Given a string, find all unique substrings that are palindromes.\n    \n    A palindrome is a word, number, phrase, or other sequence of characters that reads the same forward and backward, ignoring spaces, punctuation, and capitalization.\n    \n    Return a list of all unique palindrome substrings, sorted in ascending order.\n\n    >>> find_palindrome_substrings('racecar')\n    ['a', 'aceca', 'c', 'cec', 'e', 'r', 'racecar']\n\n    >>> find_palindrome_substrings('madam')\n    ['a', 'ada', 'd', 'm', 'madam']\n\n    >>> find_palindrome_substrings('civic')\n    ['c', 'civic', 'i', 'ivi', 'v']\n\n    >>> find_palindrome_substrings('hello')\n    ['e', 'h', 'l', 'll', 'o']\n\n    >>> find_palindrome_substrings('hannah')\n    ['a', 'anna', 'h', 'hannah', 'n', 'nn']\n    \"\"\"\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    substrings = set()\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if is_palindrome(substring):\n                substrings.add(substring)\n    return sorted(list(substrings))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/93": [{"task_id": "EvoEval/93", "solution": "def secret_code(message, n_values):\n    encoded_message = ''\n    n_values_cycle = cycle(n_values)\n    for char in message:\n        if char.isalpha():\n            n = next(n_values_cycle)\n            if char.isupper():\n                encoded_char = chr((ord(char) - 65 + n) % 26 + 65)\n            else:\n                encoded_char = chr((ord(char) - 97 + n) % 26 + 97)\n            encoded_message += encoded_char\n        else:\n            encoded_message += char\n    return encoded_message", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Hello", [1, 2, 3, 4, 5]]], "plus_fail_tests": []}], "EvoEval/49": [{"task_id": "EvoEval/49", "solution": "", "base_status": "fail", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/41": [{"task_id": "EvoEval/41", "solution": "def spider_web_jump(arr):\n    rows = len(arr)\n    cols = len(arr[0])\n    dp = [[float('inf')] * cols for _ in range(rows)]\n    dp[0][0] = 0\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + arr[i][j])\n            if j > 0:\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + arr[i][j])\n    return dp[-1][-1]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[2, 3], [1, 0]]]], "plus_fail_tests": []}], "EvoEval/9": [{"task_id": "EvoEval/9", "solution": "\ndef calculate_word_frequency(string: str) -> dict:\n    \"\"\" Given a string, calculate the frequency of each word present in that string (regardless of case) and return a dictionary with words as keys and their frequencies as values. \n    Words are separated by spaces. Ignore punctuation.\n    \n    >>> calculate_word_frequency('Hello, World! Hello Again.')\n    {'hello': 2, 'world': 1, 'again': 1}\n\n    >>> calculate_word_frequency('This is a test. This is only a test.')\n    {'this': 2, 'is': 2, 'a': 2, 'test': 2, 'only': 1}\n    \"\"\"\n    string = re.sub('[^\\\\w\\\\s]', '', string.lower())\n    words = string.split()\n    word_frequency = {}\n    for word in words:\n        if word in word_frequency:\n            word_frequency[word] += 1\n        else:\n            word_frequency[word] = 1\n    return word_frequency", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Hello, World! Hello Again."]], "plus_fail_tests": []}], "EvoEval/7": [{"task_id": "EvoEval/7", "solution": "def find_shangri_la(code_sequence: list[int]) -> str:\n    \"\"\"\n    You are an explorer trying to find the mythical city of Shangri-La. According to an ancient text,\n    Shangri-La can be found by following a code sequence of numbers, each referring to the direction to move.\n    The directions correspond to 0: North, 1: East, 2: South, 3: West.\n    \n    Implement a function that takes a sequence of numbers as input and returns whether the sequence leads to Shangri-La.\n    Assume starting point is always (0,0). If the sequence leads back to the starting point, it has found Shangri-La and \n    function should return 'Shangri-La found'. Otherwise, return 'Shangri-La not found'.\n    Not moving is considered as not found.\n    \n    Note: Every move is considered as unit = 1.\n\n    Example:\n    >>> find_shangri_la([0, 1, 2, 3])\n    'Shangri-La found'\n    \n    >>> find_shangri_la([0, 1, 0, 3])\n    'Shangri-La not found'\n    \"\"\"\n    (x, y) = (0, 0)\n    for direction in code_sequence:\n        if direction == 0:\n            y += 1\n        elif direction == 1:\n            x += 1\n        elif direction == 2:\n            y -= 1\n        elif direction == 3:\n            x -= 1\n    if x == 0 and y == 0:\n        return 'Shangri-La found'\n    else:\n        return 'Shangri-La not found'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[]]], "plus_fail_tests": []}], "EvoEval/73": [{"task_id": "EvoEval/73", "solution": "", "base_status": "fail", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/60": [{"task_id": "EvoEval/60", "solution": "def happy_ants(path_length, sugar_locations, ant_positions):\n    sugar_map = {loc: False for loc in sugar_locations}\n    happy_ants_count = 0\n    for (ant_pos, direction) in ant_positions:\n        if ant_pos in sugar_map and (not sugar_map[ant_pos]):\n            sugar_map[ant_pos] = True\n            happy_ants_count += 1\n        if direction == 'right':\n            for i in range(ant_pos + 1, path_length):\n                if i in sugar_map and (not sugar_map[i]):\n                    sugar_map[i] = True\n                    happy_ants_count += 1\n                else:\n                    break\n        elif direction == 'left':\n            for i in range(ant_pos - 1, -1, -1):\n                if i in sugar_map and (not sugar_map[i]):\n                    sugar_map[i] = True\n                    happy_ants_count += 1\n                else:\n                    break\n    return happy_ants_count", "base_status": "fail", "plus_status": null, "base_fail_tests": [[3, [2], [[0, "right"], [1, "right"], [2, "left"]]]], "plus_fail_tests": []}], "EvoEval/87": [{"task_id": "EvoEval/87", "solution": "def word_spiral(arr):\n    \"\"\"Create a function which takes in a 2D array of characters and returns a \n    string which represents the words in the array read in a clockwise spiral starting\n    from the top left corner. If the array is empty, return an empty string. \n\n    Examples:\n    assert word_spiral([['h','i','!'],['b','y','e']]) == 'hi!eyb'\n    assert word_spiral([['l','o','v','e'],['i','s','i','n'],['t','h','e','a'],['i','r', '!','!!']]) == 'lovena!!!ritisieh'\n    assert word_spiral([]) == ''\n    \"\"\"\n    if not arr:\n        return ''\n    result = ''\n    top_row = 0\n    bottom_row = len(arr) - 1\n    left_col = 0\n    right_col = len(arr[0]) - 1\n    while top_row <= bottom_row and left_col <= right_col:\n        for i in range(left_col, right_col + 1):\n            result += arr[top_row][i]\n        top_row += 1\n        for i in range(top_row, bottom_row + 1):\n            result += arr[i][right_col]\n        right_col -= 1\n        if top_row <= bottom_row:\n            for i in range(right_col, left_col - 1, -1):\n                result += arr[bottom_row][i]\n            bottom_row -= 1\n        if left_col <= right_col:\n            for i in range(bottom_row, top_row - 1, -1):\n                result += arr[i][left_col]\n            left_col += 1\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[["t", "h", "i", "s", "f", "u", "n", "c", "t", "i", "o", "n", "t", "e", "s", "t"], ["a", "n", "i", "s", "r", "e", "a", "l", "l", "y", "g", "o", "o", "d", "o", "n"], ["t", "i", "m", "e", "t", "o", "s", "e", "e", "i", "f", "i", "t", "p", "a", "s", "s"], ["e", "s", "t", "r", "t", "h", "i", "s", "p", "r", "o", "g", "r", "a", "m", "m", "e"]]]], "plus_fail_tests": []}], "EvoEval/17": [{"task_id": "EvoEval/17", "solution": "def wizard_battle(dragon_hp: int, wizards: list) -> str:\n    \"\"\" Return the name of the wizard who defeated the dragon, given the dragon's hit points (HP) and\n    an ordered list with the name of the wizard and their magic power:\n        - The wizard's magic reduces the dragon's HP by their magic power. \n        - Wizards take turns in the order they are listed, and they only get to attack once.\n        - The dragon is defeated when its HP is reduced to 0 or less.\n\n    If none of the wizards can defeat the dragon return 'The dragon won!'\n\n    Note that the wizards are a list of tuples, where each tuple has the wizard's name as a string and\n    their magic power as an integer. The dragon's HP is a positive integer.\n\n    >>> wizard_battle(20, [('Gandalf', 15), ('Merlin', 10), ('Dumbledore', 30)])\n    'Merlin'\n    >>> wizard_battle(100, [('Harry', 25), ('Ron', 20), ('Hermione', 30), ('Luna', 10)])\n    'The dragon won!'\n    >>> wizard_battle(65, [('Newt', 15), ('Tina', 20)])\n    'The dragon won!'\n    \"\"\"\n    for wizard in wizards:\n        if dragon_hp <= 0:\n            return wizard[0]\n        dragon_hp -= wizard[1]\n    return 'The dragon won!'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[20, [["Gandalf", 15], ["Merlin", 10], ["Dumbledore", 30]]]], "plus_fail_tests": []}], "EvoEval/5": [{"task_id": "EvoEval/5", "solution": "from typing import List, Tuple\n\n\ndef zigzag_traversal(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a 2D list of integers, return a list that represents its elements traversed in a zigzag order starting from the top-left corner and moving rightwards.\n    When the right end is reached, the direction should be downwards to the next row, then to the left end, and so on until all elements are covered. \n    >>> zigzag_traversal([[1, 2], [3, 4], [5, 6, 7], [8, 9, 10]])\n    [1, 2, 4, 3, 5, 6, 7, 10, 9, 8]\n    \"\"\"\n    if not matrix:\n        return []\n    rows = len(matrix)\n    cols = max((len(row) for row in matrix))\n    result = []\n    direction = 1\n    (row, col) = (0, 0)\n    while row < rows and col < cols:\n        result.append(matrix[row][col])\n        if direction == 1:\n            if col == cols - 1:\n                row += 1\n                direction = -1\n            elif row == 0:\n                col += 1\n                direction = -1\n            else:\n                row -= 1\n                col += 1\n        elif row == rows - 1:\n            col += 1\n            direction = 1\n        elif col == 0:\n            row += 1\n            direction = 1\n        else:\n            row += 1\n            col -= 1\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[null, 2], [3, 4], [5, 6, 7], [8, 9, 10]]]], "plus_fail_tests": []}], "EvoEval/28": [{"task_id": "EvoEval/28", "solution": "def calculate_progressive_tax(income: float, deductions=0) -> float:\n    \"\"\"\n    Calculate the tax for a given income and deductions according to a set of progressive tax rates:\n\n    - Up to $10,000 of income is tax-free\n    - The next $25,000 is taxed at 15%\n    - The next $45,000 is taxed at 25%\n    - Any income over $130,000 is taxed at 30%\n\n    The function also considers tax reductions due to deductions:\n        - The first $1000 of deductions are subtracted at a 1:1 ratio from the taxable income\n        - The next $2000 of deductions are subtracted at a 2:1 ratio from the taxable income\n        - Any deduction over $3000 is subtracted at a 3:1 ratio from the taxable income\n\n    It should return a float representing the amount of tax.\n\n    Examples:\n    >>> calculate_progressive_tax(12000, 500)\n    225.0\n    >>> calculate_progressive_tax(55000, 2500)\n    7750.0\n    >>> calculate_progressive_tax(120000, 5000)\n    23700.0\n    \"\"\"\n    taxable_income = income - deductions\n    if taxable_income <= 10000:\n        tax = 0\n    elif taxable_income <= 35000:\n        tax = (taxable_income - 10000) * 0.15\n    elif taxable_income <= 80000:\n        tax = 3750 + (taxable_income - 35000) * 0.25\n    else:\n        tax = 13125 + (taxable_income - 80000) * 0.3\n    return tax", "base_status": "fail", "plus_status": null, "base_fail_tests": [[55000, 2500]], "plus_fail_tests": []}], "EvoEval/51": [{"task_id": "EvoEval/51", "solution": "def alien_encoding(string, list_of_alphabets):\n    if string == '':\n        return ''\n    if list_of_alphabets == []:\n        return string\n    encoded_string = ''\n    for i in range(len(string)):\n        alphabet_index = i % len(list_of_alphabets)\n        encoded_string += list_of_alphabets[alphabet_index]\n    return encoded_string", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/69": [{"task_id": "EvoEval/69", "solution": "def magicTrick(cards, magicNumber):\n    \"\"\"\n    In this problem, you are a magician who needs to perform a card trick. You have a list of cards, each marked with a number, and a magic number.\n\n    Your task is to implement a function that takes a list of card numbers and a magic number. The function should determine whether it's possible to select two cards such that when multiplied, their product equals the magic number.\n\n    The function should return the indices of the two cards if it's possible, and \"No magic today\" if it's not. The indices should be 0-indexed and returned in an ascending order i.e., (smaller index, larger index). \n\n    For example:\n    magicTrick([2, 3, 4, 5], 20) => (2, 3)\n    magicTrick([1, 1, 1, 1], 1) => (0, 1)\n    magicTrick([1, 2, 3, 4], 10) => \"No magic today\"\n\n    It is assumed that the input list will be non-empty and the magic number will be a positive integer.\n    \"\"\"\n    for i in range(len(cards)):\n        for j in range(i + 1, len(cards)):\n            if cards[i] * cards[j] == magicNumber:\n                return (i, j)\n    return 'No magic today'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/36": [{"task_id": "EvoEval/36", "solution": "def calculate_integral_coefficients(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return indefinite integral of this polynomial in the same form, with the constant of integration set to zero,\n    i.e. you should generate the coefficients for the polynomial representing the integral of the input polynomial.\n    So for example, if the input is [3, 2, 1], then the output would represent the polynomial 3*x + x^2 + x^3/3\n    >>> calculate_integral_coefficients([3, 2, 1])\n    [0, 3.0, 1.0, 0.3333333333333333]\n    >>> calculate_integral_coefficients([1, 3, 3, 1])\n    [0, 1.0, 1.5, 1.0, 0.25]\n    \"\"\"\n    integral_coeffs = [0]\n    for (i, coeff) in enumerate(xs):\n        integral_coeffs.append(coeff / (i + 1))\n    return integral_coeffs", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/79": [{"task_id": "EvoEval/79", "solution": "def find_fruitful_days(prices, days):\n    max_profit = 0\n    min_price = float('inf')\n    for i in range(days):\n        min_price = min(min_price, prices[i])\n        max_profit = max(max_profit, prices[i] - min_price)\n    return max_profit", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/86": [{"task_id": "EvoEval/86", "solution": "def sort_movies_by_ratings_and_release_date(movies_dict):\n    sorted_movies = sorted(movies_dict.keys(), key=lambda x: (movies_dict[x][0], movies_dict[x][1]), reverse=True)\n    return sorted_movies", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/72": [{"task_id": "EvoEval/72", "solution": "def string_fairy_tale(lst):\n    tales = []\n    for string in lst:\n        count = sum((1 for char in string if char.isdigit()))\n        tale = \"Once upon a time, in a kingdom far away, lived a magical creature with the name of '{}' who was known for telling {} tales a day\".format(string, count)\n        tales.append(tale)\n    return tales", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/4": [{"task_id": "EvoEval/4", "solution": "from typing import List\n\n\ndef candles_relight(candles: List[int]) -> int:\n    \"\"\"\n    You've got a list representing a row of birthday candles of various heights.\n    A candle at position \"i\" can be lit (gets the flame) if it is taller than all the candles \n    before it. The first candle is always lit. \n    Your task is to return the number of candles that can be lit.\n    An empty list means there were no candles, so return 0.\n\n    >>> candles_relight([3, 2, 1, 3, 2, 4])\n    2\n    >>> candles_relight([1, 2, 3, 4, 5])\n    5\n    >>> candles_relight([])\n    0\n    \"\"\"\n    if not candles:\n        return 0\n    count = 1\n    max_height = candles[0]\n    for candle in candles[1:]:\n        if candle > max_height:\n            count += 1\n            max_height = candle\n    return count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/48": [{"task_id": "EvoEval/48", "solution": "def wizard_inventory(inventory_logs):\n    inventory = {}\n    for log in inventory_logs:\n        item = log['item']\n        quantity = log['quantity']\n        if item in inventory:\n            inventory[item] += quantity\n        else:\n            inventory[item] = quantity\n    final_inventory = {item: quantity for (item, quantity) in inventory.items() if quantity > 0}\n    return final_inventory", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/45": [{"task_id": "EvoEval/45", "solution": "def find_castle(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n    left_count = [1] * n\n    right_count = [1] * n\n    for i in range(1, n):\n        if arr[i] > arr[i - 1]:\n            left_count[i] = left_count[i - 1] + 1\n    for i in range(n - 2, -1, -1):\n        if arr[i] > arr[i + 1]:\n            right_count[i] = right_count[i + 1] + 1\n    max_hills = 0\n    for i in range(n):\n        max_hills = max(max_hills, left_count[i] + right_count[i] - 1)\n    return max_hills", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 2, 5, 3, 6, 4, 8, 2, 7]]], "plus_fail_tests": []}], "EvoEval/58": [{"task_id": "EvoEval/58", "solution": "def interstellar_translator(earth_phrase):\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    translated_phrase = ''\n    words = earth_phrase.split()\n    for word in words:\n        translated_word = word.capitalize()\n        for char in translated_word:\n            if char in vowels:\n                translated_word = translated_word.replace(char, vowels[(vowels.index(char) + 1) % len(vowels)])\n            elif char in consonants:\n                translated_word = translated_word.replace(char, consonants[(consonants.index(char) + 1) % len(consonants)])\n            elif char == ' ':\n                translated_word = translated_word.replace(char, '@')\n        if word[0] in vowels:\n            translated_word += 'xy'\n        else:\n            translated_word += 'yz'\n        translated_phrase += translated_word + ' '\n    return translated_phrase.strip()", "base_status": "fail", "plus_status": null, "base_fail_tests": [["hello world"]], "plus_fail_tests": []}], "EvoEval/54": [{"task_id": "EvoEval/54", "solution": "def find_star_map(lst, star):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == star:\n                coordinates.append((i, j))\n    return coordinates", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/53": [{"task_id": "EvoEval/53", "solution": "def magical_transformation(s):\n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    transformed = ''\n    for (i, char) in enumerate(s):\n        if char in vowels:\n            if char == 'u':\n                transformed += 'a' if char.islower() else 'A'\n            else:\n                transformed += chr(ord(char) + 1) if char.islower() else chr(ord(char) + 1).upper()\n        elif char in consonants:\n            if char == 'z':\n                transformed += 'b' if char.islower() else 'B'\n            elif char == 'Z':\n                transformed += 'B'\n            else:\n                transformed += chr(ord(char) + 1) if char.islower() else chr(ord(char) + 1).upper()\n        else:\n            transformed += char\n        if i % 2 == 0 and char == '?':\n            transformed = transformed[:-1] + '!' if transformed[-1] == '?' else transformed[:-1] + '?'\n    return transformed", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Hello World???"]], "plus_fail_tests": []}], "EvoEval/18": [{"task_id": "EvoEval/18", "solution": "def magical_seven(n: int):\n    \"\"\"\n    magical_seven returns the n-th number that is a multiple of 7 and its digits sum up to 7.\n    \n    >>> magical_seven(1)\n    7\n    >>> magical_seven(2)\n    70\n    >>> magical_seven(3)\n    133\n    >>> magical_seven(4)\n    322\n    >>> magical_seven(5)\n    511\n    \"\"\"\n    count = 0\n    num = 0\n    while count < n:\n        num += 1\n        if num % 7 == 0 and sum((int(digit) for digit in str(num))) == 7:\n            count += 1\n    return num", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/80": [{"task_id": "EvoEval/80", "solution": "def adventure_game(map, instructions):\n    (start_row, start_column) = (None, None)\n    for i in range(len(map)):\n        for j in range(len(map[i])):\n            if map[i][j] == 'S':\n                (start_row, start_column) = (i, j)\n                break\n    if start_row is None or start_column is None:\n        return []\n    path = [(start_row, start_column)]\n    (current_row, current_column) = (start_row, start_column)\n    for instruction in instructions:\n        if instruction == 'up':\n            if current_row > 0 and map[current_row - 1][current_column] != 'X':\n                current_row -= 1\n        elif instruction == 'down':\n            if current_row < len(map) - 1 and map[current_row + 1][current_column] != 'X':\n                current_row += 1\n        elif instruction == 'left':\n            if current_column > 0 and map[current_row][current_column - 1] != 'X':\n                current_column -= 1\n        elif instruction == 'right':\n            if current_column < len(map[0]) - 1 and map[current_row][current_column + 1] != 'X':\n                current_column += 1\n        path.append((current_row, current_column))\n        if map[current_row][current_column] == 'E':\n            break\n    return path", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[["S", "X", "E"]], ["right", "right"]]], "plus_fail_tests": []}], "EvoEval/0": [{"task_id": "EvoEval/0", "solution": "from typing import List, Union\n\n", "base_status": "fail", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/26": [{"task_id": "EvoEval/26", "solution": "def pathfinder(maze, start, end):\n    if start == end:\n        return []\n    rows = len(maze)\n    cols = len(maze[0])\n    visited = [[False] * cols for _ in range(rows)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    direction_names = ['right', 'left', 'down', 'up']\n\n    def dfs(row, col):\n        if row < 0 or row >= rows or col < 0 or (col >= cols) or (maze[row][col] == 1) or visited[row][col]:\n            return False\n        visited[row][col] = True\n        if (row, col) == end:\n            return True\n        for i in range(len(directions)):\n            new_row = row + directions[i][0]\n            new_col = col + directions[i][1]\n            if dfs(new_row, new_col):\n                return True\n        return False\n    if dfs(start[0], start[1]):\n        path = []\n        (row, col) = start\n        while (row, col) != end:\n            for i in range(len(directions)):\n                new_row = row + directions[i][0]\n                new_col = col + directions[i][1]\n                if new_row >= 0 and new_row < rows and (new_col >= 0) and (new_col < cols) and visited[new_row][new_col]:\n                    path.append(direction_names[i])\n                    row = new_row\n                    col = new_col\n                    break\n        return path\n    return []", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[0, 0, 0], [1, 1, 0], [1, 1, 0]], [0, 0], [2, 2]]], "plus_fail_tests": []}], "EvoEval/77": [{"task_id": "EvoEval/77", "solution": "def magical_sequence(sequence, k):\n    points = []\n    for num in sequence:\n        count = 0\n        while num % k == 0:\n            num //= k\n            count += 1\n        points.append(count)\n    return sorted(points, reverse=True)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 1, 1, 1, 1, 1], 1]], "plus_fail_tests": []}], "EvoEval/64": [{"task_id": "EvoEval/64", "solution": "def magical_sequence(start, end, divisor):\n    \"\"\"This function takes three positive integers: 'start', 'end', and 'divisor'. It returns a list of all \n    the numbers in the range ['start', 'end'] inclusive, that are divisible by 'divisor' and are prime numbers. \n    If no such number exists, the function should return an empty list.\n\n    For example:\n    magical_sequence(10, 20, 2) returns an empty list because there are no prime numbers in the range [10, 20] that are divisible by 2.\n    magical_sequence(1, 5, 3) returns [3] because 3 is the only prime number in the range [1, 5] that is divisible by 3.\n    magical_sequence(10, 15, 6) returns an empty list because there are no prime numbers in the range [10, 15] that are divisible by 6.\n    \"\"\"\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    result = []\n    for num in range(start, end + 1):\n        if num % divisor == 0 and is_prime(num):\n            result.append(num)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/66": [{"task_id": "EvoEval/66", "solution": "def prime_anagram_pairs(n):\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_anagram(num1, num2):\n        return sorted(str(num1)) == sorted(str(num2))\n    primes = [num for num in range(2, n) if is_prime(num)]\n    pairs = []\n    for i in range(len(primes)):\n        for j in range(i + 1, len(primes)):\n            if is_anagram(primes[i], primes[j]):\n                pairs.append((primes[i], primes[j]))\n    return pairs", "base_status": "fail", "plus_status": null, "base_fail_tests": [[8741]], "plus_fail_tests": []}], "EvoEval/12": [{"task_id": "EvoEval/12", "solution": "from typing import List\n\ndef teleporter_energy_signature(flux_values: List[int]) -> int:\n    max_occurrence = max(flux_values, key=flux_values.count)\n    smallest_max_occurrence = min([num for num in flux_values if num == max_occurrence])\n    sum_of_elements = sum(flux_values)\n    result = sum_of_elements * smallest_max_occurrence\n    return result", "base_status": "timeout", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}]}}