{"eval": {"HumanEval/72": [{"task_id": "HumanEval/72", "solution": "\ndef will_it_fly(q, w):\n    \"\"\"\n    Returns True if list q is palindromic and the sum of its elements is less or equal to w, False otherwise.\n    \"\"\"\n    if q == q[::-1] and sum(q) <= w:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/119": [{"task_id": "HumanEval/119", "solution": "\ndef match_parens(lst):\n    stack = []\n    for s in lst:\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if len(stack) == 0 or stack[-1] != '(':\n                    return 'No'\n                stack.pop()\n    if len(stack) == 0:\n        return 'Yes'\n    else:\n        return 'No'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[")())", "(()()("]]], "plus_fail_tests": [[[")()()()(()()))", "(("]]]}], "HumanEval/124": [{"task_id": "HumanEval/124", "solution": "\ndef valid_date(date):\n    \"\"\"\n    This function checks if a given date string is valid or not. The function returns True for a valid date and False otherwise. \n    Validity is based on the following:\n    1. The string is not empty.\n    2. Day value ranges between 1 and 31 for months 1,3,5,7,8,10,12; 1 to 30 for months 4,6,9,11; and 1 to 29 for month 2.\n    3. Month value ranges between 1 and 12.\n    4. The date format should be in 'mm-dd-yyyy'.\n    \n    Example:\n    valid_date('03-11-2000') => True\n    valid_date('15-01-2012') => False\n    valid_date('04-0-2040') => False\n    valid_date('06-04-2020') => True\n    valid_date('06/04/2020') => False\n    \"\"\"\n    if not date:\n        return False\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    (month, day, year) = parts\n    if not month.isdigit() or not day.isdigit() or (not year.isdigit()):\n        return False\n    month = int(month)\n    day = int(day)\n    year = int(year)\n    if month < 1 or month > 12:\n        return False\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["06-04-202"]]}], "HumanEval/4": [{"task_id": "HumanEval/4", "solution": "from typing import List\n\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/68": [{"task_id": "HumanEval/68", "solution": "\ndef pluck(arr):\n    \"\"\"\n    Given an array (representing a tree branch with non-negative integer nodes), \n    this function returns a list of the smallest even node value and its index. \n    If multiple nodes have the same smallest even value, the one with the smallest index is returned. \n    If no even values exist or the array is empty, an empty list is returned.\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n\n    Example 3:\n        Input: []\n        Output: []\n\n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n\n    Note:\n        * Array length: 1 <= nodes.length <= 10000\n        * Node values: 0 <= node.value\n    \"\"\"\n    smallest_even = float('inf')\n    smallest_even_index = -1\n    for (i, num) in enumerate(arr):\n        if num % 2 == 0 and num < smallest_even:\n            smallest_even = num\n            smallest_even_index = i\n    if smallest_even_index == -1:\n        return []\n    else:\n        return [smallest_even, smallest_even_index]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/47": [{"task_id": "HumanEval/47", "solution": "\n\ndef median(l: list):\n    \"\"\"\n    Calculate and return the median of list 'l'.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    sorted_list = sorted(l)\n    length = len(sorted_list)\n    if length % 2 == 0:\n        mid1 = sorted_list[length // 2]\n        mid2 = sorted_list[length // 2 - 1]\n        median_value = (mid1 + mid2) / 2\n    else:\n        median_value = sorted_list[length // 2]\n    return median_value", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/101": [{"task_id": "HumanEval/101", "solution": "\ndef words_string(s):\n    \"\"\"\n    Given a string of words divided by commas or spaces, split the string into individual words. \n    Return an array containing these words.\n    \n    Example:\n    words_string(\"Hi, my name is John\") => [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") => [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n    words = []\n    split_words = s.split(',') if ',' in s else s.split(' ')\n    for word in split_words:\n        words.append(word.strip())\n    return words", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Hi, my name is John"]], "plus_fail_tests": [[",,,,"]]}], "HumanEval/71": [{"task_id": "HumanEval/71", "solution": "\ndef triangle_area(a, b, c):\n    \"\"\"\n    Returns area of a triangle (rounded to 2 decimals) given the lengths of its \n    three sides, if they form a valid triangle. If not, returns -1. A valid triangle \n    is one where the sum of any two sides is greater than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    \"\"\"\n    if a + b > c and a + c > b and (b + c > a):\n        s = (a + b + c) / 2\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        return round(area, 2)\n    else:\n        return -1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/105": [{"task_id": "HumanEval/105", "solution": "\ndef by_length(arr):\n    \"\"\"\n    This function takes an array of integers and performs a series of operations. It first filters out numbers \n    that are not between 1 and 9 inclusive. Then, it sorts the resulting array in ascending order, reverses it, \n    and replaces each digit with its corresponding English word \n    (\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\").\n\n    Example:\n      For input array [2, 1, 1, 4, 5, 8, 2, 3], the function returns [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"].\n      For an empty array, it returns an empty array.\n      For an array with integers outside the 1-9 range, such as [1, -1 , 55], the function ignores those numbers and returns ['One'].\n    \"\"\"\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    sorted_arr = sorted(filtered_arr)\n    reversed_arr = sorted_arr[::-1]\n    word_arr = []\n    for num in reversed_arr:\n        if num == 1:\n            word_arr.append('One')\n        elif num == 2:\n            word_arr.append('Two')\n        elif num == 3:\n            word_arr.append('Three')\n        elif num == 4:\n            word_arr.append('Four')\n        elif num == 5:\n            word_arr.append('Five')\n        elif num == 6:\n            word_arr.append('Six')\n        elif num == 7:\n            word_arr.append('Seven')\n        elif num == 8:\n            word_arr.append('Eight')\n        elif num == 9:\n            word_arr.append('Nine')\n    return word_arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/104": [{"task_id": "HumanEval/104", "solution": "\ndef unique_digits(x):\n    \"\"\"Returns a sorted list of integers from the input list x that do not contain any even digits.\n\n    The list is sorted in ascending order.\n    \n    Example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    result = []\n    for num in x:\n        digits = [int(digit) for digit in str(num)]\n        if all((digit % 2 != 0 for digit in digits)):\n            result.append(num)\n    return sorted(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/75": [{"task_id": "HumanEval/75", "solution": "\ndef is_multiply_prime(a):\n    \"\"\"Check if a number is a product of 3 prime numbers.\n\n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    prime_factors = []\n    for i in range(2, a):\n        if is_prime(i) and a % i == 0:\n            prime_factors.append(i)\n    return len(prime_factors) == 3", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[8]], "plus_fail_tests": [[99]]}], "HumanEval/107": [{"task_id": "HumanEval/107", "solution": "\ndef even_odd_palindrome(n):\n    even_count = 0\n    odd_count = 0\n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/87": [{"task_id": "HumanEval/87", "solution": "\ndef get_row(lst, x):\n    \"\"\"\n    Given a jagged 2D list 'lst' and an integer 'x', this function finds all occurrences of 'x' in the list. It returns a list of tuples where each tuple represents the coordinates (row, column) of 'x' in the list. The rows start from 0 and are sorted in ascending order. If 'x' occurs multiple times in the same row, the columns are sorted in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    occurrences = []\n    for (row_idx, row) in enumerate(lst):\n        for (col_idx, val) in sorted(enumerate(row), key=lambda x: x[1], reverse=True):\n            if val == x:\n                occurrences.append((row_idx, col_idx))\n    return sorted(occurrences)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1]], "plus_fail_tests": [[[[1, 1], [1, 2, 3], [4, 5, 6, 7]], 1]]}], "HumanEval/82": [{"task_id": "HumanEval/82", "solution": "\ndef prime_length(string):\n    \"\"\"Return True if the length of the input string is a prime number, False otherwise.\n    Examples\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    length = len(string)\n    if length < 2:\n        return False\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/66": [{"task_id": "HumanEval/66", "solution": "\ndef digitSum(s):\n    \"\"\"\n    Given a string 's', the function returns the sum of the ASCII values of the uppercase characters in 's'.\n    \n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n    sum = 0\n    for char in s:\n        if char.isupper():\n            sum += ord(char)\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/93": [{"task_id": "HumanEval/93", "solution": "\ndef encode(message):\n    encoded_message = ''\n    for char in message:\n        if char.lower() in 'aeiou':\n            encoded_message += chr(ord(char) + 2)\n        else:\n            encoded_message += char.swapcase()\n    return encoded_message", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["TEST"]], "plus_fail_tests": [["abcdefghijklmnopqrstuvwxyz"]]}], "HumanEval/156": [{"task_id": "HumanEval/156", "solution": "\ndef int_to_mini_roman(number):\n    \"\"\"\n    Converts a positive integer (1 <= num <= 1000) into its lowercase roman numeral string equivalent.\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n    roman_numerals = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd', 100: 'c', 90: 'xc', 50: 'l', 40: 'xl', 10: 'x', 9: 'ix', 5: 'v', 4: 'iv', 1: 'i'}\n    result = ''\n    for (value, numeral) in roman_numerals.items():\n        while number >= value:\n            result += numeral\n            number -= value\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/125": [{"task_id": "HumanEval/125", "solution": "\ndef split_words(txt):\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for i in range(len(txt)):\n            if i % 2 == 1 and txt[i].islower():\n                count += 1\n        return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["aabc123"]]}], "HumanEval/102": [{"task_id": "HumanEval/102", "solution": "\ndef choose_num(x, y):\n    \"\"\"Returns the largest even integer within the inclusive range [x, y]. \n    If no even number exists, return -1.\n\n    Example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0:\n            largest_even = num\n    return largest_even", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/86": [{"task_id": "HumanEval/86", "solution": "\ndef anti_shuffle(s):\n    \"\"\"\n    This function accepts a string and returns a modified version where each word (separated by spaces) is replaced\n    by an alphabetically sorted version of itself. The original order of words and spaces remains unchanged.\n\n    For example:\n    anti_shuffle('Hi') -> 'Hi'\n    anti_shuffle('hello') -> 'ehllo'\n    anti_shuffle('Hello World!!!') -> 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split()\n    sorted_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(sorted_words)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["\n\n123 456\n789\n"]]}], "HumanEval/44": [{"task_id": "HumanEval/44", "solution": "def change_base(x: int, base: int):\n    \"\"\"Converts integer x to a different numerical base.\n    Returns the conversion as a string.\n    The base is less than 10.\n    \"\"\"\n    if x < 0 or base < 2 or base > 9:\n        return 'Invalid input'\n    result = ''\n    while x > 0:\n        remainder = x % base\n        result = str(remainder) + result\n        x = x // base\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0, 3]]}], "HumanEval/14": [{"task_id": "HumanEval/14", "solution": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Generates a list of prefixes for the input string in ascending length order.\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    prefixes = [string[:i + 1] for i in range(len(string))]\n    return prefixes", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/120": [{"task_id": "HumanEval/120", "solution": "\ndef maximum(arr, k):\n    \"\"\"\n    Given an array of integers 'arr' and a positive integer 'k', this function returns a sorted list of the top 'k' integers in 'arr'.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        - Array length: 1-1000.\n        - Array elements: -1000 to 1000.\n        - 'k' value: 0 to array length.\n    \"\"\"\n    sorted_arr = sorted(arr, reverse=True)\n    return sorted_arr[:k]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-3, -4, 5], 3]], "plus_fail_tests": [[[1, 2, 3, 4, 5], 3]]}], "HumanEval/100": [{"task_id": "HumanEval/100", "solution": "\ndef make_a_pile(n):\n    pile = []\n    stones = n\n    for i in range(n):\n        pile.append(stones)\n        if n % 2 == 0:\n            stones += 2\n        else:\n            stones += 2 if i % 2 == 0 else 1\n    return pile", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[15]]}], "HumanEval/88": [{"task_id": "HumanEval/88", "solution": "\ndef sort_array(array):\n    \"\"\"\n    Returns a sorted copy of the input array with non-negative integers. If the sum of the first and last elements is odd, sorts the array in ascending order. \n    If the sum is even, sorts the array in descending order. The original array remains unchanged.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n    sorted_array = sorted(array)\n    if len(sorted_array) < 2:\n        return sorted_array\n    if (sorted_array[0] + sorted_array[-1]) % 2 == 0:\n        return sorted_array[::-1]\n    else:\n        return sorted_array", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[0, 1, 11, 0, 0, 0]]]}], "HumanEval/97": [{"task_id": "HumanEval/97", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/84": [{"task_id": "HumanEval/84", "solution": "\ndef solve(N):\n    \"\"\"\n    Returns the sum of the digits in the binary representation of a positive integer N, as a binary string.\n\n    Example:\n        For N = 1000, binary sum of digits is 1, output: \"1\".\n        For N = 150, binary sum of digits is 6, output: \"110\".\n        For N = 147, binary sum of digits is 12, output: \"1100\".\n\n    Variables:\n        N : integer (0 \u2264 N \u2264 10000)\n    Output:\n        string representing binary number\n    \"\"\"\n    binary_sum = sum((int(digit) for digit in bin(N)[2:]))\n    return bin(binary_sum)[2:]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1000]], "plus_fail_tests": [[10]]}], "HumanEval/23": [{"task_id": "HumanEval/23", "solution": "\n\ndef strlen(string: str) -> int:\n    \"\"\" Calculates and returns the length of input string.\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    return len(string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/35": [{"task_id": "HumanEval/35", "solution": "\n\ndef max_element(l: list):\n    \"\"\"Finds and returns the largest number in a list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    max_num = float('-inf')\n    for num in l:\n        if num > max_num:\n            max_num = num\n    return max_num", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/13": [{"task_id": "HumanEval/13", "solution": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Returns the highest common divisor of integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    while b != 0:\n        (a, b) = (b, a % b)\n    return a", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/31": [{"task_id": "HumanEval/31", "solution": "\n\ndef is_prime(n):\n    \"\"\"\n    Checks if the input number is prime.\n    Returns true for prime numbers, false for non-prime numbers.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/157": [{"task_id": "HumanEval/157", "solution": "\ndef right_angle_triangle(a, b, c):\n    \"\"\"\n    Determine if the lengths of the three sides of a triangle form a right-angled triangle.\n    A triangle has a right angle if the square of the longest side equals the sum of the squares of the other two sides.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    \"\"\"\n    sides = [a, b, c]\n    sides.sort()\n    if sides[2] ** 2 == sides[0] ** 2 + sides[1] ** 2:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/110": [{"task_id": "HumanEval/110", "solution": "\ndef exchange(lst1, lst2):\n    if all((num % 2 == 0 for num in lst1)):\n        return 'YES'\n    odd_count_lst1 = sum((num % 2 != 0 for num in lst1))\n    odd_count_lst2 = sum((num % 2 != 0 for num in lst2))\n    if odd_count_lst1 >= odd_count_lst2:\n        return 'YES'\n    else:\n        return 'NO'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[5, 7, 3], [2, 6, 3]]], "plus_fail_tests": [[[1, 3, 5, 7], [2, 4, 6]]]}], "HumanEval/43": [{"task_id": "HumanEval/43", "solution": "\n\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    Takes a list of integers (l) as input. Returns True if a pair of distinct elements sum to zero; otherwise, returns False.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/95": [{"task_id": "HumanEval/95", "solution": "\ndef check_dict_case(dict):\n    \"\"\"\n    Returns True if all keys in the input dictionary are either all lower case or all upper case strings. \n    If the dictionary is empty or if the keys are a mix of upper and lower case strings, the function returns False.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) returns True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) returns False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) returns False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) returns False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) returns True.\n    \"\"\"\n    if len(dict) == 0:\n        return False\n    keys = list(dict.keys())\n    first_key = keys[0]\n    is_lower = first_key.islower()\n    is_upper = first_key.isupper()\n    for key in keys[1:]:\n        if is_lower and (not key.islower()) or (is_upper and (not key.isupper())):\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"Name": "John", "Age": "36", "City": "Houston"}]], "plus_fail_tests": [[{"firstName": "John", "LASTNAME": "DOE", "Age": 35, "cItY": "new york", "Income": "$50,000"}]]}], "HumanEval/98": [{"task_id": "HumanEval/98", "solution": "\ndef count_upper(s):\n    \"\"\"\n    Returns the count of uppercase vowels at even indices in string s.\n    \n    Example:\n    count_upper('aBCdEf') -> 1\n    count_upper('abcdefg') -> 0\n    count_upper('dBBE') -> 0\n    \"\"\"\n    count = 0\n    vowels = ['A', 'E', 'I', 'O', 'U']\n    for i in range(0, len(s), 2):\n        if s[i].isupper() and s[i] in vowels:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/96": [{"task_id": "HumanEval/96", "solution": "\ndef count_up_to(n):\n    \"\"\"Create a function that takes a non-negative integer n and returns a list of prime numbers less than n.\n    \n    Examples:\n    count_up_to(5) => [2,3]\n    count_up_to(11) => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n    primes = []\n    for num in range(2, n):\n        if all((num % i != 0 for i in range(2, int(num ** 0.5) + 1))):\n            primes.append(num)\n    return primes", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/81": [{"task_id": "HumanEval/81", "solution": "\ndef numerical_letter_grade(grades):\n    letter_grades = []\n    for grade in grades:\n        if grade >= 4.0:\n            letter_grades.append('A+')\n        elif grade >= 3.7:\n            letter_grades.append('A')\n        elif grade >= 3.3:\n            letter_grades.append('A-')\n        elif grade >= 3.0:\n            letter_grades.append('B+')\n        elif grade >= 2.7:\n            letter_grades.append('B')\n        elif grade >= 2.3:\n            letter_grades.append('B-')\n        elif grade >= 2.0:\n            letter_grades.append('C+')\n        elif grade >= 1.7:\n            letter_grades.append('C')\n        elif grade >= 1.3:\n            letter_grades.append('C-')\n        elif grade >= 1.0:\n            letter_grades.append('D+')\n        elif grade >= 0.7:\n            letter_grades.append('D')\n        else:\n            letter_grades.append('E')\n    return letter_grades", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[4.0, 3, 1.7, 2, 3.5]]], "plus_fail_tests": [[[3.8, 2.5, 3.9, 2.2, 1.0]]]}], "HumanEval/73": [{"task_id": "HumanEval/73", "solution": "\ndef smallest_change(arr):\n    \"\"\"\n    Calculate the minimum number of changes required to transform the input array, arr, into a palindrome. A palindrome\n    array reads the same forwards and backwards. One change involves substituting an element with any other element.\n\n    Example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    changes = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            changes += 1\n    return changes", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/108": [{"task_id": "HumanEval/108", "solution": "\ndef count_nums(arr):\n    count = 0\n    for num in arr:\n        sum_of_digits = sum((int(digit) for digit in str(num)))\n        if num < 0:\n            sum_of_digits -= int(str(num)[1])\n        if sum_of_digits > 0:\n            count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, -2, 0]]], "plus_fail_tests": [[[-1, 0, 1]]]}], "HumanEval/146": [{"task_id": "HumanEval/146", "solution": "\ndef specialFilter(nums):\n    count = 0\n    for num in nums:\n        if num > 10 and str(num)[0] % 2 != 0 and (str(num)[-1] % 2 != 0):\n            count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[15, -73, 14, -15]]], "plus_fail_tests": [[[24, -25, 9, 37, -71, -18]]]}], "HumanEval/147": [{"task_id": "HumanEval/147", "solution": "\ndef get_max_triples(n):\n    \"\"\"\n    Given a positive integer n, create an array a of length n where each element a[i] = i * i - i + 1.\n    Return the count of triples (a[i], a[j], a[k]) where i < j < k and the sum of the triples is divisible by 3.\n\n    Example :\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        Only triple whose sum is divisible by 3 is (1, 7, 13).\n    \"\"\"\n    a = [i * i - i + 1 for i in range(n)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[1]]}], "HumanEval/144": [{"task_id": "HumanEval/144", "solution": "def simplify(x, n):\n    \"\"\"Implements a function that checks if the multiplication of two fractions results in a whole number.\n    \n    Both fractions x and n are represented as strings in the format '<numerator>/<denominator>'. \n    The numerator and denominator are positive integers. \n    \n    Returns True if the multiplication results in a whole number, False otherwise.\n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n    (x_num, x_denom) = map(int, x.split('/'))\n    (n_num, n_denom) = map(int, n.split('/'))\n    result_num = x_num * n_num\n    result_denom = x_denom * n_denom\n    return result_num % result_denom == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/20": [{"task_id": "HumanEval/20", "solution": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Returns the pair of numbers from the input list that are nearest to each other, sorted in ascending order.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = None\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    return closest_pair", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/26": [{"task_id": "HumanEval/26", "solution": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" Removes duplicate integers from a given list preserving the original order.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    unique_numbers = []\n    for number in numbers:\n        if number not in unique_numbers:\n            unique_numbers.append(number)\n    return unique_numbers", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 2, 4, 3, 5]]], "plus_fail_tests": [[[1, 1, 2, 2, 3, 3, 4, 4]]]}], "HumanEval/6": [{"task_id": "HumanEval/6", "solution": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\n    Takes a string representing groups of nested parentheses separated by spaces.\n    Returns a list representing the deepest level of nesting in each group.\n    \n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depths = []\n    max_depth = 0\n    current_depth = 0\n    for char in paren_string:\n        if char == '(':\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char == ')':\n            current_depth -= 1\n        if char == ' ':\n            depths.append(max_depth)\n            max_depth = 0\n            current_depth = 0\n    depths.append(max_depth)\n    return depths", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "HumanEval/51": [{"task_id": "HumanEval/51", "solution": "\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/89": [{"task_id": "HumanEval/89", "solution": "\ndef encrypt(s):\n    encrypted = ''\n    for char in s:\n        if char.isalpha():\n            if char.isupper():\n                encrypted += chr((ord(char) - 65 + 4) % 26 + 65)\n            else:\n                encrypted += chr((ord(char) - 97 + 4) % 26 + 97)\n        else:\n            encrypted += char\n    return encrypted", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/45": [{"task_id": "HumanEval/45", "solution": "\n\ndef triangle_area(a, h):\n    \"\"\"Returns the area of a triangle with given side length 'a' and height 'h'.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    return a * h / 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/55": [{"task_id": "HumanEval/55", "solution": "\n\ndef fib(n: int):\n    \"\"\"\n    Returns the n-th Fibonacci number.\n    :param n: Index of the Fibonacci sequence.\n    :return: The n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        fib_sequence = [0, 1]\n        for i in range(2, n + 1):\n            fib_sequence.append(fib_sequence[i - 1] + fib_sequence[i - 2])\n        return fib_sequence[n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/114": [{"task_id": "HumanEval/114", "solution": "import math\n\ndef minSubArraySum(nums):\n    \"\"\"\n    Return the minimum sum of any non-empty sub-array from an array of integers.\n    \n    Example:\n    minSubArraySum([2, 3, 4, 1, 2, 4]) returns 1\n    minSubArraySum([-1, -2, -3]) returns -6\n    \"\"\"\n    if not nums:\n        return None\n    min_sum = math.inf\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        min_sum = min(min_sum, current_sum)\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[true, true, true, false, true, true]]]}], "HumanEval/77": [{"task_id": "HumanEval/77", "solution": "\ndef iscube(a):\n    \"\"\"\n    Determines if an integer is a perfect cube.\n    \n    Accepts an integer and returns True if it's a perfect cube, else False.\n    Input will always be valid.\n    \n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    \"\"\"\n    if a < 0:\n        a = -a\n    root = round(a ** (1 / 3))\n    return root ** 3 == a", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/92": [{"task_id": "HumanEval/92", "solution": "\ndef any_int(x, y, z):\n    if not all((isinstance(num, int) for num in [x, y, z])):\n        return False\n    if x == y + z or y == x + z or z == x + y:\n        return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/46": [{"task_id": "HumanEval/46", "solution": "\n\ndef fib4(n: int):\n    \"\"\"Calculates the n-th element of the Fib4 sequence, defined as:\n    fib4(n) -> 0 for n in {0, 1, 3}, 2 for n = 2, and fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) for n > 3.\n    Uses an efficient non-recursive approach.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"\n    if n == 0 or n == 1 or n == 3:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        fib = [0, 0, 2, 0]\n        for i in range(4, n + 1):\n            fib[i % 4] = fib[(i - 1) % 4] + fib[(i - 2) % 4] + fib[(i - 3) % 4] + fib[(i - 4) % 4]\n        return fib[n % 4]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/36": [{"task_id": "HumanEval/36", "solution": "\n\ndef fizz_buzz(n: int):\n    \"\"\"Returns count of digit '7' in numbers less than 'n' that are multiples of 11 or 13.\"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/16": [{"task_id": "HumanEval/16", "solution": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Returns the count of unique case-insensitive characters in a given string.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    string = string.lower()\n    unique_chars = set()\n    for char in string:\n        unique_chars.add(char)\n    return len(unique_chars)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/141": [{"task_id": "HumanEval/141", "solution": "\ndef file_name_check(file_name):\n    \"\"\"\n    Checks a file name's validity based on specific conditions, and returns 'Yes' if valid and 'No' if not valid. The conditions are as follows:\n    - No more than three digits ('0'-'9') in the file name.\n    - Exactly one dot '.' in the file name.\n    - The substring before the dot should begin with a latin alphabet letter ('a'-'z' or 'A'-'Z') and should not be empty.\n    - The substring after the dot should be 'txt', 'exe', or 'dll'.\n    \n    Example:\n    file_name_check(\"example.txt\") returns 'Yes'\n    file_name_check(\"1example.dll\") returns 'No' (file name doesn't start with a latin alphabet letter)\n    \"\"\"\n    digits_count = 0\n    dot_count = 0\n    latin_letter_found = False\n    file_extension = ''\n    for char in file_name:\n        if char.isdigit():\n            digits_count += 1\n        elif char == '.':\n            dot_count += 1\n        elif char.isalpha() and (not latin_letter_found):\n            latin_letter_found = True\n        elif dot_count == 1:\n            file_extension += char\n    if digits_count <= 3 and dot_count == 1 and latin_letter_found and (file_extension in ['txt', 'exe', 'dll']):\n        return 'Yes'\n    else:\n        return 'No'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["1example.dll"]], "plus_fail_tests": [["123.ttxt"]]}], "HumanEval/7": [{"task_id": "HumanEval/7", "solution": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"\n    Returns list of input strings containing the specified substring.\n\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    filtered_strings = []\n    for string in strings:\n        if substring in string:\n            filtered_strings.append(string)\n    return filtered_strings", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/67": [{"task_id": "HumanEval/67", "solution": "\ndef fruit_distribution(s, n):\n    \"\"\"\n    Given a string representing the number of apples and oranges, and an integer representing the total\n    number of fruits in a basket, this function returns the number of mango fruits in the basket.\n    The string format is \"{number of apples} apples and {number of oranges} oranges\". The function computes \n    the number of mango fruits by subtracting the number of apples and oranges from the total number of fruits.\n    Examples:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) -> 8\n    fruit_distribution(\"0 apples and 1 oranges\",3) -> 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 95\n    fruit_distribution(\"100 apples and 1 oranges\",120) -> 19\n    \"\"\"\n    (apples, oranges) = map(int, s.split()[0::2])\n    mangoes = n - apples - oranges\n    return mangoes", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["5 apples and 6 oranges", 19]], "plus_fail_tests": [["10 apples and 20 oranges", 50]]}], "HumanEval/60": [{"task_id": "HumanEval/60", "solution": "\n\ndef sum_to_n(n: int):\n    \"\"\"\n    Calculates the sum of integers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return sum(range(1, n + 1))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/129": [{"task_id": "HumanEval/129", "solution": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a square grid of N rows and N columns (N >= 2), each cell holds a unique integer value ranging from 1 to N*N inclusive. \n    The task is to determine the minimum path of length k. A path can start from any cell and proceed to any neighboring cell which shares an edge with the current cell. \n    The path should remain within the grid. A path is defined as minimum if the ordered list of cell values it passes through is lexicographically smaller than any other path of length k.\n    The function returns an ordered list of cell values the minimum path goes through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n\n    def dfs(grid, i, j, k, path):\n        if k == 0:\n            return path\n        if i < 0 or i >= len(grid) or j < 0 or (j >= len(grid[0])):\n            return None\n        if (i, j, k) in memo:\n            return memo[i, j, k]\n        path.append(grid[i][j])\n        min_path = None\n        for (dx, dy) in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            (x, y) = (i + dx, j + dy)\n            new_path = dfs(grid, x, y, k - 1, path)\n            if new_path is not None:\n                if min_path is None or new_path < min_path:\n                    min_path = new_path\n        path.pop()\n        memo[i, j, k] = min_path\n        return min_path\n    memo = {}\n    min_path = None\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            path = dfs(grid, i, j, k - 1, [])\n            if path is not None:\n                if min_path is None or path < min_path:\n                    min_path = path\n    return min_path", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3]], "plus_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1]]}], "HumanEval/54": [{"task_id": "HumanEval/54", "solution": "\n\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Determines whether two strings share the same unique characters, irrespective of count or order.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/29": [{"task_id": "HumanEval/29", "solution": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Return strings from input list that start with specified prefix. \"\"\"\n    return [s for s in strings if s.startswith(prefix)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/145": [{"task_id": "HumanEval/145", "solution": "\ndef order_by_points(nums):\n    \"\"\"\n    Sort a list of integers in ascending order by the sum of their digits. \n    In case of ties, maintain original order. \n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n\n    def digit_sum(num):\n        return sum((int(d) for d in str(abs(num))))\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 11, -1, -11, -12]]], "plus_fail_tests": [[[-5, -12, 9, 15]]]}], "HumanEval/59": [{"task_id": "HumanEval/59", "solution": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Finds n's largest non-prime factor. Assumes n > 1 and n is non-prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/153": [{"task_id": "HumanEval/153", "solution": "\ndef Strongest_Extension(class_name, extensions):\n    \"\"\"\n    Given a class name (string) and a list of extensions, this function loads the strongest extension to the class. \n    The strength of an extension is defined as the difference between the count of uppercase letters (CAP) and the \n    count of lowercase letters (SM) in its name. In case of a tie, the first extension in the list wins. The function \n    returns a string in the format 'ClassName.StrongestExtensionName'.\n    \n    Example:\n    Strongest_Extension('my_class', ['AA', 'Be', 'CC']) returns 'my_class.AA'\n    \"\"\"\n    strongest_extension = extensions[0]\n    strongest_strength = count_uppercase(strongest_extension) - count_lowercase(strongest_extension)\n    for extension in extensions[1:]:\n        strength = count_uppercase(extension) - count_lowercase(extension)\n        if strength > strongest_strength:\n            strongest_extension = extension\n            strongest_strength = strength\n    return f'{class_name}.{strongest_extension}'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Watashi", ["tEN", "niNE", "eIGHt8OKe"]]], "plus_fail_tests": [["Test1", ["UPPERCASE", "uppercase", "1111"]]]}], "HumanEval/78": [{"task_id": "HumanEval/78", "solution": "\ndef hex_key(num):\n    prime_hex_digits = ['2', '3', '5', '7', 'B', 'D']\n    count = 0\n    for digit in num:\n        if digit in prime_hex_digits:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/69": [{"task_id": "HumanEval/69", "solution": "\ndef search(lst):\n    \"\"\"\n    Given a non-empty list of positive integers, return the highest integer that exceeds zero, whose frequency in the list is at least equal to its value. If no such integer exists, return -1.\n    The frequency of an integer is its count in the list.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    \"\"\"\n    max_num = -1\n    for num in lst:\n        if num > 0 and lst.count(num) >= num:\n            max_num = max(max_num, num)\n    return max_num", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/122": [{"task_id": "HumanEval/122", "solution": "\ndef add_elements(arr, k):\n    \"\"\"\n    This function takes an array (arr) of integers and another integer (k). Its task is to return \n    the sum of the elements in the first k elements of arr that have at most two digits.\n\n    Example:\n        arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        should return: 24  # 21 + 3\n\n    Constraints:\n        1. The length of arr is between 1 and 100.\n        2. k is between 1 and the length of arr.\n    \"\"\"\n    count = 0\n    total = 0\n    for num in arr:\n        if num >= 10 and num <= 99:\n            total += num\n            count += 1\n        if count == k:\n            break\n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, -2, -3, 41, 57, 76, 87, 88, 99], 3]], "plus_fail_tests": [[[-4, 5, 67, 34, 56, 12, 89, 23, 45], 7]]}], "HumanEval/11": [{"task_id": "HumanEval/11", "solution": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"\n    Perform binary XOR on two binary strings a and b, and return result as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    result = ''\n    for i in range(len(a)):\n        if a[i] != b[i]:\n            result += '1'\n        else:\n            result += '0'\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/2": [{"task_id": "HumanEval/2", "solution": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\"\n    Decomposes a positive float into its integer and decimal parts,\n    then returns the decimal part.\n    \n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/5": [{"task_id": "HumanEval/5", "solution": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\" Insert 'delimiter' between each pair of elements in `numbers'.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    result = []\n    for i in range(len(numbers)):\n        if i != 0:\n            result.append(delimiter)\n        result.append(numbers[i])\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/61": [{"task_id": "HumanEval/61", "solution": "\n\ndef correct_bracketing(brackets: str):\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif bracket == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/161": [{"task_id": "HumanEval/161", "solution": "\ndef solve(s):\n    \"\"\"\n    Given a string 's', if 's' contains alphabetic characters, flip their case. If 's' contains no alphabetic characters, reverse 's'. \n    Return the modified string.\n    Examples:\n    solve(\"1234\") -> \"4321\"\n    solve(\"ab\") -> \"AB\"\n    solve(\"#a@C\") -> \"#A@c\"\n    \"\"\"\n    if any((c.isalpha() for c in s)):\n        return s.swapcase()\n    else:\n        return s[::-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/160": [{"task_id": "HumanEval/160", "solution": "\ndef do_algebra(operator, operand):\n    \"\"\"\n    Takes two lists: 'operator', containing basic algebra operations, and 'operand', containing integers. Constructs an algebraic expression using these lists and returns its evaluation.\n\n    Basic algebra operations include:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator = ['+', '*', '-']\n    operand = [2, 3, 4, 5]\n    Resulting expression: 2 + 3 * 4 - 5\n    Output: 9\n\n    Constraints:\n    - The length of 'operator' is one less than the length of 'operand'.\n    - 'operand' contains non-negative integers only.\n    - Both lists are non-empty, with 'operand' containing at least two numbers.\n    \"\"\"\n    expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += ' ' + operator[i] + ' ' + str(operand[i + 1])\n    return eval(expression)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/127": [{"task_id": "HumanEval/127", "solution": "\ndef intersection(interval1, interval2):\n    \"\"\"\n    Given two closed intervals of integers, determine whether the length of their intersection is a prime number. \n    Closed intervals include both start and end, and start is always less or equal to end. \n    If the intersection's length is prime, return \"YES\". If not or if the intervals don't intersect, return \"NO\".\n    \n    Examples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n    (start1, end1) = interval1\n    (start2, end2) = interval2\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    if intersection_start > intersection_end:\n        return 'NO'\n    intersection_length = intersection_end - intersection_start + 1\n    if intersection_length <= 1:\n        return 'NO'\n    for i in range(2, int(intersection_length ** 0.5) + 1):\n        if intersection_length % i == 0:\n            return 'NO'\n    return 'YES'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, 1], [0, 4]]], "plus_fail_tests": [[[10, 20], [15, 25]]]}], "HumanEval/27": [{"task_id": "HumanEval/27", "solution": "\n\ndef flip_case(string: str) -> str:\n    \"\"\" Switches the case of each character in the given string.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n    flipped_string = ''\n    for char in string:\n        if char.islower():\n            flipped_string += char.upper()\n        else:\n            flipped_string += char.lower()\n    return flipped_string", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/30": [{"task_id": "HumanEval/30", "solution": "\n\ndef get_positive(l: list):\n    \"\"\"Returns positive integers from input list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return [num for num in l if num > 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/151": [{"task_id": "HumanEval/151", "solution": "\ndef double_the_difference(lst):\n    \"\"\"\n    Returns the sum of squares of positive odd integers in the list. \n    Zero is included, negatives are excluded. Returns 0 for an empty list.\n\n    Example:\n    double_the_difference([1, 3, 2, 0]) == 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \"\"\"\n    sum_of_squares = 0\n    for num in lst:\n        if num > 0 and num % 2 != 0:\n            sum_of_squares += num ** 2\n    return sum_of_squares", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[0.1, 0.2, 0.3]]], "plus_fail_tests": [[[1.0, 3.5, -4.6]]]}], "HumanEval/85": [{"task_id": "HumanEval/85", "solution": "\ndef add(lst):\n    \"\"\"Sum the even numbers at odd indices in a non-empty list of integers, lst.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/113": [{"task_id": "HumanEval/113", "solution": "\ndef odd_count(lst):\n    \"\"\"Given a list of digit-only strings, this function returns a new list. Each element i of the new list is a string describing the count of odd digits in the i'th input string.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements in the string 1234567 of the input.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements in the string 3 of the input.\",\n     \"the number of odd elements in the string 11111111 of the input.\"]\n    \"\"\"\n    result = []\n    for string in lst:\n        count = 0\n        for digit in string:\n            if int(digit) % 2 != 0:\n                count += 1\n        result.append('the number of odd elements in the string {} of the input.'.format(string))\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["1234567"]]], "plus_fail_tests": [[["2468"]]]}], "HumanEval/142": [{"task_id": "HumanEval/142", "solution": "\n\n\ndef sum_squares(lst):\n    \"\"\"\n    This function receives a list of integers and modifies it based on the index of each entry. If the index is a multiple of 3, \n    the entry is squared. If the index is a multiple of 4 but not 3, the entry is cubed. Other entries remain unchanged. \n    The function returns the sum of all entries.\n    \n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n    \"\"\"\n    total = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            lst[i] = lst[i] ** 2\n        elif i % 4 == 0:\n            lst[i] = lst[i] ** 3\n        total += lst[i]\n    return total", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/134": [{"task_id": "HumanEval/134", "solution": "\ndef check_if_last_char_is_a_letter(txt):\n    if len(txt) == 0:\n        return False\n    last_char = txt[-1]\n    if last_char.isalpha():\n        if len(txt.split()[-1]) == 1:\n            return True\n        else:\n            return False\n    else:\n        return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["apple pi\ne"]]}], "HumanEval/38": [{"task_id": "HumanEval/38", "solution": "\ndef encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n    \n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/28": [{"task_id": "HumanEval/28", "solution": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\"\n    Join list of strings into one string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    return ''.join(strings)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/42": [{"task_id": "HumanEval/42", "solution": "\n\ndef incr_list(l: list):\n    \"\"\"Increments each element in a list by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return [x + 1 for x in l]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/12": [{"task_id": "HumanEval/12", "solution": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Returns the longest string from a list, or the first one in case of a tie. If list is empty, returns None.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    if not strings:\n        return None\n    longest_string = strings[0]\n    for string in strings:\n        if len(string) > len(longest_string):\n            longest_string = string\n    return longest_string", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/24": [{"task_id": "HumanEval/24", "solution": "\n\ndef largest_divisor(n: int) -> int:\n    \"\"\"Find the largest number smaller than n which divides n evenly.\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/18": [{"task_id": "HumanEval/18", "solution": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Returns the count of the occurrences of the substring in the string, including overlaps.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    if len(substring) == 0:\n        return count\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i + len(substring)] == substring:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/111": [{"task_id": "HumanEval/111", "solution": "\ndef histogram(test):\n    \"\"\"Return a dictionary with keys as letters from a given string of space separated lowercase letters and values being their counts. If multiple letters have the same maximum frequency, include them all.\n\n    Example:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n\n    \"\"\"\n    letter_counts = {}\n    letters = test.split()\n    for letter in letters:\n        if letter in letter_counts:\n            letter_counts[letter] += 1\n        else:\n            letter_counts[letter] = 1\n    max_count = max(letter_counts.values())\n    max_letters = {}\n    for (letter, count) in letter_counts.items():\n        if count == max_count:\n            max_letters[letter] = count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["a b b a"]], "plus_fail_tests": [["x y z x y z x"]]}], "HumanEval/53": [{"task_id": "HumanEval/53", "solution": "\n\ndef add(x: int, y: int):\n    \"\"\"Calculate the sum of x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/139": [{"task_id": "HumanEval/139", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/32": [{"task_id": "HumanEval/32", "solution": "\nimport math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/106": [{"task_id": "HumanEval/106", "solution": "\ndef f(n):\n    \"\"\"\n    Implement a function f, taking n as an input and returning a list of size n. For each index i, the value is i's factorial for even i or the sum of numbers up to i for odd i. i starts from 1. Factorial is the product of numbers from 1 to i. \n    Example: \n    f(5) == [1, 2, 6, 24, 15]  \n    \"\"\"\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            factorial = 1\n            for j in range(1, i + 1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            total = 0\n            for j in range(1, i + 1):\n                total += j\n            result.append(total)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/143": [{"task_id": "HumanEval/143", "solution": "\ndef words_in_sentence(sentence):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/121": [{"task_id": "HumanEval/121", "solution": "\ndef solution(lst):\n    \"\"\"\n    Calculates the sum of odd numbers at even-indexed positions in a given integer list.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    sum_odd = 0\n    for i in range(len(lst)):\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            sum_odd += lst[i]\n    return sum_odd", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/91": [{"task_id": "HumanEval/91", "solution": "\ndef is_bored(S):\n    \"\"\"\n    Given a string of sentences, this function counts the number of sentences starting with \"I\". \n    Sentences are separated by '.', '?' or '!'.\n    \n    Example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n    sentences = S.split('. ') + S.split('? ') + S.split('! ')\n    count = 0\n    for sentence in sentences:\n        if sentence.startswith('I'):\n            count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Is the sky blue?"]], "plus_fail_tests": [["I am very happy today. I love spending time with my friends."]]}], "HumanEval/49": [{"task_id": "HumanEval/49", "solution": "\n\ndef modp(n: int, p: int):\n    \"\"\"\n    Computes 2^n modulo p.\n    \n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/9": [{"task_id": "HumanEval/9", "solution": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" Generates a list with the maximum element found till that index in the given list of integers.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    max_numbers = []\n    current_max = float('-inf')\n    for num in numbers:\n        current_max = max(current_max, num)\n        max_numbers.append(current_max)\n    return max_numbers", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/136": [{"task_id": "HumanEval/136", "solution": "\ndef largest_smallest_integers(lst):\n    negatives = [num for num in lst if num < 0]\n    positives = [num for num in lst if num > 0]\n    max_negative = None\n    min_positive = None\n    if negatives:\n        max_negative = max(negatives)\n    if positives:\n        min_positive = min(positives)\n    return (max_negative, min_positive)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/21": [{"task_id": "HumanEval/21", "solution": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Transforms a list of numbers by rescaling values between 0 and 1 \n    where smallest becomes 0 and largest becomes 1.\n\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_val = min(numbers)\n    max_val = max(numbers)\n    rescaled_numbers = [(x - min_val) / (max_val - min_val) for x in numbers]\n    return rescaled_numbers", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/0": [{"task_id": "HumanEval/0", "solution": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Determines if any two elements in the provided list of numbers are closer than the specified threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/80": [{"task_id": "HumanEval/80", "solution": "\ndef is_happy(s):\n    if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/22": [{"task_id": "HumanEval/22", "solution": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Returns a list of integers from the provided list.\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    return [value for value in values if isinstance(value, int)]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[true, false, null, 0, -10, "test", [], {}, 3.14]]]}], "HumanEval/140": [{"task_id": "HumanEval/140", "solution": "\ndef fix_spaces(text):\n    \"\"\"\n    Replaces all spaces in the input string 'text' with underscores. If 'text' contains \n    more than two consecutive spaces, these are replaced with a single dash. \n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"\n    text = text.replace(' ', '_')\n    text = text.replace('__', '-')\n    text = text.replace('_', ' ', 1)\n    return text", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Mudasir Hanif "]], "plus_fail_tests": [["Hello,   world!"]]}], "HumanEval/40": [{"task_id": "HumanEval/40", "solution": "\n\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    Check if there are three distinct elements in the given list of integers that sum to zero. If yes, return True, otherwise return False.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n    if len(l) < 3:\n        return False\n    for i in range(len(l) - 2):\n        for j in range(i + 1, len(l) - 1):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/58": [{"task_id": "HumanEval/58", "solution": "\n\ndef common(l1: list, l2: list):\n    \"\"\"Returns sorted list of unique elements common to both input lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    common_elements = list(set(l1) & set(l2))\n    return sorted(common_elements)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/41": [{"task_id": "HumanEval/41", "solution": "\n\ndef car_race_collision(n: int) -> int:\n    \"\"\"\n    On an infinitely long straight road, n cars are driving from left to right, while another n cars are driving from right to left at the same speed. A collision occurs when a car moving in one direction hits a car moving in the opposite direction. Despite collisions, all cars keep moving in their original direction. The function returns the total number of such collisions.\n    \"\"\"\n    return n * (n - 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[5]]}], "HumanEval/109": [{"task_id": "HumanEval/109", "solution": "\ndef move_one_ball(arr):\n    \"\"\"Determines if it's possible to sort an array of N unique integers in non-decreasing order \n    by repeatedly performing a right shift operation. A right shift operation refers to moving \n    all elements one position to the right, with the last element moving to the first position. \n\n    Returns True if possible, False if not. An empty array is considered sorted and will return True.\n\n    For Example:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Explanation: 2 right shift operations can sort the array in non-decreasing order.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Explanation: No amount of right shift operations can sort the array in non-decreasing order.                \n    \"\"\"\n    if len(arr) == 0:\n        return True\n    sorted_arr = sorted(arr)\n    for i in range(len(arr)):\n        shifted_arr = arr[-1:] + arr[:-1]\n        if shifted_arr == sorted_arr:\n            return True\n        arr = shifted_arr\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/33": [{"task_id": "HumanEval/33", "solution": "\n\ndef sort_third(l: list):\n    \"\"\"Takes a list 'l' and returns a new list with l's elements at indices divisible by three sorted, while other elements remain the same.\n\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    divisible_by_three = [x for (i, x) in enumerate(l) if (i + 1) % 3 == 0]\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    result = [x if (i + 1) % 3 != 0 else sorted_divisible_by_three.pop(0) for (i, x) in enumerate(l)]\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]]], "plus_fail_tests": [[[9, 12, 15, 6, 3, 8, 10, 23, 7]]]}], "HumanEval/52": [{"task_id": "HumanEval/52", "solution": "\n\ndef below_threshold(l: list, t: int):\n    \"\"\"Checks if all elements in list l are less than threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for element in l:\n        if element >= t:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/123": [{"task_id": "HumanEval/123", "solution": "\ndef get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, this function returns a sorted list of the odd numbers in the Collatz sequence.\n    \n    Collatz sequence starts with a positive integer n. Each subsequent term is derived from the previous term: \n    - If the previous term is even, the next term is half of the previous term.\n    - If the previous term is odd, the next term is 3 times the previous term plus 1.\n    The sequence always concludes at 1, regardless of the initial n.\n\n    Note: \n        1. Collatz(1) returns [1].\n        2. The returned list is sorted in ascending order.\n\n    Example:\n    get_odd_collatz(5) returns [1, 5] # The Collatz sequence for 5 is [5, 16, 8, 4, 2, 1], hence the odd numbers are 1 and 5.\n    \"\"\"\n    collatz_sequence = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        collatz_sequence.append(n)\n    odd_numbers = [num for num in collatz_sequence if num % 2 != 0]\n    return sorted(odd_numbers)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/3": [{"task_id": "HumanEval/3", "solution": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Determine if the account balance drops below zero at any point given a list of deposit and withdrawal operations. \n    The function should return True if it does, otherwise return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/137": [{"task_id": "HumanEval/137", "solution": "\ndef compare_one(a, b):\n    \"\"\"\n    Returns the greater of two inputs, each of which may be an integer, float, or string representing a real number. \n    If a number is expressed as a string, it could contain either '.' or ',' as the decimal point. \n    If inputs are equal, the function returns None.\n\n    compare_one(1, 2.5) \u279e 2.5\n    compare_one(1, \"2,3\") \u279e \"2,3\"\n    compare_one(\"5,1\", \"6\") \u279e \"6\"\n    compare_one(\"1\", 1) \u279e None\n    \"\"\"\n    if isinstance(a, str) and isinstance(b, str):\n        a = a.replace(',', '.')\n        b = b.replace(',', '.')\n    elif isinstance(a, str):\n        a = a.replace(',', '.')\n        a = float(a)\n    elif isinstance(b, str):\n        b = b.replace(',', '.')\n        b = float(b)\n    if a == b:\n        return None\n    elif a > b:\n        return a\n    else:\n        return b", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, "2,3"]], "plus_fail_tests": [["-4,1", "-4.0"]]}], "HumanEval/1": [{"task_id": "HumanEval/1", "solution": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    Takes a string of multiple balanced and non-nested parentheses groups. Returns a list containing each group as a separate string. Spaces within the string are ignored.\n\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    result = []\n    stack = []\n    current_group = ''\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n        current_group += char\n        if not stack:\n            result.append(current_group.strip())\n            current_group = ''\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["(()()) ((())) () ((())()())"]], "plus_fail_tests": [["((() ((()()((((((  )))))))()()))) (()(()))()(()())"]]}], "HumanEval/128": [{"task_id": "HumanEval/128", "solution": "\ndef prod_signs(arr):\n    if len(arr) == 0:\n        return None\n    product = 1\n    sum_abs = 0\n    for num in arr:\n        product *= 1 if num > 0 else -1 if num < 0 else 0\n        sum_abs += abs(num)\n    return product * sum_abs", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/115": [{"task_id": "HumanEval/115", "solution": "\ndef max_fill(grid, capacity):\n    import math\n    num_lowerings = 0\n    for row in grid:\n        for well in row:\n            water_units = sum(well)\n            well_lowerings = math.ceil(water_units / capacity)\n            num_lowerings += well_lowerings\n    return num_lowerings", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1]], "plus_fail_tests": [[[[1, 0, 0, 1], [0, 1, 1, 1], [0, 0, 0, 0], [1, 0, 1, 1]], 2]]}], "HumanEval/62": [{"task_id": "HumanEval/62", "solution": "\n\ndef derivative(xs: list):\n    \"\"\" \n    Returns the derivative of a polynomial represented by list 'xs', where each element corresponds to a coefficient. \n    The list index represents the power of x (i.e., xs[i]*x^i).\n    \n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    derivative_xs = []\n    for i in range(1, len(xs)):\n        derivative_xs.append(i * xs[i])\n    return derivative_xs", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/131": [{"task_id": "HumanEval/131", "solution": "\ndef digits(n):\n    \"\"\"Returns the product of the odd digits in a positive integer n, or 0 if all digits are even.\n\n    Examples:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n    product = 1\n    has_odd_digit = False\n    while n > 0:\n        digit = n % 10\n        if digit % 2 != 0:\n            product *= digit\n            has_odd_digit = True\n        n //= 10\n    if has_odd_digit:\n        return product\n    else:\n        return 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/112": [{"task_id": "HumanEval/112", "solution": "\ndef reverse_delete(s, c):\n    result = ''.join([char for char in s if char not in c])\n    is_palindrome = result == result[::-1]\n    return (result, is_palindrome)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/148": [{"task_id": "HumanEval/148", "solution": "\ndef bf(planet1, planet2):\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    if index1 < index2:\n        return tuple(planets[index1 + 1:index2])\n    else:\n        return tuple(planets[index2 + 1:index1][::-1])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Neptune", "Venus"]], "plus_fail_tests": [["Neptune", "Mercury"]]}], "HumanEval/65": [{"task_id": "HumanEval/65", "solution": "\ndef circular_shift(x, shift):\n    \"\"\"Performs a circular right shift on the digits of x as per shift value and returns the result in string format.\n    Returns reversed digits if shift exceeds number of digits.\n\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n    x_str = str(x)\n    num_digits = len(x_str)\n    shift = shift % num_digits\n    if shift == 0:\n        return x_str\n    shifted_str = x_str[-shift:] + x_str[:-shift]\n    return shifted_str", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[97, 8]], "plus_fail_tests": [[1234, 6]]}], "HumanEval/57": [{"task_id": "HumanEval/57", "solution": "\n\ndef monotonic(l: list):\n    \"\"\"Checks if list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    increasing = all((l[i] <= l[i + 1] for i in range(len(l) - 1)))\n    decreasing = all((l[i] >= l[i + 1] for i in range(len(l) - 1)))\n    return increasing or decreasing", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/118": [{"task_id": "HumanEval/118", "solution": "\ndef get_closest_vowel(word):\n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    for i in range(1, len(word) - 1):\n        if word[i] in vowels and word[i - 1] in consonants and (word[i + 1] in consonants):\n            return word[i]\n    return ''", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["yogurt"]], "plus_fail_tests": [["himute"]]}], "HumanEval/116": [{"task_id": "HumanEval/116", "solution": "\ndef sort_array(arr):\n    \"\"\"\n    Sort an array of non-negative integers based on the number of ones in their binary representations in ascending order.\n    If two integers have the same number of ones, sort them based on their decimal values.\n\n    Example:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"\n\n    def count_ones(num):\n        return bin(num).count('1')\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/79": [{"task_id": "HumanEval/79", "solution": "\ndef decimal_to_binary(decimal):\n    binary = bin(decimal)[2:]\n    return 'db' + binary + 'db'", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/34": [{"task_id": "HumanEval/34", "solution": "\n\ndef unique(l: list):\n    \"\"\"Sorts and removes duplicates from a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/162": [{"task_id": "HumanEval/162", "solution": "\ndef string_to_md5(text):\n    \"\"\"\n    Converts a string 'text' to its md5 hash. Returns None for an empty string.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    if text == '':\n        return None\n    else:\n        md5_hash = hashlib.md5(text.encode()).hexdigest()\n        return md5_hash", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Hello world"]], "plus_fail_tests": [["5873hajsdklh"]]}], "HumanEval/50": [{"task_id": "HumanEval/50", "solution": "\ndef encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/64": [{"task_id": "HumanEval/64", "solution": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"This function, vowels_count, accepts a string s, representing a word and returns the number of vowels in it. \n    The vowels are 'a', 'e', 'i', 'o', 'u' and 'y' (only if it's at the end of the word).\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    count = 0\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    for char in s.lower():\n        if char in vowels:\n            count += 1\n    if s[-1].lower() == 'y':\n        count += 1\n    return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "HumanEval/158": [{"task_id": "HumanEval/158", "solution": "\ndef find_max(words):\n    max_unique_count = 0\n    max_unique_word = ''\n    for word in words:\n        unique_count = len(set(word))\n        if unique_count > max_unique_count:\n            max_unique_count = unique_count\n            max_unique_word = word\n        elif unique_count == max_unique_count:\n            max_unique_word = min(max_unique_word, word)\n    return max_unique_word", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/63": [{"task_id": "HumanEval/63", "solution": "\n\ndef fibfib(n: int):\n    \"\"\"This function calculates the n-th element of the FibFib sequence.\n    The FibFib sequence is defined as:\n    fibfib(0) = 0,\n    fibfib(1) = 0,\n    fibfib(2) = 1,\n    fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    It returns the n-th element of this sequence.\n    \n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        fibfib_n_minus_1 = 1\n        fibfib_n_minus_2 = 0\n        fibfib_n_minus_3 = 0\n        fibfib_n = 0\n        for i in range(3, n + 1):\n            fibfib_n = fibfib_n_minus_1 + fibfib_n_minus_2 + fibfib_n_minus_3\n            fibfib_n_minus_3 = fibfib_n_minus_2\n            fibfib_n_minus_2 = fibfib_n_minus_1\n            fibfib_n_minus_1 = fibfib_n\n        return fibfib_n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/83": [{"task_id": "HumanEval/83", "solution": "\ndef starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of n-digit positive integers that either begin or conclude with 1.\n    \"\"\"\n    count = 0\n    if n == 1:\n        count = 1\n    elif n > 1:\n        count = 9 * 10 ** (n - 2) + starts_one_ends(n - 1)\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[6]]}], "HumanEval/19": [{"task_id": "HumanEval/19", "solution": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"\n    Input: A string of space-separated numerals from 'zero' to 'nine'.\n    Output: Returns the input string sorted in ascending order.\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n    numeral_to_number = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    numerals = numbers.split()\n    numbers = [numeral_to_number[numeral] for numeral in numerals]\n    numbers.sort()\n    sorted_numerals = [numeral for number in numbers for (numeral, num) in numeral_to_number.items() if num == number]\n    sorted_numbers = ' '.join(sorted_numerals)\n    return sorted_numbers", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/17": [{"task_id": "HumanEval/17", "solution": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Transforms a string of musical notes (represented in a special ASCII format) into a list of integers. Each integer represents the duration of a note.\n\n    Legend:\n    'o' - whole note (4 beats)\n    'o|' - half note (2 beats)\n    '.|' - quarter note (1 beat)\n\n    Example: \n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    durations = {'o': 4, 'o|': 2, '.|': 1}\n    notes = music_string.split()\n    return [durations[note] for note in notes]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/155": [{"task_id": "HumanEval/155", "solution": "\ndef even_odd_count(num):\n    \"\"\"Returns a tuple with counts of even and odd digits in a given integer.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    num = abs(num)\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num = num // 10\n    return (even_count, odd_count)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[0]], "plus_fail_tests": [[0]]}], "HumanEval/74": [{"task_id": "HumanEval/74", "solution": "\ndef total_match(lst1, lst2):\n    \"\"\"\n    A function that takes two lists of strings as input. It returns the list with the fewer total characters across all its strings. \n    If both lists have the same total number of characters, it returns the first list.\n\n    Examples\n    total_match([], []) -> []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) -> ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) -> ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) -> ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) -> ['4']\n    \"\"\"\n    total_chars_lst1 = sum((len(s) for s in lst1))\n    total_chars_lst2 = sum((len(s) for s in lst2))\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/8": [{"task_id": "HumanEval/8", "solution": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Returns a tuple with the sum and product of a list of integers. For an empty list, sum is 0 and product is 1. \n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    if not numbers:\n        return (0, 1)\n    sum_result = sum(numbers)\n    product_result = 1\n    for num in numbers:\n        product_result *= num\n    return (sum_result, product_result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/163": [{"task_id": "HumanEval/163", "solution": "\ndef generate_integers(a, b):\n    \"\"\"\n    Returns the even numbers between two positive integers a and b in ascending order, irrespective of the order of a and b. If there are no even numbers, an empty list is returned.\n    \n    Example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n    start = min(a, b)\n    end = max(a, b)\n    even_numbers = []\n    for num in range(start, end + 1):\n        if num % 2 == 0:\n            even_numbers.append(num)\n    return even_numbers", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2, 10]], "plus_fail_tests": [[6, 12]]}], "HumanEval/133": [{"task_id": "HumanEval/133", "solution": "\n\ndef sum_squares(lst):\n    \"\"\"Return the sum of squares of each element in the list, after rounding each element to the nearest integer towards positive infinity.\n    \n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6\n    \"\"\"\n    sum_of_squares = 0\n    for num in lst:\n        rounded_num = int(num + 0.5)\n        sum_of_squares += rounded_num ** 2\n    return sum_of_squares", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1.4, 4.2, 0]]], "plus_fail_tests": [[[-3, 4, 5, 6, 7]]]}], "HumanEval/149": [{"task_id": "HumanEval/149", "solution": "\ndef sorted_list_sum(lst):\n    \"\"\"This function takes a list of strings, removes strings with odd lengths,\n    and returns the sorted list. Sorting is done primarily according to string length \n    in ascending order, and secondarily alphabetically for strings of the same length. \n    The list may contain duplicates.\n\n    Example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    lst = [s for s in lst if len(s) % 2 == 0]\n    lst.sort(key=lambda s: (len(s), s))\n    return lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/154": [{"task_id": "HumanEval/154", "solution": "\ndef cycpattern_check(a, b):\n    \"\"\"Check if any rotation of the second word is a substring of the first word. Return True if so, else return False.\n\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n    if len(a) != len(b):\n        return False\n    for i in range(len(a)):\n        if a[i:] + a[:i] == b:\n            return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["yello", "ell"]], "plus_fail_tests": [["abcdefg", "cde"]]}], "HumanEval/135": [{"task_id": "HumanEval/135", "solution": "\ndef can_arrange(arr):\n    \"\"\"Define a function that returns the highest index of a number in the array that is not equal to or greater than its preceding number. Return -1 if no such number exists. The input array does not have duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n    for i in range(len(arr) - 1, 0, -1):\n        if arr[i] < arr[i - 1]:\n            return i\n    return -1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/37": [{"task_id": "HumanEval/37", "solution": "\n\ndef sort_even(l: list):\n    \"\"\"Takes a list l and returns a new list where odd-indexed elements are unchanged, while even-indexed elements are sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indexed = sorted(l[::2])\n    sorted_list = []\n    for (i, num) in enumerate(l):\n        if i % 2 == 0:\n            sorted_list.append(even_indexed.pop(0))\n        else:\n            sorted_list.append(num)\n    return sorted_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/48": [{"task_id": "HumanEval/48", "solution": "\n\ndef is_palindrome(text: str):\n    \"\"\"\n    Returns True if input string is a palindrome, False otherwise\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n    return text == text[::-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/130": [{"task_id": "HumanEval/130", "solution": "\ndef tri(n):\n    \"\"\"\n    This function returns the first n+1 numbers of the Tribonacci sequence. \n    The Tribonacci sequence is defined as:\n    - tri(1) = 3,\n    - tri(n) = 1 + n / 2, if n is even,\n    - tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    The function's input is a non-negative integer n.\n     \n    Example:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"\n    sequence = [3]\n    if n == 0:\n        return sequence\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i // 2)\n        else:\n            sequence.append(sequence[i - 1] + sequence[i - 2] + sequence[i + 1])\n    return sequence", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[2]]}], "HumanEval/152": [{"task_id": "HumanEval/152", "solution": "\ndef compare(game, guess):\n    \"\"\"Determine the accuracy of an individual's predictions for a series of match results. \n    Provided are two lists of equal length, the 'game' containing actual scores and 'guess' containing predictions. \n    Return a list where each element is the absolute difference between the corresponding game score and guess. \n    If a guess is accurate, the difference is 0.\n    \n    example:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    \"\"\"\n    differences = []\n    for i in range(len(game)):\n        differences.append(abs(game[i] - guess[i]))\n    return differences", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/70": [{"task_id": "HumanEval/70", "solution": "\ndef strange_sort_list(lst):\n    \"\"\"\n    Sorts a list of integers in a specific order: start with the smallest value, \n    then the largest of the remaining, then smallest, and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    \"\"\"\n    sorted_lst = []\n    lst.sort()\n    while lst:\n        sorted_lst.append(lst.pop(0))\n        if lst:\n            sorted_lst.append(lst.pop())\n    return sorted_lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/99": [{"task_id": "HumanEval/99", "solution": "\ndef closest_integer(value):\n    \"\"\"\n    This function takes a string of a number as an input and returns the nearest \n    integer to the provided number. If the number falls midway between two integers, \n    the function rounds away from zero.\n\n    Examples:\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n    >>> closest_integer(\"14.5\")\n    15\n    >>> closest_integer(\"-14.5\")\n    -15\n    \"\"\"\n    number = float(value)\n    rounded_number = int(number + (0.5 if number > 0 else -0.5))\n    return rounded_number", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/132": [{"task_id": "HumanEval/132", "solution": "\ndef is_nested(string):\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if len(stack) == 0 or stack[-1] != '[':\n                return False\n            stack.pop()\n    return len(stack) == 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["[][]"]], "plus_fail_tests": [["[[]]]"]]}], "HumanEval/10": [{"task_id": "HumanEval/10", "solution": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Creates the shortest possible palindrome starting with the given string.\n    \n    The algorithm identifies the longest suffix palindrome in the substring and reverses any preceding text to append at the end of the string.\n    \n    Examples: \n    make_palindrome(''): returns ''\n    make_palindrome('cat'): returns 'catac'\n    make_palindrome('cata'): returns 'catac'\n    \"\"\"\n    if not string:\n        return ''\n    for i in range(len(string), 0, -1):\n        if is_palindrome(string[:i]):\n            return string + string[:i][::-1]\n    return string + string[1:][::-1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["x"]], "plus_fail_tests": [["race"]]}], "HumanEval/159": [{"task_id": "HumanEval/159", "solution": "\ndef eat(number, need, remaining):\n    \"\"\"\n    This function represents a hungry rabbit eating carrots. It takes in the number of carrots already eaten,\n    the number of additional carrots needed, and the number of carrots remaining. The function returns an array\n    with two elements: the total number of carrots eaten and the remaining carrots after eating. If there are not \n    enough remaining carrots to meet the need, the rabbit eats all the remaining carrots, but still requires more.\n    \n    Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Args:\n    @number (int): Number of carrots already eaten by the rabbit (0 <= number <= 1000).\n    @need (int): Additional number of carrots needed by the rabbit (0 <= need <= 1000).\n    @remaining (int): Number of carrots still available (0 <= remaining <= 1000).\n    \"\"\"\n    total_eaten = number + min(need, remaining)\n    remaining_carrots = max(0, remaining - need)\n    return [total_eaten, remaining_carrots]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/56": [{"task_id": "HumanEval/56", "solution": "\n\ndef correct_bracketing(brackets: str):\n    \"\"\"\n    Checks if each '<' has a matching '>' in the string.\n    Assumes string consists only of '<' and '>' characters.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == '<':\n            stack.append(bracket)\n        elif bracket == '>':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/126": [{"task_id": "HumanEval/126", "solution": "\ndef is_sorted(lst):\n    \"\"\"\n    Determine if a list of positive integers is sorted in ascending order. \n    Returns False if there are any duplicates beyond a pair of the same number.\n\n    Examples\n    is_sorted([5]) \u279e True\n    is_sorted([1, 2, 3, 4, 5]) \u279e True\n    is_sorted([1, 3, 2, 4, 5]) \u279e False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u279e True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279e True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279e False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u279e True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u279e False\n    \"\"\"\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n        if i < len(lst) - 2 and lst[i] == lst[i + 1] and (lst[i + 1] == lst[i + 2]):\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/117": [{"task_id": "HumanEval/117", "solution": "\ndef select_words(s, n):\n    \"\"\"Return a list of words from string s that contain exactly n consonants, in their original order. \n    If string s is empty, return an empty list. \n    It is assumed that the input string only contains letters and spaces. \n    Examples:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n    words = s.split()\n    result = []\n    for word in words:\n        consonant_count = 0\n        for char in word:\n            if char.lower() not in ['a', 'e', 'i', 'o', 'u'] and char.isalpha():\n                consonant_count += 1\n        if consonant_count == n:\n            result.append(word)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/150": [{"task_id": "HumanEval/150", "solution": "\ndef x_or_y(n, x, y):\n    \"\"\"Returns x if n is prime, otherwise returns y.\n\n    Examples:\n    x_or_y(7, 34, 12) returns 34\n    x_or_y(15, 8, 5) returns 5\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"Checks if a number is prime.\"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    if is_prime(n):\n        return x\n    else:\n        return y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/76": [{"task_id": "HumanEval/76", "solution": "\ndef is_simple_power(x, n):\n    \"\"\"Returns true if x is an integer power of n, false otherwise.\n    \n    A number x is an integer power of n if there exists some integer i such that n**i = x\n    \n    Examples:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n    \"\"\"\n    if x == 1:\n        return True\n    elif n == 1:\n        return False\n    else:\n        i = 1\n        while n ** i <= x:\n            if n ** i == x:\n                return True\n            i += 1\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/90": [{"task_id": "HumanEval/90", "solution": "\ndef next_smallest(lst):\n    \"\"\"\n    Given a list of integers, return the second smallest element. If no such element exists, return None.\n    \n    Examples: \n    next_smallest([1, 2, 3, 4, 5]) -> 2\n    next_smallest([5, 1, 4, 3, 2]) -> 2\n    next_smallest([]) -> None\n    next_smallest([1, 1]) -> None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    smallest = float('inf')\n    second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n    if second_smallest == float('inf'):\n        return None\n    else:\n        return second_smallest", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/25": [{"task_id": "HumanEval/25", "solution": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Returns the list of prime factors of 'n', sorted from smallest to largest. \n    The frequency of each factor matches its occurrence in the factorization of 'n'.\n    The product of all factors equals the input number.\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/15": [{"task_id": "HumanEval/15", "solution": "\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Returns a string of numbers from 0 to n inclusive, separated by spaces.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n    return ' '.join((str(i) for i in range(n + 1)))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/103": [{"task_id": "HumanEval/103", "solution": "\ndef rounded_avg(n, m):\n    if n > m:\n        return -1\n    total = 0\n    count = 0\n    for i in range(n, m + 1):\n        total += i\n        count += 1\n    avg = round(total / count)\n    binary = bin(avg)\n    return binary", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/39": [{"task_id": "HumanEval/39", "solution": "\n\ndef prime_fib(n: int):\n    \"\"\"\n    Returns the n-th Fibonacci number which is also a prime number.\n    \n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    fib_sequence = [0, 1]\n    while len(fib_sequence) < n:\n        next_fib = fib_sequence[-1] + fib_sequence[-2]\n        if is_prime(next_fib):\n            fib_sequence.append(next_fib)\n    return fib_sequence[n - 1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1]], "plus_fail_tests": [[11]]}], "HumanEval/94": [{"task_id": "HumanEval/94", "solution": "\n\ndef skjkasdkd(lst):\n    \"\"\"Given a list of integers, this function finds the largest prime number in the list and returns the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    prime_numbers = [num for num in lst if is_prime(num)]\n    if prime_numbers:\n        largest_prime = max(prime_numbers)\n        return sum((int(digit) for digit in str(largest_prime)))\n    else:\n        return 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/138": [{"task_id": "HumanEval/138", "solution": "\ndef is_equal_to_sum_even(n):\n    \"\"\"Check if the input number n can be expressed as the sum of exactly 4 positive even numbers.\n    Example\n    is_equal_to_sum_even(4) == False\n    is_equal_to_sum_even(6) == False\n    is_equal_to_sum_even(8) == True\n    \"\"\"\n    count = 0\n    for i in range(2, n, 2):\n        for j in range(2, n, 2):\n            for k in range(2, n, 2):\n                for l in range(2, n, 2):\n                    if i + j + k + l == n:\n                        count += 1\n    return count > 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}]}}