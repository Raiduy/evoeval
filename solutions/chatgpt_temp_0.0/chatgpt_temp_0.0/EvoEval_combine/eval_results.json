{"eval": {"EvoEval/78": [{"task_id": "EvoEval/78", "solution": "\ndef solve_and_count(s):\n    vowels = ['A', 'E', 'I', 'O', 'U']\n    result = ''\n    count = 0\n    for i in range(len(s)):\n        if s[i].isalpha():\n            if s[i].islower():\n                result += s[i].upper()\n            else:\n                result += s[i].lower()\n        else:\n            result += s[i]\n    if not any((char.isalpha() for char in result)):\n        result = result[::-1]\n    for i in range(1, len(result), 2):\n        if result[i].isupper() and result[i] in vowels:\n            count += 1\n    return (result, count)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["abcdefg"]], "plus_fail_tests": []}], "EvoEval/35": [{"task_id": "EvoEval/35", "solution": "def check_dict_happiness(dict):\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    first_key = keys[0]\n    is_lower = first_key.islower()\n    is_upper = first_key.isupper()\n    if not all((key.islower() == is_lower or key.isupper() == is_upper for key in keys)):\n        return False\n\n    def is_happy_string(s):\n        if len(s) < 3:\n            return False\n        for i in range(len(s) - 2):\n            if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n                return False\n        return True\n    return all((is_happy_string(key) for key in keys))", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"aab": "apple", "8": "banana", "a": "apple"}]], "plus_fail_tests": []}], "EvoEval/88": [{"task_id": "EvoEval/88", "solution": "\ndef process_and_sort_string(s):\n    words = s.replace(',', ' ').split()\n    words = [word for word in words if len(word) % 2 == 0]\n    words.sort(key=lambda x: (len(x), x))\n    return words", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/59": [{"task_id": "EvoEval/59", "solution": "def odd_count_base_change(lst, base):\n\n    def count_odd_digits(num, base):\n        count = 0\n        while num > 0:\n            digit = num % base\n            if digit % 2 != 0:\n                count += 1\n            num //= base\n        return count\n    result = []\n    for string in lst:\n        odd_count = count_odd_digits(int(string), base)\n        result.append('the number of odd elements {}n the str{}ng {} of the {}nput.'.format(odd_count, odd_count, odd_count, odd_count))\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["3", "11111111"], 3]], "plus_fail_tests": []}], "EvoEval/16": [{"task_id": "EvoEval/16", "solution": "def get_music_notes(word: str, music_string: str):\n    vowels = 'aeiouAEIOU'\n    vowels_indices = [i for (i, char) in enumerate(word) if char in vowels]\n    if len(vowels_indices) < 2:\n        return []\n    closest_vowel_index = vowels_indices[-2]\n    beats = []\n    for i in range(closest_vowel_index, len(word)):\n        if word[i] in vowels:\n            break\n        if word[i] != ' ':\n            if music_string[i] == 'o':\n                beats.append(4)\n            elif music_string[i] == '|':\n                beats.append(2)\n            elif music_string[i] == '.':\n                beats.append(1)\n    return beats", "base_status": "fail", "plus_status": null, "base_fail_tests": [["FULL", "o o| .| o| o| .| .| .| .| o o"]], "plus_fail_tests": []}], "EvoEval/81": [{"task_id": "EvoEval/81", "solution": "\nfrom typing import List\n\ndef mean_absolute_deviation_fibfib(n: int) -> float:\n    \"\"\"\n    Given an integer n, calculate the mean absolute deviation of the first n elements of a modified Fibonacci sequence,\n    called the FibFib sequence. The FibFib sequence is defined as follows:\n    \n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    \n    Then, compute the Mean Absolute Deviation (MAD) of these n elements. The MAD is the average absolute difference\n    between each element and the mean of this set:\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation_fibfib(1)\n    0.0\n    >>> mean_absolute_deviation_fibfib(5)\n    0.64\n    >>> mean_absolute_deviation_fibfib(8)\n    3.375\n    \"\"\"\n\n    def fibfib(n: int) -> int:\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 0\n        elif n == 2:\n            return 1\n        else:\n            return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n    sequence = [fibfib(i) for i in range(n)]\n    mean = sum(sequence) / n\n    mad = sum((abs(x - mean) for x in sequence)) / n\n    return round(mad, 2)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[8]], "plus_fail_tests": []}], "EvoEval/40": [{"task_id": "EvoEval/40", "solution": "\ndef largest_prime_odd_ends(nums):\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def get_first_digit(n):\n        return int(str(n)[0])\n\n    def get_last_digit(n):\n        return int(str(n)[-1])\n    prime_factors = []\n    for num in nums:\n        if num > 10 and get_first_digit(num) % 2 != 0 and (get_last_digit(num) % 2 != 0):\n            for i in range(2, num + 1):\n                if num % i == 0 and is_prime(i):\n                    prime_factors.append(i)\n    if prime_factors:\n        return max(prime_factors)\n    else:\n        return None", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[51, -73, 14, -15]]], "plus_fail_tests": []}], "EvoEval/44": [{"task_id": "EvoEval/44", "solution": "\nfrom typing import List\n\ndef roman_prefixes(number: int) -> List[str]:\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string in lowercase.\n    Afterwards, return a list of all prefixes of the roman numeral from shortest to longest.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> roman_prefixes(19) == ['x', 'xi', 'xix']\n    >>> roman_prefixes(152) == ['c', 'cl', 'cli', 'clii']\n    >>> roman_prefixes(426) == ['c', 'cd', 'cdx', 'cdxx', 'cdxxv', 'cdxxvi']\n    \"\"\"\n    roman_numerals = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd', 100: 'c', 90: 'xc', 50: 'l', 40: 'xl', 10: 'x', 9: 'ix', 5: 'v', 4: 'iv', 1: 'i'}\n\n    def to_roman(num: int) -> str:\n        result = ''\n        for (value, symbol) in roman_numerals.items():\n            while num >= value:\n                result += symbol\n                num -= value\n        return result\n    roman_numeral = to_roman(number)\n    prefixes = [roman_numeral[:i] for i in range(1, len(roman_numeral) + 1)]\n    return prefixes", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/26": [{"task_id": "EvoEval/26", "solution": "\nfrom typing import List, Tuple\n\ndef sort_and_pluck(values: List[str]) -> Tuple[str, int]:\n    if not values:\n        return ()\n    numerals = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\n    even_numerals = [numeral for numeral in numerals if numerals.index(numeral) % 2 == 0]\n    sorted_values = [' '.join(sorted(value.split())) for value in values]\n    plucked_numeral = None\n    plucked_index = None\n    for (i, value) in enumerate(sorted_values):\n        for numeral in even_numerals:\n            if numeral in value:\n                if plucked_numeral is None or numerals.index(numeral) < numerals.index(plucked_numeral):\n                    plucked_numeral = numeral\n                    plucked_index = i\n                break\n    if plucked_numeral is None:\n        return ()\n    return (plucked_numeral, plucked_index)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["three two one", "five four zero", "six nine eight"]]], "plus_fail_tests": []}], "EvoEval/50": [{"task_id": "EvoEval/50", "solution": "\ndef get_closest_upper_vowel(word):\n    vowels = set('AEIOU')\n    word = word[::-1]\n    for (i, char) in enumerate(word):\n        if char.isupper() and char in vowels and (i % 2 == 0):\n            if i > 0 and i < len(word) - 1 and word[i - 1].isalpha() and word[i + 1].isalpha():\n                return char\n    return ''", "base_status": "fail", "plus_status": null, "base_fail_tests": [["FULL"]], "plus_fail_tests": []}], "EvoEval/10": [{"task_id": "EvoEval/10", "solution": "\ndef class_grades_with_flip(name_grade_list):\n\n    def get_letter_grade(gpa):\n        if gpa >= 4.0:\n            return 'A+'\n        elif gpa >= 3.7:\n            return 'A'\n        elif gpa >= 3.3:\n            return 'A-'\n        elif gpa >= 3.0:\n            return 'B+'\n        elif gpa >= 2.7:\n            return 'B'\n        elif gpa >= 2.3:\n            return 'B-'\n        elif gpa >= 2.0:\n            return 'C+'\n        elif gpa >= 1.7:\n            return 'C'\n        elif gpa >= 1.3:\n            return 'C-'\n        elif gpa >= 1.0:\n            return 'D+'\n        elif gpa >= 0.7:\n            return 'D'\n        else:\n            return 'D-'\n    graded_students = []\n    for (name, gpa) in name_grade_list:\n        proper_case_name = name.capitalize()\n        letter_grade = get_letter_grade(gpa)\n        graded_students.append((proper_case_name, letter_grade))\n    return graded_students", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[["JOHN", 4.0], ["sarah", 3.0], ["ALICE", 1.7], ["BOB", 2.0], ["linda", 3.5]]]], "plus_fail_tests": []}], "EvoEval/22": [{"task_id": "EvoEval/22", "solution": "def binary_planet_distance(planet1, planet2):\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ''\n    start_index = planets.index(planet1)\n    end_index = planets.index(planet2)\n    if start_index > end_index:\n        (start_index, end_index) = (end_index, start_index)\n    planets_between = planets[start_index + 1:end_index]\n    num_planets = len(planets_between)\n    binary_str = bin(num_planets)[2:]\n    return 'bd' + binary_str + 'bd'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/24": [{"task_id": "EvoEval/24", "solution": "from typing import List\n\ndef sort_happy_numbers(numbers: str) -> str:\n    numbers_list = numbers.split()\n    num_str = ''.join(numbers_list)\n    for i in range(len(num_str) - 2):\n        if num_str[i] == num_str[i + 1] or num_str[i] == num_str[i + 2] or num_str[i + 1] == num_str[i + 2]:\n            return 'Not a happy string'\n    numbers_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    sorted_numbers = sorted(numbers_list, key=lambda x: numbers_dict[x])\n    return ' '.join(sorted_numbers)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/71": [{"task_id": "EvoEval/71", "solution": "\nimport math\n\ndef special_brazilian_balloon(n, w):\n\n    def brazilian_factorial(n):\n        result = 1\n        for i in range(n, 0, -1):\n            result *= math.factorial(i)\n        return result\n    max_weight = brazilian_factorial(n)\n    sum_weights = sum(w)\n    is_balanced = w == w[::-1]\n    return sum_weights <= max_weight and is_balanced", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/61": [{"task_id": "EvoEval/61", "solution": "\nfrom typing import List, Optional, Tuple\n\ndef longest_planet_chain(planet1: str, planet2: str, chains: List[Tuple[str, ...]]) -> Optional[Tuple[str, ...]]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return None\n    for chain in chains:\n        if chain[0] == planet1 and chain[-1] == planet2:\n            if not hasattr(longest_planet_chain, 'longest_chain') or len(chain) > len(longest_planet_chain.longest_chain):\n                longest_planet_chain.longest_chain = chain\n    return longest_planet_chain.longest_chain if hasattr(longest_planet_chain, 'longest_chain') else None", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Venus", "Jupiter", [["Venus", "Earth", "Mars", "Jupiter"], ["Venus", "Mercury", "Earth", "Mars", "Jupiter"], ["Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"]]]], "plus_fail_tests": []}], "EvoEval/91": [{"task_id": "EvoEval/91", "solution": "\ndef sort_prime_even(l: list, x, y):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted. If the sorted element at an even index\n    is prime, replace it with x. Otherwise, replace it with y.\n\n    Examples:\n    sort_prime_even([2, 3, 4, 5, 6], 10, 20) == [10, 3, 20, 5, 20]\n    sort_prime_even([7, 1, 9, 2, 8], 15, 30) == [15, 1, 30, 2, 30]\n    \"\"\"\n    even_indices = [l[i] for i in range(len(l)) if i % 2 == 0]\n    sorted_even_indices = sorted(even_indices)\n    prime_indices = [x if num in sorted_even_indices and is_prime(num) else y for num in l]\n    return [prime_indices[i] if i % 2 == 0 else l[i] for i in range(len(l))]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[7, 1, 9, 2, 8], 15, 30]], "plus_fail_tests": []}], "EvoEval/75": [{"task_id": "EvoEval/75", "solution": "def transform_dict(input_dict):\n    if not input_dict or not all((isinstance(key, str) for key in input_dict.keys())):\n        return {}\n    if not all((key.islower() or key.isupper() for key in input_dict.keys())):\n        return {}\n    result_dict = {}\n    for (key, value) in input_dict.items():\n        try:\n            num = float(value)\n            rounded_num = int(num + 0.5) if num > 0 else int(num - 0.5)\n            result_dict[key] = rounded_num\n        except ValueError:\n            return {}\n    return result_dict", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"a": "10", "B": "15.3"}]], "plus_fail_tests": []}], "EvoEval/82": [{"task_id": "EvoEval/82", "solution": "\ndef odd_fibfib(n: int) -> int:\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        fibfib = [0, 0, 1]\n        for i in range(3, n + 1):\n            fibfib.append(fibfib[i - 1] + fibfib[i - 2] + fibfib[i - 3])\n            if fibfib[i] % 2 == 0:\n                digits = [int(digit) for digit in str(fibfib[i]) if int(digit) % 2 != 0]\n                if len(digits) > 0:\n                    fibfib[i] = 1\n                    for digit in digits:\n                        fibfib[i] *= digit\n                else:\n                    fibfib[i] = 0\n        return fibfib[n]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/89": [{"task_id": "EvoEval/89", "solution": "\nfrom typing import List\n\ndef md5_substring_filter(strings: List[str], hash_substring: str) -> List[str]:\n    if not strings:\n        return None\n    filtered_strings = []\n    for string in strings:\n        if string != '' and hashlib.md5(string.encode()).hexdigest().find(hash_substring) != -1:\n            filtered_strings.append(string)\n    return filtered_strings", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["Python", "Hello", "123", ""], "96"]], "plus_fail_tests": []}], "EvoEval/62": [{"task_id": "EvoEval/62", "solution": "\ndef strange_word_sort(text):\n    words = text.split()\n    words = [word.lower() for word in words]\n    words.sort(key=lambda x: (x.lower(), -len(x)))\n    sorted_text = '-'.join(words)\n    sorted_text = sorted_text.replace('  ', '-')\n    sorted_text = sorted_text.replace(' ', '_')\n    return sorted_text", "base_status": "fail", "plus_status": null, "base_fail_tests": [["House   car"]], "plus_fail_tests": []}], "EvoEval/32": [{"task_id": "EvoEval/32", "solution": "\nfrom typing import List\n\ndef circular_shift_nested_parens(input: List[str], shift: int) -> List[int]:\n    depths = []\n    for group in input:\n        depth = 0\n        max_depth = 0\n        for char in group:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        depths.append(max_depth)\n    num = int(''.join(map(str, depths)))\n    num_str = str(num)\n    if shift > len(num_str):\n        shifted_num_str = num_str[::-1]\n    else:\n        shifted_num_str = num_str[-shift:] + num_str[:-shift]\n    shifted_num = int(shifted_num_str)\n    shifted_digits = [int(digit) for digit in str(shifted_num)]\n    return shifted_digits", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["(((", ")))"], 1]], "plus_fail_tests": []}], "EvoEval/55": [{"task_id": "EvoEval/55", "solution": "import hashlib\n\ndef mini_roman_to_md5(number):\n    if number <= 0:\n        return None\n    roman_numerals = {1: 'i', 4: 'iv', 5: 'v', 9: 'ix', 10: 'x', 40: 'xl', 50: 'l', 90: 'xc', 100: 'c', 400: 'cd', 500: 'd', 900: 'cm', 1000: 'm'}\n    result = ''\n    for (value, numeral) in sorted(roman_numerals.items(), key=lambda x: x[0], reverse=True):\n        while number >= value:\n            result += numeral\n            number -= value\n    md5_hash = hashlib.md5(result.encode()).hexdigest()\n    return md5_hash", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/92": [{"task_id": "EvoEval/92", "solution": "\ndef get_common_max_triples(n, l1: list):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    common_elements = sorted(list(set(a) & set(l1)))\n    multiples_of_3 = [x for x in common_elements if x % 3 == 0]\n    if len(multiples_of_3) == 0:\n        return 0\n    count = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return (common_elements, count)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[10, [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]]], "plus_fail_tests": []}], "EvoEval/57": [{"task_id": "EvoEval/57", "solution": "def palindromic_and_odd_digit_array(arr):\n    \"\"\"Given a list of positive integers 'arr', return the minimum number of elements\n    that need to be changed to make the array both palindromic and containing only odd digits. \n    A palindromic array is an array that is read the same backwards and forwards. \n    An array containing only odd digits is an array where every digit in every element is an odd number. \n    In one change, you can change one element to any other positive integer.\n    \n    For example:\n    >>> palindromic_and_odd_digit_array([1, 2, 3, 5, 4, 2, 9, 6])\n    4\n    >>> palindromic_and_odd_digit_array([1, 2, 3, 4, 3, 6, 2])\n    4\n    >>> palindromic_and_odd_digit_array([1, 2, 3, 2, 1])\n    2\n    \"\"\"\n\n    def is_palindromic(num):\n        return str(num) == str(num)[::-1]\n\n    def has_even_digit(num):\n        return any((int(digit) % 2 == 0 for digit in str(num)))\n    changes_needed = 0\n    for num in arr:\n        if not is_palindromic(num) or has_even_digit(num):\n            changes_needed += 1\n    return changes_needed", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 2, 5]]], "plus_fail_tests": []}], "EvoEval/19": [{"task_id": "EvoEval/19", "solution": "from typing import List, Tuple, Optional\n\ndef account_operations(operations: List[int]) -> Tuple[Optional[int], Optional[int], bool]:\n    balance = 0\n    largest_withdrawal = None\n    smallest_deposit = None\n    balance_below_zero = False\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            balance_below_zero = True\n            break\n        if operation < 0 and (largest_withdrawal is None or operation < largest_withdrawal):\n            largest_withdrawal = operation\n        if operation > 0 and (smallest_deposit is None or operation < smallest_deposit):\n            smallest_deposit = operation\n    return (largest_withdrawal, smallest_deposit, balance_below_zero)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/94": [{"task_id": "EvoEval/94", "solution": "\ndef sort_count_nums(arr):\n    count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n        digit_sum = sum((int(digit) for digit in str(num)))\n        if digit_sum > 0:\n            count += 1\n    if count % 2 == 0:\n        sorted_arr = sorted(arr, reverse=True)\n    else:\n        sorted_arr = sorted(arr)\n    return sorted_arr", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[15, -23, 56, 78, -90, 0, 34, 23, -45, 67]]], "plus_fail_tests": []}], "EvoEval/31": [{"task_id": "EvoEval/31", "solution": "\nfrom typing import List\n\ndef special_prime_factorial(n: int) -> int:\n    prime_factors = factorize(n)\n    factorials = [factorial(factor) for factor in prime_factors]\n    return product(factorials)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[70]], "plus_fail_tests": []}], "EvoEval/76": [{"task_id": "EvoEval/76", "solution": "def sort_prime_digit_sum(lst):\n    \"\"\"\n    You are given a list of non-negative integers. First, for each integer, if it is a prime number, \n    replace it with the sum of its digits; if not, keep it as is. Then, return a copy of the modified list \n    after sorting, where you will sort the list in ascending order if the sum of the first and last index value \n    is odd, or sort it in descending order if the sum of the first and last index value is even.\n\n    Note:\n    * don't change the original list.\n\n    Examples:\n    * sort_prime_digit_sum([]) => []\n    * sort_prime_digit_sum([5]) => [5]\n    * sort_prime_digit_sum([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_prime_digit_sum([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    * sort_prime_digit_sum([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]) => [0, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 7, 10, 32, 32, 32, 324]\n    \"\"\"\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def digit_sum(n):\n        return sum((int(digit) for digit in str(n)))\n    modified_lst = [digit_sum(num) if is_prime(num) else num for num in lst]\n    if (modified_lst[0] + modified_lst[-1]) % 2 == 0:\n        return sorted(modified_lst, reverse=True)\n    else:\n        return sorted(modified_lst)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[]]], "plus_fail_tests": []}], "EvoEval/70": [{"task_id": "EvoEval/70", "solution": "\nfrom typing import List, Tuple\nimport math\n\n\ndef closest_special_factorial(numbers: List[int]) -> Tuple[int, int]:\n\n    def special_factorial(n: int) -> int:\n        result = 1\n        for i in range(1, n + 1):\n            result *= math.factorial(i)\n        return result\n    closest_pair = None\n    min_difference = float('inf')\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            difference = abs(special_factorial(numbers[i]) - special_factorial(numbers[j]))\n            if difference < min_difference:\n                min_difference = difference\n                closest_pair = (numbers[i], numbers[j])\n    return tuple(sorted(closest_pair))", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[5, -6, -7]]], "plus_fail_tests": []}], "EvoEval/83": [{"task_id": "EvoEval/83", "solution": "\nimport re\n\n\ndef prime_underscored_length(text):\n    text = re.sub('\\\\s', '_', text)\n    text = re.sub('\\\\s+', '-', text)\n    length = len(text)\n    if length < 2:\n        return False\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return False\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[" Example    4"]], "plus_fail_tests": []}], "EvoEval/85": [{"task_id": "EvoEval/85", "solution": "def next_smallest_sorted_binary(lst):\n    if len(lst) < 2:\n        return None\n\n    def count_ones(num):\n        return bin(num).count('1')\n    sorted_lst = sorted(lst, key=lambda x: (count_ones(x), x))\n    if len(sorted_lst) < 2:\n        return None\n    return sorted_lst[1]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 1]]], "plus_fail_tests": []}], "EvoEval/2": [{"task_id": "EvoEval/2", "solution": "\nfrom typing import List\n\ndef modp_intersperse(numbers: List[int], n: int, p: int) -> List[int]:\n    result = []\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i < len(numbers) - 1:\n            result.append(pow(2, n) % p)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/47": [{"task_id": "EvoEval/47", "solution": "def count_odd_upper(s, lst):\n    vowels = set('AEIOU')\n    result = []\n\n    def count_vowels(s):\n        return sum((1 for (i, c) in enumerate(s) if c.upper() in vowels and i % 2 == 0))\n\n    def count_odd_digits(s):\n        return sum((1 for c in s if int(c) % 2 != 0))\n    n = count_vowels(s)\n    for string in lst:\n        m = count_odd_digits(string)\n        result.append(f'In the string, the number of uppercase vowels in even indices is {n}, and the number of odd digits is {m}.')\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["aBCdEf", ["1234567"]]], "plus_fail_tests": []}], "EvoEval/74": [{"task_id": "EvoEval/74", "solution": "def sum_exchange(lst1, lst2, x, y, z):\n    if sum((num % 2 != 0 for num in lst1)) <= len(lst2):\n        answer = 'YES'\n    else:\n        answer = 'NO'\n    if x == y + z or y == x + z or z == x + y:\n        answer = 'SUM ' + answer\n    else:\n        answer = 'NO_SUM ' + answer\n    return answer", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 4], [1, 5, 3, 4], 4, 2, 2]], "plus_fail_tests": []}], "EvoEval/52": [{"task_id": "EvoEval/52", "solution": "def pluck_and_prod(arr):\n    if not arr:\n        return ([], None)\n    even_values = [num for num in arr if num % 2 == 0]\n    if not even_values:\n        return ([], None)\n    smallest_even_value = min(even_values)\n    smallest_even_index = arr.index(smallest_even_value)\n    plucked_node = [smallest_even_value, smallest_even_index]\n    remaining_nodes = [abs(num) for num in arr if num != smallest_even_value]\n    product_of_signs = 1 if sum([1 for num in arr if num < 0]) % 2 == 0 else -1\n    sum_of_remaining_nodes = sum(remaining_nodes) * product_of_signs\n    return (plucked_node, sum_of_remaining_nodes)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[-5, -2, 3, 0, -4]]], "plus_fail_tests": []}], "EvoEval/13": [{"task_id": "EvoEval/13", "solution": "def filter_exchange(arr, lst1):\n\n    def sum_of_digits(num):\n        return sum((int(digit) for digit in str(abs(num))))\n    filtered_arr = [num for num in arr if sum_of_digits(num) > 0]\n    if not filtered_arr:\n        return 'NO'\n    even_count = sum((1 for num in lst1 if num % 2 == 0))\n    odd_count = len(lst1) - even_count\n    if odd_count > len(filtered_arr):\n        return 'NO'\n    else:\n        return 'YES'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 1, -121, 2], [1, 2, 3, 4]]], "plus_fail_tests": []}], "EvoEval/34": [{"task_id": "EvoEval/34", "solution": "from typing import List\n\ndef md5_nested_parens(paren_string: str) -> List[str]:\n    if not paren_string:\n        return []\n\n    def compute_deepest_level(paren_group: str) -> str:\n        stack = []\n        max_depth = 0\n        current_depth = 0\n        for char in paren_group:\n            if char == '(':\n                stack.append(char)\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                if not stack:\n                    return 'None'\n                stack.pop()\n                current_depth -= 1\n        if stack:\n            return 'None'\n        return str(max_depth)\n    groups = paren_string.split()\n    result = []\n    for group in groups:\n        deepest_level = compute_deepest_level(group)\n        if deepest_level == 'None':\n            result.append(hashlib.md5('None'.encode()).hexdigest())\n        else:\n            result.append(hashlib.md5(deepest_level.encode()).hexdigest())\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["(()()) (((((()))()((())()()))))"]], "plus_fail_tests": []}], "EvoEval/98": [{"task_id": "EvoEval/98", "solution": "\ndef check_dict_bracketing(dict):\n    if len(dict) == 0:\n        return False\n    keys = list(dict.keys())\n    first_key = keys[0]\n    is_lower_case = first_key.islower()\n    is_upper_case = first_key.isupper()\n    for key in keys:\n        if is_lower_case and (not key.islower()) or (is_upper_case and (not key.isupper())):\n            return False\n        value = dict[key]\n        if not all((c in '()[]' for c in value)):\n            return False\n        stack = []\n        for c in value:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if len(stack) == 0 or stack[-1] != '(':\n                    return False\n                stack.pop()\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"Name": "()", "Age": "(())"}]], "plus_fail_tests": []}], "EvoEval/63": [{"task_id": "EvoEval/63", "solution": "\ndef sort_planets(planet1: str, planet2: str, order: str) -> str:\n    planets = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven']\n    if planet1 not in planets or planet2 not in planets:\n        return 'Invalid'\n    order_list = order.split()\n    if len(order_list) != len(set(order_list)) or any((num not in planets for num in order_list)):\n        return 'Invalid'\n    index1 = order_list.index(planet1)\n    index2 = order_list.index(planet2)\n    sorted_planets = sorted(order_list[index1 + 1:index2], key=lambda x: order_list.index(x))\n    return ' '.join(sorted_planets)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Mercury", "Uranus", "zero one two three four five six seven"]], "plus_fail_tests": []}], "EvoEval/20": [{"task_id": "EvoEval/20", "solution": "\ndef grade_and_case(s, grades):\n\n    def reverse_case(name):\n        return name.swapcase()\n\n    def assign_grade(gpa):\n        if gpa >= 4.0:\n            return 'A+'\n        elif gpa > 3.7:\n            return 'A'\n        elif gpa > 3.3:\n            return 'A-'\n        elif gpa > 3.0:\n            return 'B+'\n        elif gpa > 2.7:\n            return 'B'\n        elif gpa > 2.3:\n            return 'B-'\n        elif gpa > 2.0:\n            return 'C+'\n        elif gpa > 1.7:\n            return 'C'\n        elif gpa > 1.3:\n            return 'C-'\n        elif gpa > 1.0:\n            return 'D+'\n        elif gpa > 0.7:\n            return 'D'\n        elif gpa > 0.0:\n            return 'D-'\n        else:\n            return 'E'\n    result = []\n    for i in range(len(s)):\n        name = reverse_case(s[i])\n        grade = assign_grade(grades[i])\n        result.append((name, grade))\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["JANe", "JOHN", "MARy", "ALICE", "BOB"], [4.1, 2.0, 1.6, 3.9, 0.5]]], "plus_fail_tests": []}], "EvoEval/33": [{"task_id": "EvoEval/33", "solution": "\ndef roman_happiness(s):\n    \"\"\"\n    Given a string s of Roman numerals in lowercase, your task is to check if the roman numeral string is happy or not.\n\n    Definition:\n    A Roman numeral string is happy if:\n    1. Its length is at least 3.\n    2. It represents a positive integer less than or equal to 1000.\n    3. Every 3 consecutive letters are distinct.\n\n    If the string does not meet the criteria, return False. If the string is happy, return the integer that it represents.\n\n    For example:\n    roman_happiness('i') => False\n    roman_happiness('ii') => False\n    roman_happiness('xiv') => 14\n    roman_happiness('iiv') => False\n    roman_happiness('xiv') => 14\n    roman_happiness('xxxi') => False\n    roman_happiness('xliv') => 44\n    \"\"\"\n    if len(s) < 3:\n        return False\n    roman_values = {'i': 1, 'v': 5, 'x': 10, 'l': 50, 'c': 100, 'd': 500, 'm': 1000}\n    total = 0\n    prev = None\n    count = 0\n    for letter in s:\n        if letter not in roman_values:\n            return False\n        value = roman_values[letter]\n        if prev is not None and prev == letter:\n            count += 1\n            if count >= 3:\n                return False\n        else:\n            count = 1\n        total += value\n        prev = letter\n    if total > 1000:\n        return False\n    return total", "base_status": "fail", "plus_status": null, "base_fail_tests": [["xliv"]], "plus_fail_tests": []}], "EvoEval/90": [{"task_id": "EvoEval/90", "solution": "\ndef vowels_in_dict_keys(dict):\n    \"\"\"\n    Given a dictionary, write a function that checks if all the keys are strings in either lower case or upper case \n    and returns a dictionary where keys are the same keys from the input dictionary and the values are the count of vowels in each key. \n    If the keys are not all in lower case nor all in upper case, return an empty dictionary. \n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a vowel, but only when it is at the end of the given word.\n    The function should return an empty dictionary if the input dictionary itself is empty.\n    \n    Examples:\n    vowels_in_dict_keys({\"a\":\"apple\", \"b\":\"banana\"}) should return {\"a\":1, \"b\":0}.\n    vowels_in_dict_keys({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return {}.\n    vowels_in_dict_keys({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return {}.\n    vowels_in_dict_keys({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return {}.\n    vowels_in_dict_keys({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return {\"STATE\": 2, \"ZIP\": 1}.\n    \"\"\"\n    if not dict:\n        return {}\n    lowercase_keys = []\n    uppercase_keys = []\n    for key in dict.keys():\n        if isinstance(key, str):\n            if key.islower():\n                lowercase_keys.append(key)\n            elif key.isupper():\n                uppercase_keys.append(key)\n            else:\n                return {}\n        else:\n            return {}\n    result = {}\n    for key in lowercase_keys:\n        count = 0\n        for char in key:\n            if char.lower() in ['a', 'e', 'i', 'o', 'u']:\n                count += 1\n        result[key] = count\n    for key in uppercase_keys:\n        count = 0\n        for char in key:\n            if char.lower() in ['a', 'e', 'i', 'o', 'u', 'y']:\n                count += 1\n        result[key] = count\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"a": "apple", "A": "banana", "B": "banana"}]], "plus_fail_tests": []}], "EvoEval/96": [{"task_id": "EvoEval/96", "solution": "\ndef common_pairs_with_zero_sum(l1: list, l2: list) -> bool:\n    \"\"\"\n    common_pairs_with_zero_sum takes two lists of integers as an input.\n    It first identifies the common elements between the two lists.\n    Then, it checks if there are two distinct elements in the common elements that sum to zero.\n    \n    Returns True if such pair exists and False otherwise.\n\n    >>> common_pairs_with_zero_sum([1, 3, 5, -3, 0], [0, -3, 1, 5, 2])\n    False\n    >>> common_pairs_with_zero_sum([1, 3, -2, 1], [2, 3, -2, 1])\n    False\n    >>> common_pairs_with_zero_sum([1, 2, 3, 7], [8, 9, 2, 1])\n    False\n    >>> common_pairs_with_zero_sum([2, 4, -5, 3, 5, 7], [-5, 4, 2, 3, 5, 7])\n    True\n    >>> common_pairs_with_zero_sum([1], [2])\n    False\n    \"\"\"\n    common_elements = set(l1) & set(l2)\n    for num1 in common_elements:\n        for num2 in common_elements:\n            if num1 != num2 and num1 + num2 == 0:\n                return True\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/67": [{"task_id": "EvoEval/67", "solution": "\nfrom typing import List\n\ndef max_close_element_difference(numbers: List[float], threshold: float) -> float:\n    \"\"\"\n    Given a list of numbers and a threshold, find two elements that are closer to each other than the threshold and return their difference. If multiple pairs meet the criteria, return the maximum difference. If no such pairs exist, return 0.\n    >>> max_close_element_difference([1.0, 2.0, 3.0], 0.5)\n    0\n    >>> max_close_element_difference([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    0.2\n    >>> max_close_element_difference([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 5)\n    4\n    \"\"\"\n    max_difference = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            difference = abs(numbers[i] - numbers[j])\n            if difference < threshold and difference > max_difference:\n                max_difference = difference\n    return max_difference", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/42": [{"task_id": "EvoEval/42", "solution": "\ndef check_expression(expression: str):\n    stack = []\n    i = 0\n    while i < len(expression):\n        if expression[i] == '<':\n            stack.append('<')\n        elif expression[i] == '>':\n            if len(stack) == 0 or stack[-1] != '<':\n                return False\n            stack.pop()\n        elif expression[i] == ',':\n            if len(stack) == 0 or stack[-1] != '<':\n                return False\n        i += 1\n    if len(stack) > 0:\n        return False\n    fractions = expression[1:-1].split(',')\n    product = 1\n    for fraction in fractions:\n        (numerator, denominator) = map(int, fraction.split('/'))\n        product *= numerator / denominator\n    return product.is_integer()", "base_status": "fail", "plus_status": null, "base_fail_tests": [["<1/2,2/1><2/3,3/2>"]], "plus_fail_tests": []}], "EvoEval/15": [{"task_id": "EvoEval/15", "solution": "from typing import List\n\ndef balance_triples(operations: List[int]) -> bool:\n    \"\"\"\n    balance_triples takes a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. It returns True if there are at least three distinct points in time where the balance of account sums to zero (excluding the initial balance), \n    and False otherwise. If at any point the balance of account falls below zero, function should immediately return False.\n    \n    >>> balance_triples([1, -1, 2, -2, 3, -3])\n    True\n    >>> balance_triples([1, 2, 3, -6])\n    False\n    >>> balance_triples([1, 2, -4, 5])\n    False\n    >>> balance_triples([2, -2, 3, -3, 4, -4])\n    True\n    >>> balance_triples([1, -1, 2])\n    False\n    \"\"\"\n    balance = 0\n    zero_sums = set()\n    for i in range(len(operations)):\n        balance += operations[i]\n        if balance < 0:\n            return False\n        if balance == 0:\n            zero_sums.add(i)\n    return len(zero_sums) >= 3", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/30": [{"task_id": "EvoEval/30", "solution": "\nfrom typing import List\n\ndef parse_music_simplify(x: str, music_string: str) -> List[bool]:\n    (numerator, denominator) = map(int, x.split('/'))\n    beats = {'o': 4, 'o|': 2, '.|': 1}\n    music_notes = music_string.split()\n    result = []\n    for note in music_notes:\n        if numerator * beats[note] % denominator == 0:\n            result.append(True)\n        else:\n            result.append(False)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/37": [{"task_id": "EvoEval/37", "solution": "\nimport math\n\ndef minSubArraySumEvenOdd(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums. Then, return a tuple that has the number of even and odd digits in \n    this minimum sum respectively.\n\n    Example:\n    minSubArraySumEvenOdd([2, 3, 4, 1, 2, 4]) == (0, 1)  # minimum sum is 1 which has 0 even digit and 1 odd digit\n    minSubArraySumEvenOdd([-1, -2, -3]) == (1, 0)  # minimum sum is -6 which has 1 even digit and 0 odd digit\n    \"\"\"\n    min_sum = math.inf\n    even_count = 0\n    odd_count = 0\n    for i in range(len(nums)):\n        current_sum = 0\n        for j in range(i, len(nums)):\n            current_sum += nums[j]\n            if current_sum < min_sum:\n                min_sum = current_sum\n    min_sum_str = str(abs(min_sum))\n    for digit in min_sum_str:\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/84": [{"task_id": "EvoEval/84", "solution": "\nfrom typing import List, Dict\n\ndef prefixes_histogram(string: str) -> Dict[str, Dict[str, int]]:\n    \"\"\" Given a string, return a dictionary where the keys are all the prefixes of the string,\n    and the values are dictionaries representing the histograms of the individual letters in each prefix. \n    The histogram dictionaries should contain the letter with the most repetition and the corresponding count.\n    If several letters have the same occurrence, include all of them.\n    \n    Example:\n    prefixes_histogram('abc') == {'a': {'a': 1}, 'ab': {'a': 1, 'b': 1}, 'abc': {'a': 1, 'b': 1, 'c': 1}}\n    prefixes_histogram('aba') == {'a': {'a': 1}, 'ab': {'a': 1, 'b': 1}, 'aba': {'a': 2}}\n    prefixes_histogram('') == {}\n    \"\"\"\n    prefixes = {}\n    for i in range(len(string)):\n        prefix = string[:i + 1]\n        histogram = {}\n        for char in prefix:\n            histogram[char] = histogram.get(char, 0) + 1\n        prefixes[prefix] = histogram\n    return prefixes", "base_status": "fail", "plus_status": null, "base_fail_tests": [["aba"]], "plus_fail_tests": []}], "EvoEval/97": [{"task_id": "EvoEval/97", "solution": "\ndef fib_max_triples(n):\n    fib = [0, 0, 1]\n    for i in range(3, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2] + fib[i - 3] + i * i - i + 1)\n    count = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if (fib[i] + fib[j] + fib[k]) % 3 == 0:\n                    count += 1\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [[5]], "plus_fail_tests": []}], "EvoEval/21": [{"task_id": "EvoEval/21", "solution": "\nfrom typing import List\n\ndef base_change_prefixes(x: int, base: int) -> List[str]:\n    \"\"\" For a given number x and a base less than 10, first change the numerical base of x to the given base.\n    Then return a list of all prefixes from the shortest to the longest of the new base representation of x.\n    \n    >>> base_change_prefixes(8, 3)\n    ['2', '22']\n    >>> base_change_prefixes(8, 2)\n    ['1', '10', '100', '1000']\n    >>> base_change_prefixes(7, 2)\n    ['1', '11', '111']\n    \"\"\"\n    result = []\n    while x > 0:\n        result.append(str(x % base))\n        x //= base\n    result.reverse()\n    prefixes = []\n    for i in range(len(result)):\n        prefixes.append(''.join(result[:i + 1]))\n    return prefixes", "base_status": "fail", "plus_status": null, "base_fail_tests": [[0, 2]], "plus_fail_tests": []}], "EvoEval/3": [{"task_id": "EvoEval/3", "solution": "\nfrom typing import List\n\ndef sort_parentheses(lst: List[str]) -> str:\n    numbers = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    sorted_lst = sorted(lst, key=lambda s: numbers[s.strip('()')])\n    concatenated = ''.join(sorted_lst)\n    stack = []\n    for char in concatenated:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return 'No'\n            stack.pop()\n    if stack:\n        return 'No'\n    else:\n        return 'Yes'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/68": [{"task_id": "EvoEval/68", "solution": "\ndef minOddDigitsProductSubArray(nums):\n    \"\"\"\n    Given an array of positive integers nums, find the minimum product of odd digits of any \n    non-empty sub-array of nums. For each integer in the sub-array, you need to calculate \n    the product of its odd digits. If all digits are even in an integer, consider its product as 0.\n    You need to return the minimum sum of these products.\n    \n    Example:\n    minOddDigitsProductSubArray([2, 3, 4, 1, 2, 4]) == 0\n    minOddDigitsProductSubArray([235, 912, 43]) == 3 (as 235 -> 15, 912 -> 9, 43 -> 3)\n\n    Note: \n    A sub-array is a contiguous part of an array. And you should calculate the products for \n    each integer in the sub-array independently.\n    \"\"\"\n    min_sum = float('inf')\n    for i in range(len(nums)):\n        product = 1\n        for digit in str(nums[i]):\n            if int(digit) % 2 != 0:\n                product *= int(digit)\n        if product == 1:\n            product = 0\n        min_sum = min(min_sum, product)\n    return min_sum", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[11111, 99999, 77777, 55555, 33333]]], "plus_fail_tests": []}], "EvoEval/27": [{"task_id": "EvoEval/27", "solution": "\ndef list_prime_exchange(lst1, lst2, x, y):\n    \"\"\"The function takes two lists of numbers lst1 and lst2, and two integers x and y. The task is to \n    determine whether it is possible to perform an exchange of elements between lst1 and lst2 to \n    make lst1 a list of only prime numbers. \n\n    If it is possible, return the value of x. If it is not possible, return the value of y. \n\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n\n    For example:\n    list_prime_exchange([1, 2, 3, 4], [5, 7, 11, 13], 10, 20) => 10\n    list_prime_exchange([1, 2, 3, 4], [6, 8, 10, 12], 30, 40)\n\n    It is assumed that the input lists will be non-empty and the integers x and y will be non-zero.\n    \"\"\"\n    prime_lst1 = [num for num in lst1 if is_prime(num)]\n    if len(prime_lst1) == len(lst1):\n        return x\n    for num in lst2:\n        if is_prime(num):\n            return x\n    return y", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 4], [6, 7, 8, 12], 30, 40]], "plus_fail_tests": []}], "EvoEval/23": [{"task_id": "EvoEval/23", "solution": "\ndef special_stone_factorial(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones. The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n\n    For each level, calculate the Brazilian factorial (defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!), \n    where n is the number of stones in the level.\n\n    Return the list of Brazilian factorials for each level.\n\n    For example:\n    >>> special_stone_factorial(3)\n    [12, 34560, 125411328000]\n    \"\"\"\n    factorials = []\n    for i in range(n):\n        stones = n + 2 * i if n % 2 == 0 else n + 2 * i + 1\n        factorial = 1\n        for j in range(stones, 0, -1):\n            factorial *= j\n        factorials.append(factorial)\n    return factorials", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1]], "plus_fail_tests": []}], "EvoEval/8": [{"task_id": "EvoEval/8", "solution": "\ndef correct_bracket_sequence_and_count(string: str, bracket: str) -> tuple:\n    \"\"\"\n    This function checks if a given string has correctly paired opening and closing brackets and \n    counts how many times a specific bracket appears in the string, including overlapping cases.\n    \n    The function takes a string of \"<\" and \">\" characters and a specific bracket (\"<\" or \">\") \n    as inputs, and returns a tuple with a boolean value and an integer. The boolean value represents \n    whether every opening bracket has a corresponding closing bracket. The integer represents the \n    count of the specific bracket in the string.\n\n    >>> correct_bracket_sequence_and_count('<<><>>', '<')\n    (True, 3)\n    >>> correct_bracket_sequence_and_count('<<><>>', '>')\n    (True, 3)\n    >>> correct_bracket_sequence_and_count('<>', '<')\n    (True, 1)\n    >>> correct_bracket_sequence_and_count('><<>', '>')\n    (False, 2)\n    >>> correct_bracket_sequence_and_count('', '>')\n    (True, 0)\n    \"\"\"\n    count = string.count(bracket)\n    if bracket == '<':\n        opening_bracket = '<'\n        closing_bracket = '>'\n    else:\n        opening_bracket = '>'\n        closing_bracket = '<'\n    stack = []\n    for char in string:\n        if char == opening_bracket:\n            stack.append(char)\n        elif char == closing_bracket:\n            if len(stack) == 0:\n                return (False, count)\n            stack.pop()\n    return (len(stack) == 0, count)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["<<><>>", ">"]], "plus_fail_tests": []}], "EvoEval/99": [{"task_id": "EvoEval/99", "solution": "\ndef len_base_conversion(x: int, base: int) -> int:\n    \"\"\"\n    Convert the numerical base of input number x to base and \n    return the length of string representation after the conversion. \n    base numbers are less than 10.\n    \n    >>> len_base_conversion(8, 3)\n    2\n    >>> len_base_conversion(8, 2)\n    4\n    >>> len_base_conversion(7, 2)\n    3\n    \"\"\"\n    converted_num = ''\n    while x > 0:\n        remainder = x % base\n        converted_num = str(remainder) + converted_num\n        x = x // base\n    return len(converted_num)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/14": [{"task_id": "EvoEval/14", "solution": "\ndef prime_avg_range(n, m):\n    if n > m:\n        return -1\n    primes = []\n    for num in range(n, m + 1):\n        if num > 1:\n            for i in range(2, int(num ** 0.5) + 1):\n                if num % i == 0:\n                    break\n            else:\n                primes.append(num)\n    if len(primes) == 0:\n        return -1\n    avg = round(sum(primes) / len(primes))\n    binary = bin(avg)\n    return binary", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/1": [{"task_id": "EvoEval/1", "solution": "def round_and_flip(value: str) -> str:\n    (num_str, str_part) = value.split(maxsplit=1)\n    num = float(num_str)\n    rounded_num = int(num + 0.5) if num > 0 else int(num - 0.5)\n    flipped_str = str_part.swapcase()\n    return f'{rounded_num} {flipped_str}'", "base_status": "fail", "plus_status": null, "base_fail_tests": [["15.3ABC"]], "plus_fail_tests": []}], "EvoEval/11": [{"task_id": "EvoEval/11", "solution": "\ndef planet_vowel_count(planet1, planet2):\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    if planet1 not in planets or planet2 not in planets:\n        return 0\n    start_index = planets.index(planet1)\n    end_index = planets.index(planet2)\n    if start_index > end_index:\n        (start_index, end_index) = (end_index, start_index)\n    count = 0\n    for i in range(start_index + 1, end_index):\n        planet = planets[i]\n        if planet[-1] in vowels:\n            count += 1\n        for vowel in vowels:\n            count += planet.count(vowel)\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Mercury", "Uranus"]], "plus_fail_tests": []}], "EvoEval/95": [{"task_id": "EvoEval/95", "solution": "\nfrom typing import List\n\ndef filter_sort_strings(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain a given substring and have an even length. \n    Return the resulted list in ascending order by the length of each word. \n    If two words have the same length, sort the list alphabetically.\n    The list may contain duplicate strings.\n    \n    For example:\n    >>> filter_sort_strings([], 'a')\n    []\n    >>> filter_sort_strings(['abc', 'bacd', 'cd', 'array'], 'a')\n    ['bacd']\n    >>> filter_sort_strings(['abc', 'bacd', 'cd', 'array', 'play'], 'a')\n    ['bacd', 'play']\n    \"\"\"\n    filtered_strings = [s for s in strings if substring in s and len(s) % 2 == 0]\n    sorted_strings = sorted(filtered_strings, key=lambda x: (len(x), x))\n    return sorted_strings", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/6": [{"task_id": "EvoEval/6", "solution": "\ndef pile_median(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the median number of stones in all levels in the pile.\n\n    You should return the answer as a float if the number of levels is even,\n    and as an integer if the number of levels is odd.\n\n    Examples:\n    >>> pile_median(3)\n    5\n    >>> pile_median(4)\n    7.0\n    \"\"\"\n    if n % 2 == 0:\n        return float(n + (n - 1)) / 2\n    else:\n        return (n + (n - 1)) // 2 + 1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[2]], "plus_fail_tests": []}], "EvoEval/43": [{"task_id": "EvoEval/43", "solution": "\ndef sorted_fib4_sequence(n: int):\n    sequence = [0, 0, 2, 0]\n    if n <= 3:\n        return sequence[:n]\n    for i in range(4, n + 1):\n        sequence.append(sequence[i - 1] + sequence[i - 2] + sequence[i - 3] + sequence[i - 4])\n    if (sequence[0] + sequence[-1]) % 2 == 0:\n        return sorted(sequence, reverse=True)\n    else:\n        return sorted(sequence)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[3]], "plus_fail_tests": []}], "EvoEval/39": [{"task_id": "EvoEval/39", "solution": "def smallest_change_and_sum(arr, x, y):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n    After finding the minimum changes, add the value of x and y to it.\n\n    For example:\n    smallest_change_and_sum([1, 2, 3, 5, 4, 7, 9, 6], 2, 3) == 9\n    smallest_change_and_sum([1, 2, 3, 4, 3, 2, 2], 1, 2) == 4\n    smallest_change_and_sum([1, 2, 3, 2, 1], 3, 2) == 5\n    \"\"\"\n\n    def min_changes_to_palindrome(arr):\n        n = len(arr)\n        dp = [[0] * n for _ in range(n)]\n        for l in range(2, n + 1):\n            for i in range(n - l + 1):\n                j = i + l - 1\n                if arr[i] == arr[j]:\n                    dp[i][j] = dp[i + 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i][j - 1], dp[i + 1][j])\n        return dp[0][n - 1]\n    min_changes = min_changes_to_palindrome(arr)\n    return min_changes + x + y", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 4, 3, 2, 2], 1, 2]], "plus_fail_tests": []}], "EvoEval/56": [{"task_id": "EvoEval/56", "solution": "def product_of_odd_prime_factors(n):\n    \"\"\"Given a positive integer n, return the product of its unique odd prime factors.\n    If all prime factors are even, return 0.\n    Assume n > 1 and is not a prime.\n    For example:\n    product_of_odd_prime_factors(9) == 3\n    product_of_odd_prime_factors(15) == 15\n    product_of_odd_prime_factors(20) == 5\n    product_of_odd_prime_factors(32) == 0\n    \"\"\"\n    factors = set()\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            factors.add(i)\n            n //= i\n        else:\n            i += 1\n    if n > 1:\n        factors.add(n)\n    odd_prime_factors = [factor for factor in factors if factor % 2 != 0 and all((factor % j != 0 for j in range(2, int(factor ** 0.5) + 1)))]\n    if all((factor % 2 == 0 for factor in factors)):\n        return 0\n    else:\n        return 1 if len(odd_prime_factors) == 0 else reduce(lambda x, y: x * y, odd_prime_factors)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[20]], "plus_fail_tests": []}], "EvoEval/93": [{"task_id": "EvoEval/93", "solution": "\ndef prime_vowel(string):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    consonants = [c for c in string if c.isalpha() and c.lower() not in vowels]\n    if is_prime(len(consonants)):\n        for i in range(len(string) - 2, 0, -1):\n            if string[i] in vowels and string[i - 1] not in vowels and (string[i + 1] not in vowels):\n                return string[i]\n    return ''", "base_status": "fail", "plus_status": null, "base_fail_tests": [["orange"]], "plus_fail_tests": []}], "EvoEval/46": [{"task_id": "EvoEval/46", "solution": "\ndef get_max_even_positive(l: list):\n    \"\"\"This function takes a list of positive and negative numbers, filters \n    out the negative numbers, and returns the largest even number among the \n    remaining elements. If there are no positive even numbers in the list, \n    the function should return -1.\n\n    For example:\n    get_max_even_positive([-1, 2, -4, 5, 6]) = 6\n    get_max_even_positive([1, 3, 5, 7]) = -1\n    \"\"\"\n    positive_numbers = [num for num in l if num > 0]\n    even_numbers = [num for num in positive_numbers if num % 2 == 0]\n    if even_numbers:\n        return max(even_numbers)\n    else:\n        return -1", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/41": [{"task_id": "EvoEval/41", "solution": "\ndef shifted_upper_count(s, shift):\n    \"\"\"\n    Given a string s and an integer shift, perform a circular shift on the ASCII values of the characters in string \n    by the shift value. Return the count of uppercase vowels in even indices after the shift.\n\n    If shift > length of string, reverse the string before counting.\n\n    For example:\n    shifted_upper_count('aBCdEf', 1) returns 0\n    shifted_upper_count('abcdefg', 2) returns 0\n    shifted_upper_count('dBBE', 3) returns 1\n    \"\"\"\n    vowels = ['A', 'E', 'I', 'O', 'U']\n    count = 0\n    if shift > len(s):\n        s = s[::-1]\n    for i in range(len(s)):\n        if i % 2 == 0 and s[i].isupper() and (s[i] in vowels):\n            count += 1\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [["dBBE", 3]], "plus_fail_tests": []}], "EvoEval/49": [{"task_id": "EvoEval/49", "solution": "\ndef modp_count(arr, n: int, p: int):\n    \"\"\"\n    Write a function modp_count which takes an array of integers and two integers n and p as inputs.\n    The function should first calculate 2^n modulo p. \n    It then counts the number of elements in the array which has a sum of digits > the result of 2^n modulo p.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> modp_count([], 2, 5) == 0\n    >>> modp_count([-1, 11, -11], 4, 5) == 1\n    >>> modp_count([1, 1, 2], 0, 101) == 1\n    >>> modp_count([12, 15, 20], 11, 3) == 2\n    \"\"\"\n    modp = pow(2, n, p)\n    count = 0\n    for num in arr:\n        if num < 0:\n            digits = [int(digit) for digit in str(num)[1:]]\n            digits[0] *= -1\n        else:\n            digits = [int(digit) for digit in str(num)]\n        if sum(digits) > modp:\n            count += 1\n    return count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/9": [{"task_id": "EvoEval/9", "solution": "def planet_to_roman_distance(planet1, planet2):\n    planets = {'mercury': 'i', 'venus': 'ii', 'earth': 'iii', 'mars': 'iv', 'jupiter': 'v', 'saturn': 'vi', 'uranus': 'vii', 'neptune': 'viii'}\n    planet_order = ['mercury', 'venus', 'earth', 'mars', 'jupiter', 'saturn', 'uranus', 'neptune']\n    planet1 = planet1.lower()\n    planet2 = planet2.lower()\n    if planet1 not in planets or planet2 not in planets:\n        return {}\n    start = planet_order.index(planet1)\n    end = planet_order.index(planet2)\n    if start > end:\n        (start, end) = (end, start)\n    result = {}\n    for i in range(start + 1, end):\n        result[planet_order[i]] = planets[planet_order[i]]\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Uranus", 1]], "plus_fail_tests": []}], "EvoEval/77": [{"task_id": "EvoEval/77", "solution": "\ndef mixed_solution(arr):\n    sum_odd = 0\n    for i in range(len(arr)):\n        if i % 2 == 0 and arr[i] % 2 != 0:\n            digits_sum = sum((int(digit) for digit in str(abs(arr[i]))))\n            if digits_sum > 0:\n                sum_odd += arr[i]\n    return sum_odd", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 3, -3, 3, 3]]], "plus_fail_tests": []}], "EvoEval/54": [{"task_id": "EvoEval/54", "solution": "\nimport math\n\ndef max_sum_of_prime_subarray(nums):\n    \"\"\"\n    Given an array of integers nums, find the maximum sum of any non-empty sub-array\n    of prime nums. If no prime subarray exists, return 0.\n    A prime number is a number that has exactly two distinct positive divisors: 1 and itself.\n    You may assume that all numbers in the array are greater than 0.\n    \n    Example\n    max_sum_of_prime_subarray([1, 2, 3, 4, 5, 6]) == 5  # The subarray [2, 3] is a subarray with primes, and it has the maximum sum, so their sum, 5, is returned\n    max_sum_of_prime_subarray([4, 6, 8, 10]) == 0 # There are no primes in the list\n    max_sum_of_prime_subarray([2, 3, 5, 7, 11, 13]) == 41 # All numbers in this list are primes, so their sum, 41, is returned\n    \"\"\"\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                return False\n        return True\n    max_sum = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            subarray = nums[i:j + 1]\n            if any((is_prime(num) for num in subarray)):\n                max_sum = max(max_sum, sum(subarray))\n    return max_sum", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 4, 5, 6]]], "plus_fail_tests": []}], "EvoEval/7": [{"task_id": "EvoEval/7", "solution": "\ndef sum_square_cube_to_n(n: int):\n    \"\"\"\n    This function takes an integer n. The function generates a list of integers from 1 to n inclusive. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n\n    Examples:\n    For n = 3 the output should be 12\n    For n = 1 the output should be 1\n    For n = 5 the output should be 81\n    For n = 10 the output should be 727\n    \"\"\"\n    numbers = list(range(1, n + 1))\n    result = 0\n    for (i, num) in enumerate(numbers):\n        if (i + 1) % 3 == 0:\n            result += num ** 2\n        if (i + 1) % 4 == 0 and (i + 1) % 3 != 0:\n            result += num ** 3\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[10]], "plus_fail_tests": []}], "EvoEval/73": [{"task_id": "EvoEval/73", "solution": "\nfrom typing import List\nfrom fractions import Fraction\n\ndef filter_and_simplify(fractions: List[str], n: str) -> List[bool]:\n    result = []\n    for fraction in fractions:\n        fraction_obj = Fraction(fraction)\n        n_obj = Fraction(n)\n        multiplied_fraction = fraction_obj * n_obj\n        result.append(multiplied_fraction.denominator == 1)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/60": [{"task_id": "EvoEval/60", "solution": "\ndef smallest_even_triple(arr, n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    smallest_triple = None\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    if smallest_triple is None or a[i] < smallest_triple[0]:\n                        smallest_triple = (a[i], a[j], a[k])\n    if smallest_triple is not None:\n        arr.append(smallest_triple[0])\n    smallest_even_value = None\n    smallest_even_index = None\n    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n            if smallest_even_value is None or arr[i] < smallest_even_value:\n                smallest_even_value = arr[i]\n                smallest_even_index = i\n    if smallest_even_value is not None:\n        return [smallest_even_value, smallest_even_index]\n    else:\n        return []", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[4, 2, 3], 1]], "plus_fail_tests": []}], "EvoEval/87": [{"task_id": "EvoEval/87", "solution": "\ndef match_and_remove_unbalanced(text):\n    stack = []\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    result = ''\n    for char in text:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                result += char\n        elif char not in vowels:\n            result += char\n    while len(stack) > 0:\n        result += stack.pop()\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["ab(cd"]], "plus_fail_tests": []}], "EvoEval/29": [{"task_id": "EvoEval/29", "solution": "def largest_prime_factor_or_value(n, x, y):\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def largest_prime_factor(num):\n        i = 2\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                num //= i\n        return num\n    if n == 1:\n        return y\n    elif is_prime(n):\n        return x\n    else:\n        return largest_prime_factor(n)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/5": [{"task_id": "EvoEval/5", "solution": "\nfrom typing import List\n\ndef sort_and_check(numbers: List[float], threshold: float) -> List[float]:\n    \"\"\"\n    Given an array of numbers, check if any two numbers in the array are closer to each other \n    than the given threshold. If yes, sort the array according to the following rules:\n\n    - If the sum of the first and last numbers in the array is even, sort the array in descending order.\n    - If the sum of the first and last numbers in the array is odd, sort the array in ascending order.\n    \n    If no two numbers are closer than the threshold, return the array as it is.\n    \n    Note: Consider the sum as even or odd after rounding off to the nearest integer.\n\n    Examples:\n    * sort_and_check([1.0, 2.0, 3.0], 0.5) => [1.0, 2.0, 3.0]\n    * sort_and_check([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) => [1.0, 2.0, 2.8, 3.0, 4.0, 5.0]\n    * sort_and_check([4.0, 2.0, 3.0, 0.0], 2.0) => [4.0, 3.0, 2.0, 0.0]\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                if round(numbers[0] + numbers[-1]) % 2 == 0:\n                    numbers.sort(reverse=True)\n                else:\n                    numbers.sort()\n                return numbers\n    return numbers", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/28": [{"task_id": "EvoEval/28", "solution": "\ndef grade_with_same_chars(grades: list, s0: str, s1: str):\n    grades_table = {4.0: 'A+', 3.7: 'A', 3.3: 'A-', 3.0: 'B+', 2.7: 'B', 2.3: 'B-', 2.0: 'C+', 1.7: 'C', 1.3: 'C-', 1.0: 'D+', 0.7: 'D', 0.0: 'D-', -1.0: 'E'}\n    if sorted(s0) != sorted(s1):\n        return []\n    result = []\n    for gpa in grades:\n        for key in grades_table:\n            if gpa >= key:\n                result.append(grades_table[key])\n                break\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[4.0, 3, 1.7, 2, 3.5], "aaabcd", "dddcba"]], "plus_fail_tests": []}], "EvoEval/51": [{"task_id": "EvoEval/51", "solution": "\ndef modify_and_compare(a, b):\n    \"\"\"\n    Create a function that takes two inputs: 'a' and 'b'. \n    Both inputs can be integers, floats, or strings (containing either characters or numbers).\n\n    If 'a' or 'b' are strings that contain alphabets, convert the strings to lower case if they\n    are upper case, and vice versa. If they contain no alphabets, reverse the string.\n\n    Then, compare 'a' and 'b'. If they represent real numbers (either as a number or a string), \n    return the larger in its original type. If they are equal, return None. If at least one of\n    them does not represent a real numbers, the function returns 'b'.\n\n    Note: Real numbers represented as strings can use either '.' or ',' as the decimal point.\n    \n    Examples:\n    modify_and_compare(\"1234\", \"#a@C\") \u279e \"#A@c\"\n    modify_and_compare(\"AB\", \"ab\") \u279e \"AB\"\n    modify_and_compare(\"5,1\", 6) \u279e 6\n    modify_and_compare(1, \"1\") \u279e None\n    \"\"\"\n\n    def is_real_number(num):\n        try:\n            float(num.replace(',', '.'))\n            return True\n        except ValueError:\n            return False\n\n    def modify_string(string):\n        if string.isalpha():\n            if string.islower():\n                return string.upper()\n            else:\n                return string.lower()\n        else:\n            return string[::-1]\n    if is_real_number(a) and is_real_number(b):\n        if float(a.replace(',', '.')) > float(b.replace(',', '.')):\n            return a\n        elif float(a.replace(',', '.')) < float(b.replace(',', '.')):\n            return b\n        else:\n            return None\n    else:\n        return b", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1, "1"]], "plus_fail_tests": []}], "EvoEval/69": [{"task_id": "EvoEval/69", "solution": "def sorted_happy_strings(lst):\n\n    def is_happy_string(s):\n        if len(s) < 3:\n            return False\n        for i in range(len(s) - 2):\n            if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n                return False\n        return True\n    happy_strings = [s for s in lst if is_happy_string(s) and len(s) % 2 == 0]\n    return sorted(happy_strings, key=lambda x: (len(x), x))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/66": [{"task_id": "EvoEval/66", "solution": "\ndef find_max_triple_sum(x, y, n):\n    largest_even = -1\n    for num in range(x, y + 1):\n        if num % 2 == 0 and num > largest_even:\n            largest_even = num\n    if largest_even == -1:\n        return -1\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    largest_sum = -1\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                triple_sum = a[i] + a[j] + a[k]\n                if triple_sum % 3 == 0 and triple_sum > largest_sum:\n                    largest_sum = triple_sum\n    largest_sum += largest_even\n    return largest_sum", "base_status": "fail", "plus_status": null, "base_fail_tests": [[12, 12, 2]], "plus_fail_tests": []}], "EvoEval/36": [{"task_id": "EvoEval/36", "solution": "\ndef mod_shift_sort(arr, n: int, p: int):\n    if len(arr) == 0:\n        return True\n    arr.sort()\n    num_shifts = pow(2, n, p)\n    return num_shifts >= len(arr)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 4, 5], 0, 101]], "plus_fail_tests": []}], "EvoEval/79": [{"task_id": "EvoEval/79", "solution": "\ndef happy_case_string(s):\n    if len(s) < 3:\n        return s[::-1]\n    happy = True\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            happy = False\n            break\n    if not happy or not any((c.isalpha() for c in s)):\n        return s[::-1]\n    result = ''\n    for c in s:\n        if c.isalpha():\n            if c.islower():\n                result += c.upper()\n            else:\n                result += c.lower()\n        else:\n            result += c\n    return result[::-1]", "base_status": "fail", "plus_status": null, "base_fail_tests": [["adb"]], "plus_fail_tests": []}], "EvoEval/86": [{"task_id": "EvoEval/86", "solution": "\ndef evaluate_common_expressions(operators, operand_lists):\n    common_operands = set(operand_lists[0])\n    for operand_list in operand_lists[1:]:\n        common_operands.intersection_update(operand_list)\n    if len(common_operands) == 0:\n        return None\n    common_operands = sorted(common_operands)\n    expression = str(common_operands[0])\n    for i in range(1, len(common_operands)):\n        expression += ' ' + operators[i - 1] + ' ' + str(common_operands[i])\n    return eval(expression)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/72": [{"task_id": "EvoEval/72", "solution": "\nfrom typing import List\nfrom math import factorial\n\ndef special_close_factorials(numbers: List[int], threshold: int) -> bool:\n    \"\"\" \n    Check if in given list of numbers, are any two special factorials closer to each other than \n    given threshold. The special factorial (Brazilian factorial) is defined as n! * (n-1)! * (n-2)! * ... * 1! \n    where n > 0.\n\n    For example:\n    >>> special_close_factorials([2, 3], 10)\n    False\n    >>> special_close_factorials([1, 2, 3, 4], 100)\n    True\n    \"\"\"\n    factorials = [factorial(n) for n in numbers]\n    factorials.sort()\n    for i in range(len(factorials) - 1):\n        if factorials[i + 1] - factorials[i] < threshold:\n            return True\n    return False", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 4], 100]], "plus_fail_tests": []}], "EvoEval/4": [{"task_id": "EvoEval/4", "solution": "\ndef largest_prime_divisor_digit_sum(lst: list) -> int:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def digit_sum(n: int) -> int:\n        return sum((int(digit) for digit in str(n)))\n    largest_prime_divisor_sum = 0\n    for num in lst:\n        largest_prime_divisor = 0\n        for i in range(2, num):\n            if num % i == 0 and is_prime(i):\n                largest_prime_divisor = max(largest_prime_divisor, i)\n        if largest_prime_divisor == 0:\n            largest_prime_divisor_sum += digit_sum(num)\n        else:\n            largest_prime_divisor_sum += digit_sum(largest_prime_divisor)\n    return largest_prime_divisor_sum", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[84, 91, 97, 101, 105]]], "plus_fail_tests": []}], "EvoEval/48": [{"task_id": "EvoEval/48", "solution": "\nfrom typing import List\n\ndef prime_prefixed_strings(strings: List[str], prefix: str) -> List[str]:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    return [s for s in strings if s.startswith(prefix) and is_prime(len(s))]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/45": [{"task_id": "EvoEval/45", "solution": "\nfrom typing import List, Tuple\n\ndef primes_sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"For a given list of integers, return a tuple consisting of a sum and a product of all the prime numbers in the list.\n    Empty sum should be equal to 0 and empty product should be equal to 1. Non-prime numbers should be ignored.\n    \"\"\"\n    prime_sum = 0\n    prime_product = 1\n    for num in numbers:\n        if is_prime(num):\n            prime_sum += num\n            prime_product *= num\n    return (prime_sum, prime_product)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[5, 25]]], "plus_fail_tests": []}], "EvoEval/38": [{"task_id": "EvoEval/38", "solution": "\ndef even_odd_zero_sum(l, n):\n    \"\"\"\n    even_odd_zero_sum takes a list of integers `l` and a positive integer `n` as inputs.\n    \n    It first calculates the number of even and odd integer palindromes that fall within the range(1, n), inclusive.\n    \n    It then checks if there are two distinct elements in the list `l` that sum to either of the two numbers obtained from the previous step.\n    \n    The function should return a tuple of two booleans. The first boolean indicates whether there are two distinct elements in the list `l` that sum to the number of even palindromes, and the second boolean indicates the same for odd palindromes.\n \n    Example:\n        Input: l = [1, 3, -2, -3, -1, 5, -2], n = 10\n        Output: (True, False)\n        Explanation:\n        Integer palindromes within the range (1, 10) are 1, 2, 3, 4, 5, 6, 7, 8, 9. There are 4 even palindromes and 5 odd palindromes.\n        In the list `l`, there are two distinct elements that sum to 4 (3, 1) but there are no two distinct elements that sum to 5.\n        \n    Note:\n        1. 1 <= n <= 10^3\n        2. List `l` can contain both positive and negative integers.\n        3. Distinct elements mean that the same element cannot be used twice to make the sum.\n    \"\"\"\n    even_palindromes = 0\n    odd_palindromes = 0\n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                even_palindromes += 1\n            else:\n                odd_palindromes += 1\n    even_sum_exists = False\n    odd_sum_exists = False\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            if l[i] + l[j] == even_palindromes:\n                even_sum_exists = True\n            if l[i] + l[j] == odd_palindromes:\n                odd_sum_exists = True\n    return (even_sum_exists, odd_sum_exists)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/18": [{"task_id": "EvoEval/18", "solution": "\ndef min_triplets_sum(nums: list):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array of size three. \n\n    If no such sub-array exists, return 0. A sub-array is a contiguous part of an array.\n\n    Examples:\n    min_triplets_sum([2, 3, 4, 1, -7, 4]) == -2   # The sub-array is [1, -7, 4]\n    min_triplets_sum([1, 2, 3, -6, 5, 1, 2]) == -1  # The sub-array is [2, 3, -6]\n    min_triplets_sum([2, 3]) == 0   # No such sub-array exists\n    min_triplets_sum([-1, -2, -3]) == -6   # The sub-array is [-1, -2, -3]\n    \"\"\"\n    if len(nums) < 3:\n        return 0\n    min_sum = float('inf')\n    for i in range(len(nums) - 2):\n        sub_array = nums[i:i + 3]\n        sub_sum = sum(sub_array)\n        min_sum = min(min_sum, sub_sum)\n    return min_sum", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/53": [{"task_id": "EvoEval/53", "solution": "\ndef hex_grade_calculator(grades):\n    prime_grades = ['D', 'B', '7', '5', '3']\n    count = 0\n    for gpa in grades:\n        if gpa >= 4.0:\n            grade = 'F'\n        elif gpa > 3.7:\n            grade = 'E'\n        elif gpa > 3.3:\n            grade = 'D'\n        elif gpa > 3.0:\n            grade = 'C'\n        elif gpa > 2.7:\n            grade = 'B'\n        elif gpa > 2.3:\n            grade = 'A'\n        elif gpa > 2.0:\n            grade = '9'\n        elif gpa > 1.7:\n            grade = '8'\n        elif gpa > 1.3:\n            grade = '7'\n        elif gpa > 1.0:\n            grade = '6'\n        elif gpa > 0.7:\n            grade = '5'\n        elif gpa > 0.0:\n            grade = '4'\n        else:\n            grade = '3'\n        if grade in prime_grades:\n            count += 1\n    return count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/12": [{"task_id": "EvoEval/12", "solution": "\ndef grade_students(student_info, n):\n    grades = {4.0: 'A+', 3.7: 'A', 3.3: 'A-', 3.0: 'B+', 2.7: 'B', 2.3: 'B-', 2.0: 'C+', 1.7: 'C', 1.3: 'C-', 1.0: 'D+', 0.7: 'D', 0.0: 'D-', -1.0: 'E'}\n\n    def count_consonants(name):\n        consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n        return sum((1 for char in name if char in consonants))\n    result = []\n    for student in student_info:\n        name = student['name']\n        gpa = student['GPA']\n        consonant_count = count_consonants(name)\n        if consonant_count == n:\n            gpa = min(4.0, gpa + 0.3)\n        grade = grades[gpa]\n        result.append({'name': name, 'grade': grade})\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[{"name": "Alice", "GPA": 3.0}, {"name": "Bob", "GPA": 2.3}, {"name": "Charlie", "GPA": 3.3}, {"name": "Dave", "GPA": 0.0}, {"name": "Eve", "GPA": 0.0}], 2]], "plus_fail_tests": []}], "EvoEval/80": [{"task_id": "EvoEval/80", "solution": "def cyclic_encode_delete(s: str, c: str) -> tuple:\n\n    def encode(s):\n        return ''.join((s[i:i + 3][j] for j in range(3) for i in range(0, len(s), 3) if i + j < len(s)))\n\n    def decode(s):\n        return ''.join((s[i // 3 + i % 3] for i in range(len(s))))\n    encoded_s = encode(s)\n    filtered_s = ''.join((char for char in encoded_s if char not in c))\n    if filtered_s == filtered_s[::-1]:\n        return (filtered_s, True)\n    else:\n        decoded_s = decode(filtered_s)\n        return (decoded_s, False)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["abceedcba", "ab"]], "plus_fail_tests": []}], "EvoEval/0": [{"task_id": "EvoEval/0", "solution": "def compare_happiness(a, b):\n\n    def is_happy(s):\n        if len(s) < 3:\n            return False\n        for i in range(len(s) - 2):\n            if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n                return False\n        return True\n    if is_happy(a) and is_happy(b):\n        a_num = float(a.replace(',', '.'))\n        b_num = float(b.replace(',', '.'))\n        if a_num > b_num:\n            return a\n        elif b_num > a_num:\n            return b\n        else:\n            return None\n    elif is_happy(a):\n        return a\n    elif is_happy(b):\n        return b\n    else:\n        return None", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/58": [{"task_id": "EvoEval/58", "solution": "def max_freq_and_sum_check(lst, a, b):\n    freq_dict = {}\n    for num in lst:\n        freq_dict[num] = freq_dict.get(num, 0) + 1\n    max_freq = -1\n    for (num, freq) in freq_dict.items():\n        if freq >= num and num > max_freq:\n            max_freq = num\n    if max_freq == -1:\n        return (-1, False)\n    if a == max_freq + b or b == max_freq + a:\n        return (max_freq, True)\n    else:\n        return (max_freq, False)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/64": [{"task_id": "EvoEval/64", "solution": "\ndef modp_prime_numbers(n: int, p: int):\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    modulo_result = pow(2, n, p)\n    primes = [num for num in range(2, modulo_result) if is_prime(num)]\n    return primes", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/25": [{"task_id": "EvoEval/25", "solution": "\nfrom typing import List, Tuple\n\ndef sum_product_triples(n: int) -> Tuple[int, int]:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    triples = [(a[i], a[j], a[k]) for i in range(n) for j in range(i + 1, n) for k in range(j + 1, n) if (a[i] + a[j] + a[k]) % 3 == 0]\n    if not triples:\n        return (0, 1)\n    sum_first_elements = sum((triple[0] for triple in triples))\n    product_first_elements = 1\n    for triple in triples:\n        product_first_elements *= triple[0]\n    return (sum_first_elements, product_first_elements)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/65": [{"task_id": "EvoEval/65", "solution": "\ndef modp_largest_divisor(n: int, p: int) -> int:\n    \"\"\"Return the largest number smaller than 'p' which divides (2^n modulo p) evenly. \n    If no such number exists, return 1.\n    \n    >>> modp_largest_divisor(3, 5)\n    3\n    >>> modp_largest_divisor(1101, 101)\n    2\n    >>> modp_largest_divisor(0, 101)\n    1\n    >>> modp_largest_divisor(3, 11)\n    8\n    \"\"\"\n    result = 1\n    mod = pow(2, n, p)\n    for i in range(2, p):\n        if mod % i == 0:\n            result = i\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[99999999, 100000000]], "plus_fail_tests": []}], "EvoEval/17": [{"task_id": "EvoEval/17", "solution": "\ndef fibfib_search(n: int, lst: list) -> int:\n\n    def fibfib(m: int) -> int:\n        if m == 0 or m == 1:\n            return 0\n        elif m == 2:\n            return 1\n        else:\n            return fibfib(m - 1) + fibfib(m - 2) + fibfib(m - 3)\n    fibfib_n = fibfib(n)\n    freq_dict = {}\n    for num in lst:\n        if num > 0:\n            freq_dict[num] = freq_dict.get(num, 0) + 1\n    max_num = -1\n    for (num, freq) in freq_dict.items():\n        if freq >= fibfib_n and num > max_num:\n            max_num = num\n    return max_num", "base_status": "fail", "plus_status": null, "base_fail_tests": [[100, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]], "plus_fail_tests": []}]}}