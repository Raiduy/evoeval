{"eval": {"EvoEval/16": [{"task_id": "EvoEval/16", "solution": "def fibonacci_sum(n):\n    \"\"\"\n    Given a positive integer n, return the sum of the first n numbers in the Fibonacci sequence.\n    The Fibonacci sequence is a series of numbers where a number is the sum of the two preceding ones, starting with 0 and 1.\n    \n    >>> fibonacci_sum(1)\n    0\n    >>> fibonacci_sum(2)\n    1\n    >>> fibonacci_sum(3)\n    2\n    >>> fibonacci_sum(10)\n    88\n    >>> fibonacci_sum(20)\n    10945\n    >>> fibonacci_sum(30)\n    1346268\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        fib_sequence = [0, 1]\n        for i in range(2, n):\n            fib_sequence.append(fib_sequence[i - 1] + fib_sequence[i - 2])\n        return sum(fib_sequence)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/61": [{"task_id": "EvoEval/61", "solution": "def transform_string(s):\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    s = list(s)\n    for i in range(len(s)):\n        if i % 2 != 0 and s[i].isalpha():\n            s[i] = s[i].swapcase()\n        if s[i].lower() in vowels:\n            s[i] = vowels[(vowels.index(s[i].lower()) + 1) % 5]\n            if s[i].isupper():\n                s[i] = s[i].upper()\n        elif s[i].lower() in consonants:\n            s[i] = consonants[(consonants.index(s[i].lower()) - 1) % 21]\n            if s[i].isupper():\n                s[i] = s[i].upper()\n    return ''.join(s)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Hello World"]], "plus_fail_tests": []}], "EvoEval/65": [{"task_id": "EvoEval/65", "solution": "def food_order(menu, order):\n    if not order:\n        return menu\n    for food in order:\n        if 'remove' in order[food]:\n            for ingredient in order[food]['remove']:\n                if ingredient in menu[food]:\n                    menu[food].remove(ingredient)\n        if 'add' in order[food]:\n            for ingredient in order[food]['add']:\n                menu[food].append(ingredient)\n    return menu", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/2": [{"task_id": "EvoEval/2", "solution": "from typing import List, Union\n\ndef encrypt_message(words: List[str], key: Union[str, int]) -> List[Union[str, int]]:\n    if isinstance(key, str):\n        key = sum((ord(c) for c in key))\n    encrypted_words = []\n    for word in words:\n        encrypted_word = ''\n        for char in word.lower():\n            if char.isalpha():\n                encrypted_word += chr((ord(char) - 97 + key) % 26 + 97)\n            else:\n                encrypted_word += char\n        encrypted_words.append(encrypted_word)\n    return encrypted_words", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["ant", "bat", "cat", "dog", "elephant"], -1]], "plus_fail_tests": []}], "EvoEval/78": [{"task_id": "EvoEval/78", "solution": "def find_pattern(mat):\n    n = len(mat)\n    pattern = []\n    for i in range(n):\n        pattern.append(mat[i][i])\n        pattern.append(mat[i][n - i - 1])\n    return pattern", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9]]]], "plus_fail_tests": []}], "EvoEval/74": [{"task_id": "EvoEval/74", "solution": "def cipher_mapping(s, cipher):\n    \"\"\"Given a string 's' and a mapping dictionary 'cipher', your task is to implement \n    a function that returns a new string where each character in 's' has been replaced \n    by its corresponding value in 'cipher'. \n    If a character in 's' does not exist in 'cipher', leave it as it is in the new string.\n    If 's' is an empty string, the function should return an empty string.\n    \n    Examples:\n    cipher_mapping(\"hello world\", {'h':'y', 'e':'u', 'l':'q', 'o':'p', 'w':'j', 'r':'f', 'd':'m'}) \n    ==> 'yuqqp jpfqm'\n    \n    cipher_mapping(\"apple pie\", {'a':'z', 'p':'r', 'l':'m', 'e':'s', 'i':'u'}) \n    ==> 'zrrms rus'\n    \n    cipher_mapping(\"simple test\", {}) \n    ==> 'simple test'\n    \n    cipher_mapping(\"good day\", {'g':'b', 'o':'a', 'd':'t', 'a':'g', 'y':'h'}) \n    ==> 'baat tgh'\n    \"\"\"\n    return ''.join([cipher[c] if c in cipher else c for c in s])", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/47": [{"task_id": "EvoEval/47", "solution": "def recipe_ingredients(recipe, available):\n    \"\"\"Checks if a particular recipe can be cooked with the available ingredients.\n\n    Args:\n        recipe (dict): A dictionary where the keys are the ingredient names and the values are the quantities.\n        available (dict): A dictionary where the keys are the ingredient names and the values are the quantities.\n\n    Returns:\n        bool: True if all ingredients needed for the recipe are available, False otherwise.\n\n    Examples:\n        assert recipe_ingredients({'flour': 200, 'sugar': 100, 'eggs': 2}, {'flour': 500, 'sugar': 100, 'eggs': 2}) == True\n        assert recipe_ingredients({'flour': 200, 'sugar': 100, 'eggs': 2}, {'flour': 100, 'sugar': 50, 'eggs': 1}) == False\n        assert recipe_ingredients({'flour': 200, 'sugar': 100, 'milk': 100}, {'flour': 500, 'sugar': 100, 'eggs': 2}) == False\n        assert recipe_ingredients({}, {'flour': 500, 'sugar': 100, 'eggs': 2}) == True\n    \"\"\"\n    for (ingredient, quantity) in recipe.items():\n        if ingredient not in available or available[ingredient] < quantity:\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/75": [{"task_id": "EvoEval/75", "solution": "def magical_string_transformer(input_str):\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    numbers = '0123456789'\n    punctuation = '!@#$%^&*()-_=+[]{}|;:,.<>?`~'\n    transformed_str = ''\n    for (i, char) in enumerate(input_str):\n        if char.lower() in vowels:\n            transformed_str += vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n        elif char.lower() in consonants:\n            transformed_str += consonants[(consonants.index(char.lower()) + 1) % len(consonants)]\n        elif char in numbers:\n            transformed_str += numbers[(numbers.index(char) + 1) % len(numbers)]\n        elif char in punctuation:\n            if char == '?' and i % 2 == 0:\n                transformed_str += '!'\n            elif char == '!' and i % 2 != 0:\n                transformed_str += '?'\n            else:\n                transformed_str += char\n        else:\n            transformed_str += char\n    return transformed_str", "base_status": "fail", "plus_status": null, "base_fail_tests": [["?!AEIOUaeiou"]], "plus_fail_tests": []}], "EvoEval/32": [{"task_id": "EvoEval/32", "solution": "def playlist_shuffle(playlist: list, seed: int):\n    \"\"\"Return a new playlist order based on a numerical seed.\n\n    Given a list of song titles (strings) as 'playlist' and an odd integer 'seed',\n    implement an algorithm to shuffle the playlist to create a new order.\n    The same seed should always produce the same shuffled playlist.\n\n    The shuffling algorithm should use the seed to produce a series of swaps in the sorted list.\n    To produce the series, start at index 0 and swap with the element\n    at the index `seed % playlist_length`. It's important to note that if a song title contains the word \"Rock\", it should remain unmoved during the swapping process (the swap operation will be skipped). For the next index, update the\n    seed using the formula: seed = (seed * 16807) % 2147483647. Continue this process\n    from the next index until the end of the list. Note that the seed will be updated for every index (swapped or not).\n\n\n    >>> playlist_shuffle([\"One More Time\", \"Around the World\", \"Harder Better Faster Stronger\", \"Technologic\", \"Robot Rock\"], 7)\n    ['Harder Better Faster Stronger', 'One More Time', 'Technologic', 'Around the World', 'Robot Rock']\n    >>> playlist_shuffle([\"Song 2\", \"Parklife\", \"Country House\", \"Song 2\", \"Girls & Boys\"], 3)\n    ['Song 2', 'Parklife', 'Girls & Boys', 'Song 2', 'Country House']\n    \"\"\"\n    playlist_length = len(playlist)\n    for i in range(playlist_length):\n        if 'Rock' not in playlist[i]:\n            swap_index = seed % playlist_length\n            (playlist[i], playlist[swap_index]) = (playlist[swap_index], playlist[i])\n        seed = seed * 16807 % 2147483647\n    return playlist", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["Stairway to Heaven", "Whole Lotta Love", "Kashmir", "Rock and Roll", "D'yer Mak'er", "Immigrant Song", "When the Levee Breaks", "Black Dog", "Good Times Bad Times", "Heartbreaker"], 17]], "plus_fail_tests": []}], "EvoEval/19": [{"task_id": "EvoEval/19", "solution": "def vampires_in_matrix(m: list):\n    \"\"\"\n    vampires_in_matrix takes a 2D list of integers as an input,\n    where 0 represents an empty cell, 1 represents a human, and 2 represents a vampire.\n    The function will return the number of humans that are in danger of being bitten.\n    A human is considered in danger if they share a row or a column with a vampire.\n\n    >>> vampires_in_matrix([[0, 1, 0], [2, 0, 1], [1, 1, 0]])\n    2\n    >>> vampires_in_matrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]])\n    0\n    >>> vampires_in_matrix([[1, 2, 1], [1, 1, 1], [2, 1, 1]])\n    6\n    >>> vampires_in_matrix([[1, 1, 1], [0, 0, 0], [2, 2, 2]])\n    3\n    >>> vampires_in_matrix([[2]])\n    0\n    \"\"\"\n    vampires = []\n    humans = []\n    for i in range(len(m)):\n        for j in range(len(m[i])):\n            if m[i][j] == 2:\n                vampires.append((i, j))\n            elif m[i][j] == 1:\n                humans.append((i, j))\n    in_danger = 0\n    for human in humans:\n        for vampire in vampires:\n            if human[0] == vampire[0] or human[1] == vampire[1]:\n                in_danger += 1\n                break\n    return in_danger", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/40": [{"task_id": "EvoEval/40", "solution": "def potion_mixing(potions, target):\n    potions = [(potion.split()[0], int(potion.split()[1])) for potion in potions]\n    potions.sort(key=lambda x: (x[1], x[0]))\n    result = []\n    for potion in potions:\n        if sum((p[1] for p in result)) + potion[1] <= target:\n            result.append(potion)\n        if sum((p[1] for p in result)) == target:\n            return [p[0] + ' ' + str(p[1]) for p in sorted(result, key=lambda x: (x[1], x[0]))]\n    return []", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["Healing Potion 10", "Strength Potion 5", "Invisibility Potion 7"], 15]], "plus_fail_tests": []}], "EvoEval/10": [{"task_id": "EvoEval/10", "solution": "from typing import List\n\ndef count_animals(animal_string: str) -> List[int]:\n    animal_counts = {'C': 0, 'D': 0, 'B': 0}\n    animal_sounds = {'C': 'meow', 'D': 'woof', 'B': 'chirp'}\n    animal_order = []\n    animal_sounds_count = []\n    animal_string_list = animal_string.split()\n    for animal_sound in animal_string_list:\n        animal = animal_sound[0]\n        sound = animal_sound[1:]\n        if animal in animal_counts and animal_counts[animal] < 2 and (sound == animal_sounds[animal]):\n            animal_counts[animal] += 1\n            if animal not in animal_order:\n                animal_order.append(animal)\n            animal_sounds_count.append(len(sound))\n        if len(animal_order) == 5:\n            break\n    return animal_sounds_count", "base_status": "fail", "plus_status": null, "base_fail_tests": [["C||| D|| B| C| K||| B|||"]], "plus_fail_tests": []}], "EvoEval/96": [{"task_id": "EvoEval/96", "solution": "def get_magic_indices(lst):\n\n    def product_of_digits(n):\n        product = 1\n        n = abs(n)\n        while n > 0:\n            product *= n % 10\n            n //= 10\n        return product\n    magic_indices = []\n    for (i, val) in enumerate(lst):\n        if val % i == 0 and product_of_digits(val) == i:\n            magic_indices.append(i)\n    return magic_indices", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[0, 7, -6, 12, -20, 5, -7]]], "plus_fail_tests": []}], "EvoEval/89": [{"task_id": "EvoEval/89", "solution": "def space_invaders(aliens, ray):\n    \"\"\"\n    A space invader game is being designed. There are n aliens represented by an array where each alien is at a certain position. \n    You are given a ray gun that can destroy an alien at a position in one shot. But the ray gun can also destroy all \n    the aliens in the positions adjacent to it. \n\n    The space_invaders function takes two parameters: an array of integers where each integer represents an alien's position \n    and an integer representing the position to aim the ray gun.\n\n    The function should return an array of the remaining aliens' positions after the ray gun has been fired. \n\n    Assume that the position of aliens and the ray are always positive integers. \n\n    Remember: The ray gun destroys the alien at its aimed position as well as any alien in the adjacent positions. \n    The ray gun does not destroy any aliens that live in odd positions unless they are directly aimed at\n\n    Examples:\n\n    assert space_invaders([1, 2, 3, 4, 5], 3) == [1, 5]\n    assert space_invaders([1, 2, 4, 5, 6], 4) == [1, 2, 5, 6]\n    assert space_invaders([2, 3, 5, 6, 7, 9, 10], 6) == [2, 3, 5, 7, 9, 10]\n    assert space_invaders([1, 2, 3, 5, 6, 7], 1) == [3, 5, 6, 7]\n    \"\"\"\n    aliens = [alien for alien in aliens if alien != ray and alien != ray - 1 and (alien != ray + 1)]\n    aliens = [alien for alien in aliens if alien % 2 == 0 or alien == ray]\n    return aliens", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 4, 5], 3]], "plus_fail_tests": []}], "EvoEval/44": [{"task_id": "EvoEval/44", "solution": "def fairy_tale_transport(q, w, e):\n    \"\"\"\n    In a fairy tale world, three types of magical creatures are there: unicorns, dragons, and griffins. The unicorns can carry 'w' kg, dragons can carry 'e' kg, and griffins can carry 'e' kg of weight. You have a list of weights of different items you want to carry.\n    \n    Write a function that returns True if the combined strength of these magical creatures can carry all the items, and False otherwise. \n\n    The function will take three parameters - a list q of weights of items, an integer w representing the carrying capacity of unicorns, an integer e representing the carrying capacity of dragons and griffins together.\n    \n    Example:\n    fairy_tale_transport([5, 10, 15], 5, 20) \u279e False\n    \n    fairy_tale_transport([10, 20, 30], 5, 10) \u279e False\n\n    fairy_tale_transport([1, 2, 3], 1, 5) \u279e True\n    \n    fairy_tale_transport([5, 10, 15], 15, 15) \u279e True\n    \"\"\"\n    total_weight = sum(q)\n    if total_weight <= w + e:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/63": [{"task_id": "EvoEval/63", "solution": "def create_pyramid(p):\n    \"\"\"\n    Given a positive integer p, your objective is to construct a pyramid. The base of the pyramid has p blocks. \n    The number of blocks in the next layer depends upon whether the number of blocks in the previous layer is even or odd.\n    The rules are as follows:\n        - If the number of blocks in the previous layer is even, the next layer contains 2 blocks less.\n        - If the number of blocks in the previous layer is odd, the next layer contains 3 blocks less.\n    Before the number of blocks in the next layer is less than or equal to zero, the pyramid is complete. Your function should return \n    a list containing the number of blocks in each layer from bottom to top. The element at index i in the list represents \n    the number of blocks in the (i+1)th layer from the bottom. \n\n    Examples:\n    >>> create_pyramid(10)\n    [10, 8, 6, 4, 2]\n    \n    >>> create_pyramid(9)\n    [9, 6, 4, 2]\n    \"\"\"\n    pyramid = []\n    while p > 0:\n        pyramid.append(p)\n        if p % 2 == 0:\n            p -= 2\n        else:\n            p -= 3\n    return pyramid", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/70": [{"task_id": "EvoEval/70", "solution": "def planet_path(planets, path):\n    \"\"\"Given a dictionary of planets where each planet is a key and its value is \n    a list of planets it directly connects to, and a list of planets forming a path, \n    return True if the path between those planets is valid (i.e. each planet connects \n    directly to the next), and False otherwise. If the planet does not exist in the \n    dictionary or the path list is empty, return False.\n\n    Example:\n    planet_path({'a': ['b', 'c'], 'b': ['a', 'c'], 'c': ['a', 'b']}, ['a', 'b', 'c']) \n    returns True\n    planet_path({'a': ['b', 'c'], 'b': ['a', 'c'], 'c': ['a', 'b']}, ['a', 'c', 'b']) \n    returns True\n    planet_path({'a': ['b', 'c'], 'b': ['a', 'c'], 'c': ['a', 'b']}, ['a', 'b', 'a']) \n    returns True\n    planet_path({'a': ['b'], 'b': ['a', 'c'], 'c': ['b']}, ['a', 'c', 'b']) \n    returns False\n    planet_path({'a': ['b'], 'b': ['a', 'c'], 'c': ['b']}, []) \n    returns False\n    planet_path({}, ['a', 'b', 'c']) \n    returns False\n    \"\"\"\n    if not path or len(path) < 2:\n        return False\n    for i in range(len(path) - 1):\n        if path[i + 1] not in planets.get(path[i], []):\n            return False\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"a": ["b"], "b": ["a", "c"], "c": ["b"]}, ["a"]]], "plus_fail_tests": []}], "EvoEval/85": [{"task_id": "EvoEval/85", "solution": "def princess_rescue(coord, grid):\n    (rows, cols) = (len(grid), len(grid[0]))\n    directions = [(0, 1), (1, 0)]\n    queue = deque([(0, 0, 0)])\n    visited = set((0, 0))\n    while queue:\n        (row, col, steps) = queue.popleft()\n        if (row, col) == coord:\n            return steps\n        for (dr, dc) in directions:\n            (nr, nc) = (row + dr, col + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (grid[nr][nc] == 0) and ((nr, nc) not in visited):\n                visited.add((nr, nc))\n                queue.append((nr, nc, steps + 1))\n    return -1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[2, 2], [[0, 0, 0], [0, 1, 0], [0, 0, 0]]]], "plus_fail_tests": []}], "EvoEval/81": [{"task_id": "EvoEval/81", "solution": "def alien_language(word_list, alien_dictionary):\n    \"\"\"\n    An alien civilization has its own dictionary to define the order of their alphabet letters.\n    This dictionary is a string of all lowercase letters from 'a' to 'z' but not \n    necessarily in the English alphabetic order. For example, the alien dictionary may be 'hijklmnopqrstuvwxyzabcdefg'.\n    A word in this alien language is a sequence of characters. \n    You are given a sorted list of words (sorted according to the alien dictionary's order)\n    and the alien dictionary itself.\n    Your task is to verify if the given list of words is sorted correctly in ascending order according to the alien dictionary.\n    If yes, then return \"CORRECT\", otherwise return \"INCORRECT\".\n    If the word list is empty, return \"CORRECT\".\n\n    [input/output] samples:\n    alien_language(['cat', 'dog', 'elephant'], 'abcdefghijklmnopqrstuvwxyz') => \"CORRECT\"\n    alien_language(['apple', 'banana', 'kiwi'], 'zyxwvutsrqponmlkjihgfedcba') => \"INCORRECT\"\n    alien_language(['bee', 'ant', 'cat', 'dog'], 'bacdefghijklmnopqrstuvwxyz') => \"CORRECT\"\n    alien_language([], 'bacdefghijklmnopqrstuvwxyz') => \"CORRECT\"\n    \"\"\"\n    if not word_list:\n        return 'CORRECT'\n    alien_order = {char: index for (index, char) in enumerate(alien_dictionary)}\n    for i in range(1, len(word_list)):\n        word1 = word_list[i - 1]\n        word2 = word_list[i]\n        for j in range(min(len(word1), len(word2))):\n            if alien_order[word1[j]] < alien_order[word2[j]]:\n                break\n            elif alien_order[word1[j]] > alien_order[word2[j]]:\n                return 'INCORRECT'\n            elif j == min(len(word1), len(word2)) - 1 and len(word1) > len(word2):\n                return 'INCORRECT'\n    return 'CORRECT'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/25": [{"task_id": "EvoEval/25", "solution": "def word_frequency_analysis(text: str, word: str):\n    \"\"\"Return the frequency of the given word in a text. Also, return the sentence in which the word appears the most times.\n\n    The function will return a tuple where the first element is the frequency of the word, and the second element is the sentence with the max frequency of the word. If the word is not found in the text, return (0, \"\"). \n\n    Assume that sentences end with a period.\n\n    >>> word_frequency_analysis(\"Hello world. I love this world.\", \"world\")\n    (2, \"Hello world\")\n\n    >>> word_frequency_analysis(\"This is the best day. I love this day because it's sunny.\", \"day\")\n    (2, \"This is the best day\")\n\n    >>> word_frequency_analysis(\"This is a test. Testing is fun.\", \"test\")\n    (1, \"This is a test\")\n\n    >>> word_frequency_analysis(\"Welcome to the world of coding.\", \"python\")\n    (0, \"\")\n    \"\"\"\n    sentences = text.split('.')\n    max_count = 0\n    max_sentence = ''\n    word_count = 0\n    for sentence in sentences:\n        words = sentence.split()\n        count = words.count(word)\n        if count > max_count:\n            max_count = count\n            max_sentence = sentence.strip()\n        word_count += count\n    return (word_count, max_sentence)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Hello world. I love this world.", ""]], "plus_fail_tests": []}], "EvoEval/35": [{"task_id": "EvoEval/35", "solution": "def validate_email_structure(email: str):\n    \"\"\" email is a string.\n    return True if the email has a valid format (i.e., there is exactly one \"@\" character that is not the first or last character \n    and there is at least one \".\" character after the \"@\" character).\n\n    >>> validate_email_structure(\"myemail@\")\n    False\n    >>> validate_email_structure(\"myemail@domain\")\n    False\n    >>> validate_email_structure(\"myemail@domain.com\")\n    True\n    >>> validate_email_structure(\"myemail.domain.com\")\n    False\n    >>> validate_email_structure(\"myemail@domain@domain.com\")\n    False\n    \"\"\"\n    if email.count('@') != 1 or email[0] == '@' or email[-1] == '@':\n        return False\n    if '.' not in email.split('@')[1]:\n        return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/98": [{"task_id": "EvoEval/98", "solution": "def nature_sequence_generator(n, a, b):\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, num):\n            if num % i == 0:\n                return False\n        return True\n    sequence = [a, b]\n    for i in range(2, n):\n        next_num = sequence[i - 1] + sequence[i - 2] + i\n        sequence.append(next_num)\n    for i in range(len(sequence)):\n        if is_prime(sequence[i]):\n            sequence[i] = 'prime'\n    return sequence", "base_status": "fail", "plus_status": null, "base_fail_tests": [[5, 1, 2]], "plus_fail_tests": []}], "EvoEval/26": [{"task_id": "EvoEval/26", "solution": "def pathfinder(maze, start, end):\n    if start == end:\n        return []\n    directions = [(0, 1, 'right'), (0, -1, 'left'), (1, 0, 'down'), (-1, 0, 'up')]\n    queue = deque([(start, [])])\n    visited = set()\n    while queue:\n        (current, path) = queue.popleft()\n        if current == end:\n            return path\n        if current in visited:\n            continue\n        visited.add(current)\n        for direction in directions:\n            (x, y, direction_str) = direction\n            (next_x, next_y) = (current[0] + x, current[1] + y)\n            if 0 <= next_x < len(maze) and 0 <= next_y < len(maze[0]) and (maze[next_x][next_y] == 0):\n                queue.append(((next_x, next_y), path + [direction_str]))\n    return []", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[0, 0, 0], [1, 1, 0], [1, 1, 0]], [0, 0], [2, 2]]], "plus_fail_tests": []}], "EvoEval/22": [{"task_id": "EvoEval/22", "solution": "def galactic_travel(t, v):\n    \"\"\"Given the time (t) in years and average velocity (v) in km/s, calculate the distance traveled in light years in a galaxy far, far away.\n    Assume that 1 light year is approximately 9.461 x 10^12 km.\n\n    >>> galactic_travel(1, 300000)\n    0.9999788605855617\n    \"\"\"\n    t_seconds = t * 365 * 24 * 60 * 60\n    distance_km = v * t_seconds\n    distance_ly = distance_km / (9.461 * 10 ** 12)\n    return distance_ly", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/88": [{"task_id": "EvoEval/88", "solution": "def planet_population(dict_of_planets):\n    result = {}\n    for (planet, features) in dict_of_planets.items():\n        (population, size) = features\n        if population is not None and size is not None and (size != 0):\n            density = round(population / size, 2)\n            result[planet] = density\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/55": [{"task_id": "EvoEval/55", "solution": "def treasure_map(message, shift):\n    encrypted_message = ''\n    for i in range(len(message)):\n        char = message[i]\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            encrypted_message += chr((ord(char) - ascii_offset + shift + i) % 26 + ascii_offset)\n        else:\n            encrypted_message += char\n    return encrypted_message", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/59": [{"task_id": "EvoEval/59", "solution": "def cooking_challenge(ingredient_dict):\n    \"\"\"\n    Given a dictionary where the keys are the main ingredients and the values are the number of recipes you can cook with this ingredient,\n    return a list of tuples where the first element of each tuple is an ingredient and the second is a number of recipes. The list should be \n    sorted in descending order based on the number of recipes. If two ingredients can be used in the same number of recipes, sort them in ascending \n    alphabetical order.\n    The function should return an empty list if the given dictionary is empty.\n    \n    Examples:\n    cooking_challenge({\"Chicken\": 5, \"Beef\": 10, \"Fish\": 2}) should return [('Beef', 10), ('Chicken', 5), ('Fish', 2)].\n    cooking_challenge({\"Tomato\": 10, \"Potato\": 10, \"Onion\": 5}) should return [('Potato', 10), ('Tomato', 10), ('Onion', 5)].\n    cooking_challenge({\"Eggs\": 3, \"Milk\": 0, \"Flour\": 2}) should return [('Eggs', 3), ('Flour', 2), ('Milk', 0)].\n    cooking_challenge({}) should return [].\n    \"\"\"\n    if not ingredient_dict:\n        return []\n    else:\n        sorted_ingredients = sorted(ingredient_dict.items(), key=lambda x: (-x[1], x[0]))\n        return sorted_ingredients", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/31": [{"task_id": "EvoEval/31", "solution": "def unique_paths(m: int, n: int):\n    \"\"\"\n    A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n    The robot can only move either down or right at any point in time. \n    The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n    How many possible unique paths are there from start to finish?\n    >>> unique_paths(3, 2)\n    3\n    >>> unique_paths(7, 3)\n    28\n    >>> unique_paths(3, 3)\n    6\n\n    :param m: the number of rows in the grid\n    :param n: the number of columns in the grid\n    :return: the number of possible unique paths from start to finish\n    \"\"\"\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    for i in range(m):\n        dp[i][0] = 1\n    for j in range(n):\n        dp[0][j] = 1\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[-1][-1]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/24": [{"task_id": "EvoEval/24", "solution": "def alien_language_translator(english_word: str):\n    \"\"\"\n    Assume there is an alien language where each English alphabet is replaced by a unique symbol. \n    In this language, the symbol for 'a' is '+', 'b' is '-', 'c' is '*', 'd' is '/', 'e' is '%', 'f' is '@', 'g' is '!',\n    'h' is '#', 'i' is '$', 'j' is '^', 'k' is '&', 'l' is '(', 'm' is ')', 'n' is '=', 'o' is '?', 'p' is ':',\n    'q' is ';', 'r' is '`', 's' is '~', 't' is '>', 'u' is '<', 'v' is '{', 'w' is '}', 'x' is '[', 'y' is ']', 'z' is '|'.\n    Write a function that translates an English word into this alien language.\n\n    >>> alien_language_translator(\"hello\")\n    '#%((?'\n\n    >>> alien_language_translator(\"alien\")\n    '+($%='\n    \"\"\"\n    alien_dict = {'a': '+', 'b': '-', 'c': '*', 'd': '/', 'e': '%', 'f': '@', 'g': '!', 'h': '#', 'i': '$', 'j': '^', 'k': '&', 'l': '(', 'm': ')', 'n': '=', 'o': '?', 'p': ':', 'q': ';', 'r': '`', 's': '~', 't': '>', 'u': '<', 'v': '{', 'w': '}', 'x': '[', 'y': ']', 'z': '|'}\n    alien_word = ''\n    for char in english_word:\n        alien_word += alien_dict[char]\n    return alien_word", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/83": [{"task_id": "EvoEval/83", "solution": "def reverse_vowels(s):\n    vowels = 'aeiouAEIOU'\n    s = list(s)\n    (i, j) = (0, len(s) - 1)\n    while i < j:\n        if s[i] not in vowels:\n            i += 1\n        elif s[j] not in vowels:\n            j -= 1\n        else:\n            (s[i], s[j]) = (s[j], s[i])\n            i += 1\n            j -= 1\n    return ''.join(s)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/34": [{"task_id": "EvoEval/34", "solution": "def werewolf_transformation(n: int, m: int):\n    transformation_percentages = [0]\n    for i in range(1, n):\n        if i < m:\n            transformation_percentages.append(min(100, transformation_percentages[-1] + 10))\n        elif i == m:\n            transformation_percentages.append(min(100, transformation_percentages[-1] * 2))\n        else:\n            transformation_percentages.append(max(0, transformation_percentages[-1] - 10))\n    return transformation_percentages", "base_status": "fail", "plus_status": null, "base_fail_tests": [[5, 3]], "plus_fail_tests": []}], "EvoEval/57": [{"task_id": "EvoEval/57", "solution": "def magical_cafe(menu, magic_spell):\n    new_menu = {}\n    spell_length = len(magic_spell)\n    for (dish, price) in menu.items():\n        new_dish = ''\n        for i in range(len(dish)):\n            new_dish += magic_spell[i % spell_length]\n        new_menu[new_dish] = price\n    return new_menu", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/94": [{"task_id": "EvoEval/94", "solution": "def spell_casting(spells):\n    result = []\n    for spell in spells:\n        words = spell.split()\n        words.sort(key=len)\n        result.append(' '.join(words))\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/38": [{"task_id": "EvoEval/38", "solution": "def translate_emoticons(sentence):\n    \"\"\"Convert text-based emoticons in a string to their corresponding Unicode emojis and return the result as a string.\n\n    If the sentence doesn't contain any text-based emoticons, return the original sentence.\n    Some examples of text-based emoticons and their corresponding emojis are \":)\" corresponds to \"\ud83d\ude0a\", \n    \":(\" corresponds to \"\u2639\ufe0f\", \":D\" corresponds to \"\ud83d\ude00\", \";)\" corresponds to \"\ud83d\ude09\". \n    \n    Examples:\n    >>> translate_emoticons(\"Hello :) Have a nice day Marcus, how are you? :D\")\n    \"Hello \ud83d\ude0a Have a nice day Marcus, how are you? \ud83d\ude00\"\n    >>> translate_emoticons(\"Oh no, it's raining Marcus, how is the weather? :(\")\n    \"Oh no, it's raining Marcus, how is the weather? \u2639\ufe0f\"\n    >>> translate_emoticons(\"No emoticons here Marcus\")\n    \"No emoticons here Marcus\"\n    \"\"\"\n    emoticons_to_emojis = {':)': '\ud83d\ude0a', ':(': '\u2639\ufe0f', ':D': '\ud83d\ude00', ';)': '\ud83d\ude09'}\n    words = sentence.split()\n    for i in range(len(words)):\n        if words[i] in emoticons_to_emojis:\n            words[i] = emoticons_to_emojis[words[i]]\n    return ' '.join(words)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[";);););););)"]], "plus_fail_tests": []}], "EvoEval/76": [{"task_id": "EvoEval/76", "solution": "def create_pyramid(lst):\n    \"\"\"\n    You are given a list of positive integers. \n    Your task is to create a pyramid out of the numbers, where every level of the pyramid \n    is represented by a string of equal length. The number of characters in a string equals \n    the sum of the positive integers in the corresponding level of the pyramid.\n    The pyramid should be built from the bottom up, i.e. the first element of the list \n    should form the bottom level of the pyramid.\n    Return the pyramid as a list of strings. If the list of integers is empty, return an \n    empty list.\n\n    Note: Use the character '#' to represent the numbers.\n\n    Examples:\n    create_pyramid([3, 2, 1]) == ['#', '##', '###']\n    create_pyramid([5, 4, 2]) == ['##', '####', '#####']\n    create_pyramid([]) == []\n    \"\"\"\n    pyramid = []\n    for num in lst:\n        level = '#' * num\n        pyramid.append(level)\n    return pyramid", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 2, 1]]], "plus_fail_tests": []}], "EvoEval/50": [{"task_id": "EvoEval/50", "solution": "def text_to_morse(text):\n    morse_code_dict = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', ' ': '  '}\n    morse_code = ''\n    for char in text:\n        morse_code += morse_code_dict[char.upper()] + ' '\n    return morse_code.strip()", "base_status": "fail", "plus_status": null, "base_fail_tests": [["HELLO WORLD"]], "plus_fail_tests": []}], "EvoEval/52": [{"task_id": "EvoEval/52", "solution": "def magic_cookie_baker(n, m, orders):\n    \"\"\"\n    You are a magical baker who bakes cookies with an enchanted oven.\n\n    Your oven is special because it can bake exactly n cookies at once, and no more or less. Moreover, you can only bake m batches in a day. \n\n    Given a list of orders in the format of a list of positive integers where each integer represents an order for a specific number of cookies, return the maximum number of orders you can fulfill in a day.\n\n    The function magic_cookie_baker should take three parameters: \n    - n (a positive integer) represents the exact number of cookies your oven can bake at once.\n    - m (a positive integer) represents the maximum number of batches you can bake in a day.\n    - orders (a list of positive integers) represents all the orders for the day.\n\n    The function should assume that:\n    - You can only bake one batch at a time.\n    - You cannot split an order across multiple batches.\n    - You cannot combine multiple orders into a single batch.\n\n    The function should return an integer representing the maximum number of orders you can fulfill in a day.\n\n    Example:\n    assert magic_cookie_baker(3, 2, [4, 6, 8, 10]) == 0\n    assert magic_cookie_baker(5, 3, [7, 9, 11, 13, 15]) == 0\n    assert magic_cookie_baker(2, 4, [2, 4, 6, 8, 10]) == 1\n    assert magic_cookie_baker(1, 1, [1, 2, 3, 4, 5]) == 1\n    assert magic_cookie_baker(4, 2, [3, 5, 7, 9, 11]) == 1\n    \"\"\"\n    orders.sort()\n    fulfilled_orders = 0\n    for order in orders:\n        if order <= n:\n            fulfilled_orders += 1\n            n -= order\n        else:\n            n = m\n        if fulfilled_orders == len(orders) or n == 0:\n            break\n    return fulfilled_orders", "base_status": "fail", "plus_status": null, "base_fail_tests": [[6, 2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]], "plus_fail_tests": []}], "EvoEval/14": [{"task_id": "EvoEval/14", "solution": "def create_alias(name: str) -> str:\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    alias = ''\n    for char in name:\n        if char.lower() in vowels:\n            index = (vowels.index(char.lower()) + 1) % len(vowels)\n            new_char = vowels[index]\n            if char.isupper():\n                new_char = new_char.upper()\n            alias += new_char\n        elif char.lower() in consonants:\n            index = (consonants.index(char.lower()) + 1) % len(consonants)\n            new_char = consonants[index]\n            if char.isupper():\n                new_char = new_char.upper()\n            alias += new_char\n        else:\n            alias += char\n    return alias", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/82": [{"task_id": "EvoEval/82", "solution": "def zodiac_element(birthdays):\n    if not birthdays:\n        return None\n    elements = {'Fire': 0, 'Water': 0, 'Air': 0, 'Earth': 0}\n    zodiac_signs = {'Aries': 'Fire', 'Taurus': 'Earth', 'Gemini': 'Air', 'Cancer': 'Water', 'Leo': 'Fire', 'Virgo': 'Earth', 'Libra': 'Air', 'Scorpio': 'Water', 'Sagittarius': 'Fire', 'Capricorn': 'Earth', 'Aquarius': 'Air', 'Pisces': 'Water'}\n    for birthday in birthdays:\n        date = datetime.strptime(birthday, '%Y-%m-%d')\n        month = date.month\n        day = date.day\n        if month == 3 and day >= 21 or (month == 4 and day <= 19):\n            elements[zodiac_signs['Aries']] += 1\n        elif month == 4 and day >= 20 or (month == 5 and day <= 20):\n            elements[zodiac_signs['Taurus']] += 1\n        elif month == 5 and day >= 21 or (month == 6 and day <= 20):\n            elements[zodiac_signs['Gemini']] += 1\n        elif month == 6 and day >= 21 or (month == 7 and day <= 22):\n            elements[zodiac_signs['Cancer']] += 1\n        elif month == 7 and day >= 23 or (month == 8 and day <= 22):\n            elements[zodiac_signs['Leo']] += 1\n        elif month == 8 and day >= 23 or (month == 9 and day <= 22):\n            elements[zodiac_signs['Virgo']] += 1\n        elif month == 9 and day >= 23 or (month == 10 and day <= 22):\n            elements[zodiac_signs['Libra']] += 1\n        elif month == 10 and day >= 23 or (month == 11 and day <= 21):\n            elements[zodiac_signs['Scorpio']] += 1\n        elif month == 11 and day >= 22 or (month == 12 and day <= 21):\n            elements[zodiac_signs['Sagittarius']] += 1\n        elif month == 12 and day >= 22 or (month == 1 and day <= 19):\n            elements[zodiac_signs['Capricorn']] += 1\n        elif month == 1 and day >= 20 or (month == 2 and day <= 18):\n            elements[zodiac_signs['Aquarius']] += 1\n        elif month == 2 and day >= 19 or (month == 3 and day <= 20):\n            elements[zodiac_signs['Pisces']] += 1\n    return {k: v for (k, v) in elements.items() if v > 0}", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["2000-03-21", "2001-05-21", "2002-08-23", "2003-02-19"]]], "plus_fail_tests": []}], "EvoEval/62": [{"task_id": "EvoEval/62", "solution": "def recipe_converter(recipe, conversion_factor):\n    \"\"\"\n    Write a function that takes a dictionary representing a recipe as input \n    where the keys are the ingredients and the values are the quantities \n    needed for one serving. The function should also take a conversion factor \n    which represents the number of servings required. The function should \n    return a new dictionary where the quantities of each ingredient are \n    multiplied by the conversion factor.\n\n    The quantities in the recipe are integers and the conversion factor is a \n    positive integer. \n\n    Examples:\n    >>> recipe_converter({\"flour\": 500, \"sugar\": 200, \"eggs\": 3}, 2)\n    {'flour': 1000, 'sugar': 400, 'eggs': 6}\n    >>> recipe_converter({\"milk\": 250, \"chocolate\": 75, \"butter\": 50}, 3)\n    {'milk': 750, 'chocolate': 225, 'butter': 150}\n    \"\"\"\n    return {ingredient: quantity * conversion_factor for (ingredient, quantity) in recipe.items()}", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/13": [{"task_id": "EvoEval/13", "solution": "\nfrom typing import List\n\ndef find_rarest_element(elems: List[str]) -> str:\n    \"\"\" Find the rarest element in a list of strings. If there are multiple rarest elements, return the one that appears first. \n    If the list is empty, return None.\n\n    >>> find_rarest_element(['apple', 'banana', 'apple', 'orange', 'banana', 'orange', 'apple'])\n    'banana'\n    >>> find_rarest_element(['cat', 'dog', 'bird', 'cat', 'dog', 'cat'])\n    'bird'\n    >>> find_rarest_element([])\n    None\n    \"\"\"\n    if not elems:\n        return None\n    count_dict = {}\n    for elem in elems:\n        if elem in count_dict:\n            count_dict[elem] += 1\n        else:\n            count_dict[elem] = 1\n    min_count = min(count_dict.values())\n    rarest_elems = [k for (k, v) in count_dict.items() if v == min_count]\n    for elem in elems:\n        if elem in rarest_elems:\n            return elem", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/91": [{"task_id": "EvoEval/91", "solution": "def spaceship_trajectory(spaceship_data):\n    status = 'On Ground'\n    for (action, distance) in spaceship_data:\n        if action == 'Launch' and status == 'On Ground':\n            status = 'In Space'\n        elif action == 'Move' and status == 'In Space':\n            continue\n        elif action == 'Land' and status == 'In Space':\n            status = 'On Ground'\n        else:\n            return 'Invalid Action Sequence'\n    return status", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/92": [{"task_id": "EvoEval/92", "solution": "def paint_fountain(n):\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    fountain = []\n    for i in range(n):\n        letter = alphabet[i % 26]\n        width = 2 * (i + 1) - 1\n        layer = letter * width\n        layer = layer.center(2 * n - 1)\n        fountain.append(layer)\n    return '\\n'.join(fountain)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[3]], "plus_fail_tests": []}], "EvoEval/71": [{"task_id": "EvoEval/71", "solution": "def letter_shift_cipher(s, n):\n    vowels = 'aeiou'\n    vowel_count = 0\n    result = ''\n    for char in s:\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            new_char = chr((ord(char) - ascii_offset + n) % 26 + ascii_offset)\n            result += new_char\n            if new_char.lower() in vowels:\n                vowel_count += 1\n        else:\n            result += char\n    return (result, vowel_count)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/67": [{"task_id": "EvoEval/67", "solution": "def meal_calculator(customers, meals):\n    result = {}\n    for customer in customers:\n        if customer in meals:\n            total_calories = sum((meal['calories'] for meal in meals[customer]))\n            result[customer] = total_calories\n        else:\n            result[customer] = 0\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/15": [{"task_id": "EvoEval/15", "solution": "def evaluate_poker_hand(hand: list):\n    \"\"\" \n    Evaluate a poker hand and return its score.\n\n    In this game, we use the following point scoring rules:\n\n    1. Each card has a value (A=1, 2-10 = card number, J=11, Q=12, K=13)\n    2. A 'pair' (two cards of the same value) scores the value of the card.\n    3. A 'triple' (three cards of the same value) scores double the value of the card.\n    4. A 'four of a kind' (four cards of the same value) scores triple the value of the card.\n    5. A 'five of a kind' (five cards of the same value) scores quadruple the value of the card.\n    6. If hand has no pairs, triples or fours, score is 0\n\n    Note, you should consider all cards in hand, i.e., if there are both pair and triple, score should be score or pair + score of triple.\n\n    The \"hand\" list contains 5 strings, each representing a card in the format 'value+suit'\n    (i.e. ['10H', '10D', '10C', '2S', '2D']). The suit is irrelevant for this game.\n\n    >>> evaluate_poker_hand(['5H', '5D', '5S', '9C', '9D'])\n    19\n    >>> evaluate_poker_hand(['AS', '2H', '3S', '4H', '5D'])\n    0\n    >>> evaluate_poker_hand(['KH', 'KD', 'KS', 'KC', 'KA'])\n    52\n    \"\"\"\n    card_counts = {}\n    for card in hand:\n        value = card[:-1]\n        if value in card_counts:\n            card_counts[value] += 1\n        else:\n            card_counts[value] = 1\n    score = 0\n    for count in card_counts.values():\n        if count == 2:\n            score += int(value) * 2\n        elif count == 3:\n            score += int(value) * 3\n        elif count == 4:\n            score += int(value) * 4\n        elif count == 5:\n            score += int(value) * 5\n    return score", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["5H", "5D", "5S", "9C", "9D"]]], "plus_fail_tests": []}], "EvoEval/42": [{"task_id": "EvoEval/42", "solution": "def find_legendary_item(player_input):\n    \"\"\"\n    In a popular multiplayer online game, players can acquire various items. Each item has a rarity value \n    ranging from 1 (common) to 5 (legendary). In a single game, a player can acquire multiple items but with \n    the condition that the rarity of each item is unique. The player_input is a list representing the items \n    acquired by a player in a single game, where each item is represented by its rarity.\n    \n    Your task is to write a function that determines if the player has acquired a legendary item (rarity 5) \n    in the game. The function should return True if a legendary item has been acquired and False otherwise. \n\n    Further, if a legendary item has been acquired, the function should return the rarity of the second most \n    valuable item that the player has acquired. If the player has only acquired the legendary item, return -1.\n\n    The function should be able to handle player_input lists of any length.\n\n    Examples:\n        find_legendary_item([1, 2, 3, 4, 5]) == (True, 4)\n        find_legendary_item([5]) == (True, -1)\n        find_legendary_item([1, 3, 4]) == (False, None)\n        find_legendary_item([]) == (False, None)\n    \"\"\"\n    if 5 in player_input:\n        if len(player_input) == 1:\n            return (True, -1)\n        else:\n            player_input.remove(5)\n            return (True, max(player_input))\n    else:\n        return (False, None)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/90": [{"task_id": "EvoEval/90", "solution": "def magical_multiply(s1, s2):\n    \"\"\"\n    In the mystical land of Pyth, numbers behave quite differently. Here, when two numbers are multiplied, the result is given by the sum of all possible unique combinations of their digits. \n\n    For example, if two numbers 24 and 13 are multiplied, the result would be the sum of all unique combinations of digits (2, 4) and (1, 3). The combinations would be (2, 1), (2, 3), (4, 1) and (4, 3) and their sums would be 3, 5, 5 and 7, and hence the result of the multiplication would be 3 + 5 + 5 + 7 = 20.\n\n    The function magical_multiply(s) would take in two positive integers as input (in string format) and should return their product according to the laws of the land of Pyth.\n\n    For example:\n    >>> magical_multiply('24', '13')\n    20\n    >>> magical_multiply('56', '79')\n    54\n    \"\"\"\n    digits1 = list(map(int, s1))\n    digits2 = list(map(int, s2))\n    sum_of_combinations = 0\n    for digit1 in digits1:\n        for digit2 in digits2:\n            sum_of_combinations += digit1 + digit2\n    return sum_of_combinations", "base_status": "fail", "plus_status": null, "base_fail_tests": [["999", "999"]], "plus_fail_tests": []}], "EvoEval/33": [{"task_id": "EvoEval/33", "solution": "def magical_staircase(n: int, magic_stones: list):\n    \"\"\"\n    Imagine a magical staircase with 'n' steps, and a collection of magic stones. Each magic stone has a unique power\n    that allows the user to jump a certain number of steps in a single bound.\n    For example, if there's a magic stone that has a power of 2, you can jump 2 steps at once instead of 1 step.\n\n    Provided with the number of steps 'n' and a list of the powers of magic stones available, \n    return the number of distinct ways you can reach the top of the staircase. Assume you start from the bottom of the staircase.\n\n    The magic_stones list contains positive integers, and n is a positive integer.\n\n    Example:\n    >>> magical_staircase(4, [1, 2])\n    5\n    Explanation: There are 5 distinct ways to reach the top of the staircase:\n    - Jump 1 step, jump 1 step, jump 1 step, jump 1 step\n    - Jump 1 step, jump 1 step, jump 2 steps\n    - Jump 1 step, jump 2 steps, jump 1 step\n    - Jump 2 steps, jump 1 step, jump 1 step\n    - Jump 2 steps, jump 2 steps\n\n    >>> magical_staircase(10, [1, 2, 5])\n    128\n    Explanation: There are 128 distinct ways to reach the top of the staircase.\n    \"\"\"\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for stone in magic_stones:\n            if i - stone >= 0:\n                dp[i] += dp[i - stone]\n    return dp[n]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/84": [{"task_id": "EvoEval/84", "solution": "def tree_traversal(tree, path=None):\n    if path is None:\n        path = []\n    for (node, children) in tree.items():\n        new_path = path + [node]\n        if children:\n            for p in tree_traversal(children, new_path):\n                yield p\n        else:\n            yield new_path", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"1": {"2": {"4": {}, "5": {}}, "3": {"6": {}, "7": {}}}}]], "plus_fail_tests": []}], "EvoEval/37": [{"task_id": "EvoEval/37", "solution": "def string_transform(s):\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    transformed_s = ''\n    for char in s:\n        if char.lower() in vowels:\n            if char.isupper():\n                transformed_s += vowels[(vowels.index(char.lower()) + 1) % len(vowels)].upper()\n            else:\n                transformed_s += vowels[(vowels.index(char) + 1) % len(vowels)]\n        elif char.lower() in consonants:\n            if char.isupper():\n                transformed_s += consonants[(consonants.index(char.lower()) + 1) % len(consonants)].upper()\n            else:\n                transformed_s += consonants[(consonants.index(char) + 1) % len(consonants)]\n        else:\n            transformed_s += char\n    return transformed_s", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/30": [{"task_id": "EvoEval/30", "solution": "from typing import List, Tuple\n\ndef find_path(maze: List[List[int]], start: Tuple[int], end: Tuple[int]) -> List[Tuple[int]]:\n    (rows, cols) = (len(maze), len(maze[0]))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(start, [start])])\n    visited = set(start)\n    while queue:\n        (current, path) = queue.popleft()\n        if current == end:\n            return path\n        for direction in directions:\n            (next_row, next_col) = (current[0] + direction[0], current[1] + direction[1])\n            if 0 <= next_row < rows and 0 <= next_col < cols and (maze[next_row][next_col] == 1) and ((next_row, next_col) not in visited):\n                queue.append(((next_row, next_col), path + [(next_row, next_col)]))\n                visited.add((next_row, next_col))\n    return []", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[1, 0, 1, 1, 1], [1, 0, 1, 0, 1], [1, 1, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]], [0, 0], [4, 4]]], "plus_fail_tests": []}], "EvoEval/21": [{"task_id": "EvoEval/21", "solution": "def crossword_validator(grid: list, words: list):\n    \"\"\"\n    Consider a 2D grid representing a square crossword puzzle. Each cell of the grid contains a single character.\n\n    Determine if all the words from a provided list of words can be found in the grid.\n    Words can be found left-to-right (in a row), right-to-left (in a row),\n    top-to-bottom down (in a column), and bottom-to-top (in a column).\n\n    We assume that words are only found in contiguous cells and words do not 'wrap' around the grid.\n\n    Note: the grid is a square (N x N) and all words are lowercase.\n\n    Parameters:\n    grid: list of list of char - where each char is a lowercase letter.\n    words: list of str - where each str is a lowercase word.\n\n    Returns:\n    boolean - return True all words are found in the grid, False otherwise.\n\n    >>> crossword_validator([['c', 'a', 't'], ['d', 'o', 'g'], ['d', 'o', 'p']], ['cat', 'dog', 'pop'])\n    False\n    >>> crossword_validator([['c', 'a', 't'], ['d', 'o', 'g'], ['d', 'o', 'p']], ['cdd', 'dog', 'pod'])\n    True\n    \"\"\"\n    grid_rows = [''.join(row) for row in grid]\n    grid_cols = [''.join(col) for col in zip(*grid)]\n    for word in words:\n        if not any((word in row for row in grid_rows)) and (not any((word in col for col in grid_cols))):\n            return False\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[["c", "a", "t"], ["d", "o", "g"], ["d", "o", "p"]], ["cdd", "dog", "pod"]]], "plus_fail_tests": []}], "EvoEval/20": [{"task_id": "EvoEval/20", "solution": "def generate_pattern(n: int):\n    \"\"\"\n    Given an integer 'n', return a list of strings where each string represents a pattern. \n    The pattern is composed of the numbers from 1 to n in ascending order, then descending back to 1, \n    with each number separated by a comma. If n is 0 or negative, return an empty list.\n\n    >>> generate_pattern(3)\n    ['1', '1,2', '1,2,3', '3,2,1', '2,1', '1']\n\n    >>> generate_pattern(0)\n    []\n    \"\"\"\n    if n <= 0:\n        return []\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append(','.join(map(str, list(range(1, i + 1)))))\n    for i in range(n - 1, 0, -1):\n        pattern.append(','.join(map(str, list(range(i, 0, -1)))))\n    return pattern", "base_status": "fail", "plus_status": null, "base_fail_tests": [[3]], "plus_fail_tests": []}], "EvoEval/97": [{"task_id": "EvoEval/97", "solution": "def alien_invasion(alien, humans):\n    if not isinstance(alien, str) or not isinstance(humans, dict):\n        return []\n    continents = ['Asia', 'Africa', 'Europe', 'North America', 'South America']\n    alien_encounters = []\n    for continent in continents:\n        for (human, continent_residence) in humans.items():\n            if continent_residence == continent:\n                alien_encounters.append(human)\n    return alien_encounters", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/3": [{"task_id": "EvoEval/3", "solution": "from typing import List\n\ndef magical_alphabet(input_string: str) -> List[str]:\n\n    def decode(s: str) -> str:\n        return chr(int(s) + 96)\n\n    def helper(s: str) -> List[str]:\n        if not s:\n            return []\n        elif len(s) == 1:\n            return [decode(s)]\n        else:\n            result = []\n            if s[0] != '0':\n                result += [decode(s[0]) + x for x in helper(s[1:])]\n            if len(s) > 1 and '0' < s[:2] <= '26':\n                result += [decode(s[:2]) + x for x in helper(s[2:])]\n            return result\n    return helper(input_string)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["123"]], "plus_fail_tests": []}], "EvoEval/68": [{"task_id": "EvoEval/68", "solution": "def magical_sorting(arr):\n    if not arr:\n        return True\n    swap_used = False\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            if swap_used:\n                return False\n            else:\n                swap_used = True\n                if i > 0 and arr[i - 1] > arr[i + 1]:\n                    if i + 2 < len(arr) and arr[i] > arr[i + 2]:\n                        return False\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 4, 5, 1, 2]]], "plus_fail_tests": []}], "EvoEval/46": [{"task_id": "EvoEval/46", "solution": "def hidden_message(test_cases):\n    result = []\n    for test_case in test_cases:\n        secret_message = ''.join((word[0] for word in test_case))\n        if secret_message.isalpha():\n            result.append(secret_message.lower())\n        else:\n            result.append('Take the cannoli.')\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[["apple"], ["Banana", "grape", "kiwi", "melon"]]]], "plus_fail_tests": []}], "EvoEval/27": [{"task_id": "EvoEval/27", "solution": "def split_strings(s: str, n: int):\n    \"\"\"Return a list of n-character long strings created from the input string s.\n    If the length of s isn't a multiple of n, the remaining characters are added as the \n    last element of the returned list.\n\n    >>> split_strings('HelloWorld', 3)\n    ['Hel', 'loW', 'orl', 'd']\n    >>> split_strings('CodingIsFun', 5)\n    ['Codin', 'gIsFu', 'n']\n    \"\"\"\n    return [s[i:i + n] for i in range(0, len(s), n)]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/8": [{"task_id": "EvoEval/8", "solution": "def transform_canvas(canvas: str) -> str:\n    if canvas.count('P') != 1:\n        return 'Invalid canvas'\n    painter_index = canvas.index('P')\n    if canvas.count('-') % 2 == 0:\n        return 'Invalid canvas'\n    canvas_list = list(canvas)\n    for i in range(painter_index + 1, len(canvas_list)):\n        if canvas_list[i] == '-':\n            canvas_list[i] = '*'\n        elif canvas_list[i] == '#':\n            break\n    for i in range(painter_index - 1, -1, -1):\n        if canvas_list[i] == '-':\n            canvas_list[i] = '*'\n        elif canvas_list[i] == '#':\n            break\n    return ''.join(canvas_list)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["--#-P#-----#-----#--#--"]], "plus_fail_tests": []}], "EvoEval/23": [{"task_id": "EvoEval/23", "solution": "def prime_cipher(s: str):\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103]\n    result = ''\n    for char in s:\n        if char.islower():\n            result += str(primes[ord(char) - ord('a')])\n        else:\n            result += char\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/11": [{"task_id": "EvoEval/11", "solution": "from typing import List\n\ndef fruity_messages(fruits: List[str], location: str) -> str:\n    if len(fruits) == 1:\n        return f'Oh, are those {fruits[0]} from {location}? Marvelous!'\n    elif len(fruits) == 2:\n        return f'Oh, are those {fruits[0]} and {fruits[1]} from {location}? Marvelous!'\n    else:\n        return f\"Oh, are those {', '.join(fruits[:-1])}, and {fruits[-1]} from {location}? Marvelous!\"", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["strawberries", "pineapples", "kiwis", "guavas", "papayas", "peaches", "grapes", "oranges", "apples"], "California"]], "plus_fail_tests": []}], "EvoEval/95": [{"task_id": "EvoEval/95", "solution": "def matrixMystery(m):\n    if len(m) != len(m[0]):\n        return 'Invalid Matrix'\n    sum1 = 0\n    sum2 = 0\n    for i in range(len(m)):\n        sum1 += m[i][i]\n        sum2 += m[i][len(m) - i - 1]\n    return abs(sum1 - sum2)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/1": [{"task_id": "EvoEval/1", "solution": "from typing import List, Union\n\ndef calculate_shipping_cost(items: List[Union[str, float]], location: str) -> float:\n    BASE_COST = 5.0\n    ADDITIONAL_COST = 10.0\n    total_cost = 0.0\n    for item in items:\n        if isinstance(item, str):\n            weight = 1.0\n        else:\n            weight = item\n        total_cost += BASE_COST\n        if weight > 5.0:\n            total_cost += ADDITIONAL_COST\n    if location == 'Local':\n        pass\n    elif location == 'National':\n        total_cost *= 1.5\n    elif location == 'International':\n        total_cost *= 2.5\n    return round(total_cost, 2)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/6": [{"task_id": "EvoEval/6", "solution": "from typing import List, Tuple\n\ndef minesweeper_clicked(grid: List[List[int]], position: Tuple[int, int]) -> List[List[int]]:\n    (x, y) = position\n    if x < 0 or y < 0 or x >= len(grid) or (y >= len(grid[0])):\n        return grid\n    if grid[x][y] == 1:\n        return grid\n    if grid[x][y] == 0:\n        for i in range(x - 1, x + 2):\n            for j in range(y - 1, y + 2):\n                if i >= 0 and j >= 0 and (i < len(grid)) and (j < len(grid[0])):\n                    grid[i][j] = 0\n    return grid", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[0, 1, -1], [1, -1, 0], [0, 1, 1]], [1, 2]]], "plus_fail_tests": []}], "EvoEval/29": [{"task_id": "EvoEval/29", "solution": "def find_palindrome_substrings(s: str):\n    \"\"\"\n    Given a string, find all unique substrings that are palindromes.\n    \n    A palindrome is a word, number, phrase, or other sequence of characters that reads the same forward and backward, ignoring spaces, punctuation, and capitalization.\n    \n    Return a list of all unique palindrome substrings, sorted in ascending order.\n\n    >>> find_palindrome_substrings('racecar')\n    ['a', 'aceca', 'c', 'cec', 'e', 'r', 'racecar']\n\n    >>> find_palindrome_substrings('madam')\n    ['a', 'ada', 'd', 'm', 'madam']\n\n    >>> find_palindrome_substrings('civic')\n    ['c', 'civic', 'i', 'ivi', 'v']\n\n    >>> find_palindrome_substrings('hello')\n    ['e', 'h', 'l', 'll', 'o']\n\n    >>> find_palindrome_substrings('hannah')\n    ['a', 'anna', 'h', 'hannah', 'n', 'nn']\n    \"\"\"\n    s = s.lower()\n    palindromes = set()\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if substring == substring[::-1]:\n                palindromes.add(substring)\n    return sorted(list(palindromes))", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Aibohphobia"]], "plus_fail_tests": []}], "EvoEval/43": [{"task_id": "EvoEval/43", "solution": "def space_travel(distance, speed, fuel, planet_gravity, spaceship_weight):\n    \"\"\"\n    Given the distance of a planet from Earth in light years, the speed of the spaceship in light years per year, the amount of fuel in the spaceship in years, the gravity of the planet and the weight of the spaceship.\n    Fuel consumption is computed as spaceship_weight * planet_gravity * 0.1 per year.\n    Return the remaining fuel rounded to 2 decimal points once the spaceship reaches the planet, if it is possible for the spaceship to reach the planet.\n    Otherwise, return 'Insufficient fuel'.\n    The spaceship can reach the planet if the amount of fuel is greater than or equal to the duration of the trip (distance divided by speed).\n    The remaining fuel is calculated by subtracting the fuel consumption of the trip from the initial amount of fuel.\n    Note: The spaceship travels at a constant speed and the fuel consumption is constant unless otherwise mentioned.\n\n    Example:\n    space_travel(4.22, 0.5, 10, 9.8, 100) returns 'Insufficient fuel'\n    space_travel(2.5, 1, 2, 3.7, 1.5) returns 0.61\n    \"\"\"\n    trip_duration = distance / speed\n    fuel_consumption = round(spaceship_weight * planet_gravity * 0.1 * trip_duration, 2)\n    if fuel < trip_duration:\n        return 'Insufficient fuel'\n    else:\n        remaining_fuel = round(fuel - fuel_consumption, 2)\n        return remaining_fuel", "base_status": "fail", "plus_status": null, "base_fail_tests": [[4.22, 0.5, 10, 9.8, 100]], "plus_fail_tests": []}], "EvoEval/39": [{"task_id": "EvoEval/39", "solution": "def asciiArt(n, s):\n    top_bottom_row = '*' + '*'.join((n * s for s in s)) + '*'\n    middle_rows = ['*' + '*'.join((n * s for s in s)) + '*' for _ in range(n)]\n    rows = [top_bottom_row] + middle_rows + [top_bottom_row]\n    return '\\n'.join(rows)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1, "abc"]], "plus_fail_tests": []}], "EvoEval/56": [{"task_id": "EvoEval/56", "solution": "def str_to_morse_code(s):\n    morse_code_dict = {'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', 'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', 's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', 'y': '-.--', 'z': '--..'}\n    words = s.split(' ')\n    morse_code_words = []\n    for word in words:\n        morse_code_chars = [morse_code_dict[char] for char in word]\n        morse_code_words.append('/'.join(morse_code_chars))\n    return ' / '.join(morse_code_words)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["hello world"]], "plus_fail_tests": []}], "EvoEval/93": [{"task_id": "EvoEval/93", "solution": "def secret_code(message, n_values):\n    result = ''\n    for i in range(len(message)):\n        char = message[i]\n        if char.isalpha():\n            shift = n_values[i % len(n_values)]\n            if char.isupper():\n                result += chr((ord(char) - 65 + shift) % 26 + 65)\n            else:\n                result += chr((ord(char) - 97 + shift) % 26 + 97)\n        else:\n            result += char\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/41": [{"task_id": "EvoEval/41", "solution": "def spider_web_jump(arr):\n    (n, m) = (len(arr), len(arr[0]))\n    visited = [[False] * m for _ in range(n)]\n    heap = [(arr[0][0], 0, 0)]\n    while heap:\n        (energy, x, y) = heapq.heappop(heap)\n        if visited[x][y]:\n            continue\n        visited[x][y] = True\n        if arr[x][y] == 0:\n            return energy\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < n and 0 <= ny < m and (not visited[nx][ny]):\n                heapq.heappush(heap, (energy + arr[nx][ny], nx, ny))\n    return -1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[2, 3], [1, 0]]]], "plus_fail_tests": []}], "EvoEval/49": [{"task_id": "EvoEval/49", "solution": "def morse_decoder(msg):\n    MORSE_CODE_DICT = {'A': '01', 'B': '1000', 'C': '1010', 'D': '100', 'E': '0', 'F': '0010', 'G': '110', 'H': '0000', 'I': '00', 'J': '0111', 'K': '101', 'L': '0100', 'M': '11', 'N': '10', 'O': '111', 'P': '0110', 'Q': '1101', 'R': '010', 'S': '000', 'T': '1', 'U': '001', 'V': '0001', 'W': '011', 'X': '1001', 'Y': '1011', 'Z': '1100', '1': '01111', '2': '00111', '3': '00011', '4': '00001', '5': '00000', '6': '10000', '7': '11000', '8': '11100', '9': '11110', '0': '11111'}\n    REVERSE_MORSE_CODE_DICT = {v: k for (k, v) in MORSE_CODE_DICT.items()}\n    words = msg.split('/')\n    decoded_words = []\n    for word in words:\n        chars = word.split(' ')\n        decoded_chars = []\n        for char in chars:\n            decoded_chars.append(REVERSE_MORSE_CODE_DICT[char])\n        decoded_word = ''.join(decoded_chars)\n        decoded_words.append(decoded_word)\n    decoded_msg = ' '.join(decoded_words)\n    return decoded_msg", "base_status": "fail", "plus_status": null, "base_fail_tests": [["010101/01 1010 0 110 0"]], "plus_fail_tests": []}], "EvoEval/9": [{"task_id": "EvoEval/9", "solution": "\ndef calculate_word_frequency(string: str) -> dict:\n    \"\"\" Given a string, calculate the frequency of each word present in that string (regardless of case) and return a dictionary with words as keys and their frequencies as values. \n    Words are separated by spaces. Ignore punctuation.\n    \n    >>> calculate_word_frequency('Hello, World! Hello Again.')\n    {'hello': 2, 'world': 1, 'again': 1}\n\n    >>> calculate_word_frequency('This is a test. This is only a test.')\n    {'this': 2, 'is': 2, 'a': 2, 'test': 2, 'only': 1}\n    \"\"\"\n    string = re.sub('[^\\\\w\\\\s]', '', string).lower()\n    words = string.split()\n    word_count = Counter(words)\n    return dict(word_count)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Hello, World! Hello Again."]], "plus_fail_tests": []}], "EvoEval/77": [{"task_id": "EvoEval/77", "solution": "def magical_sequence(sequence, k):\n\n    def count_points(num):\n        points = 0\n        while num > 1:\n            num /= k\n            points += 1\n        return points\n    sequence.sort(key=count_points, reverse=True)\n    return sequence", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[8, 5, 3], 2]], "plus_fail_tests": []}], "EvoEval/7": [{"task_id": "EvoEval/7", "solution": "def find_shangri_la(code_sequence: list[int]) -> str:\n    \"\"\"\n    You are an explorer trying to find the mythical city of Shangri-La. According to an ancient text,\n    Shangri-La can be found by following a code sequence of numbers, each referring to the direction to move.\n    The directions correspond to 0: North, 1: East, 2: South, 3: West.\n    \n    Implement a function that takes a sequence of numbers as input and returns whether the sequence leads to Shangri-La.\n    Assume starting point is always (0,0). If the sequence leads back to the starting point, it has found Shangri-La and \n    function should return 'Shangri-La found'. Otherwise, return 'Shangri-La not found'.\n    Not moving is considered as not found.\n    \n    Note: Every move is considered as unit = 1.\n\n    Example:\n    >>> find_shangri_la([0, 1, 2, 3])\n    'Shangri-La found'\n    \n    >>> find_shangri_la([0, 1, 0, 3])\n    'Shangri-La not found'\n    \"\"\"\n    (x, y) = (0, 0)\n    for direction in code_sequence:\n        if direction == 0:\n            y += 1\n        elif direction == 1:\n            x += 1\n        elif direction == 2:\n            y -= 1\n        elif direction == 3:\n            x -= 1\n    if x == 0 and y == 0:\n        return 'Shangri-La found'\n    else:\n        return 'Shangri-La not found'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[]]], "plus_fail_tests": []}], "EvoEval/73": [{"task_id": "EvoEval/73", "solution": "def treasure_hunt(grid, bag_capacity):\n    import math\n    total_treasures = 0\n    total_trips = 0\n    for row in grid:\n        total_treasures += sum(row)\n    if total_treasures == 0:\n        return 0\n    else:\n        total_trips = math.ceil(total_treasures / bag_capacity)\n        return total_trips * 2", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/60": [{"task_id": "EvoEval/60", "solution": "def happy_ants(path_length, sugar_locations, ant_positions):\n    sugar_pieces = [0] * path_length\n    for location in sugar_locations:\n        sugar_pieces[location] += 1\n    ants = [0] * path_length\n    for (position, direction) in ant_positions:\n        if direction == 'right':\n            for i in range(position, path_length):\n                if sugar_pieces[i] > 0:\n                    ants[i] += 1\n                    sugar_pieces[i] -= 1\n        else:\n            for i in range(position, -1, -1):\n                if sugar_pieces[i] > 0:\n                    ants[i] += 1\n                    sugar_pieces[i] -= 1\n    return sum(ants)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[3, [2], [[0, "right"], [1, "right"], [2, "left"]]]], "plus_fail_tests": []}], "EvoEval/87": [{"task_id": "EvoEval/87", "solution": "def word_spiral(arr):\n    if not arr:\n        return ''\n    res = []\n    while arr:\n        res.extend(arr.pop(0))\n        if not arr:\n            break\n        for row in arr:\n            res.append(row.pop())\n        res.extend(arr.pop()[::-1])\n        if not arr:\n            break\n        for row in arr[::-1]:\n            res.append(row.pop(0))\n    return ''.join(res)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[["1", "2", "3"], ["4", "5", "6"], ["7", "8", "9"], ["0", "a", "b"], ["c", "d", "e"]]]], "plus_fail_tests": []}], "EvoEval/17": [{"task_id": "EvoEval/17", "solution": "def wizard_battle(dragon_hp: int, wizards: list) -> str:\n    for (wizard, magic_power) in wizards:\n        dragon_hp -= magic_power\n        if dragon_hp <= 0:\n            return wizard\n    return 'The dragon won!'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/5": [{"task_id": "EvoEval/5", "solution": "from typing import List, Tuple\n\n\ndef zigzag_traversal(matrix: List[List[int]]) -> List[int]:\n    if not matrix:\n        return []\n    rows = len(matrix)\n    cols = len(matrix[0])\n    result = []\n    direction = 1\n    for col in range(cols):\n        if direction == 1:\n            for row in range(rows):\n                result.append(matrix[row][col])\n                col += 1\n                if col == cols:\n                    col -= 1\n                    break\n            direction = -1\n        else:\n            for row in range(rows - 1, -1, -1):\n                result.append(matrix[row][col])\n                col += 1\n                if col == cols:\n                    col -= 1\n                    break\n            direction = 1\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[null, 2], [3, 4], [5, 6, 7], [8, 9, 10]]]], "plus_fail_tests": []}], "EvoEval/28": [{"task_id": "EvoEval/28", "solution": "def calculate_progressive_tax(income: float, deductions=0) -> float:\n    taxable_income = income - deductions\n    tax = 0\n    if taxable_income > 130000:\n        tax += (taxable_income - 130000) * 0.3\n        taxable_income = 130000\n    if taxable_income > 60000:\n        tax += (taxable_income - 60000) * 0.25\n        taxable_income = 60000\n    if taxable_income > 10000:\n        tax += (taxable_income - 10000) * 0.15\n    return tax", "base_status": "fail", "plus_status": null, "base_fail_tests": [[55000, 2500]], "plus_fail_tests": []}], "EvoEval/51": [{"task_id": "EvoEval/51", "solution": "def alien_encoding(string, list_of_alphabets):\n    if not list_of_alphabets:\n        return string\n    if not string:\n        return ''\n    result = ''\n    for i in range(len(string)):\n        result += list_of_alphabets[i % len(list_of_alphabets)]\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/69": [{"task_id": "EvoEval/69", "solution": "def magicTrick(cards, magicNumber):\n    for i in range(len(cards)):\n        for j in range(i + 1, len(cards)):\n            if cards[i] * cards[j] == magicNumber:\n                return (i, j)\n    return 'No magic today'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/79": [{"task_id": "EvoEval/79", "solution": "def find_fruitful_days(prices, days):\n    \"\"\"\n    Given a list of prices of a certain fruit and the number of days a vendor has stayed in the market, \n    find the maximum profit that could be made by the vendor if he could buy and sell the fruit only once during his stay.\n\n    The vendor has the ability to know the prices of the fruit in the future. \n    He wants to buy the fruit on one day and sell it on another day that comes after the day he bought the fruit.\n    If he cannot make any profit, return 0.\n\n    Args:\n        prices (list): A list of integers representing the prices of the fruit for each day.\n        days (int): The latest of day the vendor can buy fruits.\n\n    Returns:\n        int: The maximum profit that could be made by the vendor.\n\n    Example:\n\n        Input: prices = [1, 5, 2, 8, 7, 3], days = 5\n        Output: 7 # The vendor buys the fruit on the first day at price 1 and sells it on the fourth day at price 8.\n\n    Constraints:\n        1. 1 <= len(prices) <= 100\n        2. 1 <= days <= len(prices)\n    \"\"\"\n    max_profit = 0\n    min_price = prices[0]\n    for i in range(1, days):\n        if prices[i] < min_price:\n            min_price = prices[i]\n        elif prices[i] - min_price > max_profit:\n            max_profit = prices[i] - min_price\n    return max_profit", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/36": [{"task_id": "EvoEval/36", "solution": "def calculate_integral_coefficients(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return indefinite integral of this polynomial in the same form, with the constant of integration set to zero,\n    i.e. you should generate the coefficients for the polynomial representing the integral of the input polynomial.\n    So for example, if the input is [3, 2, 1], then the output would represent the polynomial 3*x + x^2 + x^3/3\n    >>> calculate_integral_coefficients([3, 2, 1])\n    [0, 3.0, 1.0, 0.3333333333333333]\n    >>> calculate_integral_coefficients([1, 3, 3, 1])\n    [0, 1.0, 1.5, 1.0, 0.25]\n    \"\"\"\n    integral_coefficients = [0]\n    for i in range(len(xs)):\n        integral_coefficients.append(xs[i] / (i + 1))\n    return integral_coefficients", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/86": [{"task_id": "EvoEval/86", "solution": "def sort_movies_by_ratings_and_release_date(movies_dict):\n    sorted_movies = sorted(movies_dict.items(), key=lambda x: (-x[1][0], -x[1][1]))\n    return [movie[0] for movie in sorted_movies]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"Inception": [8.8, "2010"]}]], "plus_fail_tests": []}], "EvoEval/72": [{"task_id": "EvoEval/72", "solution": "def string_fairy_tale(lst):\n    fairy_tales = []\n    for string in lst:\n        name = ''.join(filter(str.isalpha, string))\n        count = sum((c.isdigit() for c in string))\n        fairy_tale = f\"Once upon a time, in a kingdom far away, lived a magical creature with the name of '{name}' who was known for telling {count} tales a day\"\n        fairy_tales.append(fairy_tale)\n    return fairy_tales", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["Dragon123", "Unicorn45"]]], "plus_fail_tests": []}], "EvoEval/4": [{"task_id": "EvoEval/4", "solution": "from typing import List\n\n\ndef candles_relight(candles: List[int]) -> int:\n    if not candles:\n        return 0\n    lit_candles = 1\n    max_height = candles[0]\n    for i in range(1, len(candles)):\n        if candles[i] >= max_height:\n            lit_candles += 1\n            max_height = candles[i]\n    return lit_candles", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 2, 1, 3, 2, 4]]], "plus_fail_tests": []}], "EvoEval/48": [{"task_id": "EvoEval/48", "solution": "def wizard_inventory(inventory_logs):\n    inventory = {}\n    for log in inventory_logs:\n        item = log['item']\n        quantity = log['quantity']\n        if item in inventory:\n            inventory[item] += quantity\n        else:\n            inventory[item] = quantity\n        if inventory[item] <= 0:\n            del inventory[item]\n    return inventory", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/45": [{"task_id": "EvoEval/45", "solution": "def find_castle(arr):\n    n = len(arr)\n    left = [1] * n\n    right = [1] * n\n    for i in range(1, n):\n        if arr[i] > arr[i - 1]:\n            left[i] = left[i - 1] + 1\n        else:\n            left[i] = 1\n    for i in range(n - 2, -1, -1):\n        if arr[i] > arr[i + 1]:\n            right[i] = right[i + 1] + 1\n        else:\n            right[i] = 1\n    max_hills = 0\n    for i in range(n):\n        max_hills = max(max_hills, left[i] + right[i] - 1)\n    return max_hills", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 2, 5, 3, 6, 4, 8, 2, 7]]], "plus_fail_tests": []}], "EvoEval/58": [{"task_id": "EvoEval/58", "solution": "def interstellar_translator(earth_phrase):\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    translated_phrase = ''\n    for word in earth_phrase.split():\n        translated_word = ''\n        for char in word:\n            if char in vowels:\n                translated_word += vowels[(vowels.index(char) + 1) % len(vowels)]\n            elif char in consonants:\n                translated_word += consonants[(consonants.index(char) + 1) % len(consonants)]\n            elif char == ' ':\n                translated_word += '@'\n        if word[0] in vowels:\n            translated_word += 'xy'\n        else:\n            translated_word += 'yz'\n        translated_phrase += translated_word.capitalize() + ' '\n    return translated_phrase.rstrip()", "base_status": "fail", "plus_status": null, "base_fail_tests": [["hello world"]], "plus_fail_tests": []}], "EvoEval/53": [{"task_id": "EvoEval/53", "solution": "def magical_transformation(s):\n    vowels = 'aeiou'\n    vowels_upper = vowels.upper()\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    consonants_upper = consonants.upper()\n    transformed_s = ''\n    for (i, char) in enumerate(s):\n        if char in vowels:\n            index = vowels.index(char)\n            transformed_s += vowels[(index + 1) % len(vowels)]\n        elif char in vowels_upper:\n            index = vowels_upper.index(char)\n            transformed_s += vowels_upper[(index + 1) % len(vowels_upper)]\n        elif char in consonants:\n            index = consonants.index(char)\n            transformed_s += consonants[(index + 1) % len(consonants)]\n        elif char in consonants_upper:\n            index = consonants_upper.index(char)\n            transformed_s += consonants_upper[(index + 1) % len(consonants_upper)]\n        elif char == '?':\n            if i % 2 == 0:\n                transformed_s += '!'\n            else:\n                transformed_s += '?'\n        else:\n            transformed_s += char\n    return transformed_s", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Hello World???"]], "plus_fail_tests": []}], "EvoEval/99": [{"task_id": "EvoEval/99", "solution": "def musical_chairs(n, rounds, music):\n    players = list(range(1, n + 1))\n    position = 0\n    for r in rounds:\n        position = (position + r * music) % len(players)\n        players.pop(position)\n    return players", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/80": [{"task_id": "EvoEval/80", "solution": "def adventure_game(map, instructions):\n    for i in range(len(map)):\n        for j in range(len(map[i])):\n            if map[i][j] == 'S':\n                pos = [i, j]\n                break\n    path = [(pos[0], pos[1])]\n    for instruction in instructions:\n        if instruction == 'up':\n            if pos[0] > 0 and map[pos[0] - 1][pos[1]] != 'X':\n                pos[0] -= 1\n        elif instruction == 'down':\n            if pos[0] < len(map) - 1 and map[pos[0] + 1][pos[1]] != 'X':\n                pos[0] += 1\n        elif instruction == 'left':\n            if pos[1] > 0 and map[pos[0]][pos[1] - 1] != 'X':\n                pos[1] -= 1\n        elif instruction == 'right':\n            if pos[1] < len(map[0]) - 1 and map[pos[0]][pos[1] + 1] != 'X':\n                pos[1] += 1\n        path.append((pos[0], pos[1]))\n        if map[pos[0]][pos[1]] == 'E':\n            break\n    return path", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[["S", "X", "E"]], ["right", "right"]]], "plus_fail_tests": []}], "EvoEval/0": [{"task_id": "EvoEval/0", "solution": "from typing import List, Union\n\ndef calculate_shipping_cost(items: List[Union[str, float]], location: str) -> float:\n    base_cost = 5.0\n    additional_cost = 10.0\n    total_weight = 0.0\n    has_heavy_item = False\n    has_string_item = False\n    for item in items:\n        if isinstance(item, str):\n            if not has_string_item:\n                base_cost *= 1.5\n                has_string_item = True\n            total_weight += 1.0\n        else:\n            total_weight += item\n            if item > 5.0:\n                has_heavy_item = True\n    total_cost = base_cost * len(items)\n    if has_heavy_item:\n        total_cost += additional_cost\n    if location == 'Local':\n        pass\n    elif location == 'National':\n        total_cost *= 1.5\n    elif location == 'International':\n        total_cost *= 2.5\n    return '{:.2f}'.format(total_cost)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/54": [{"task_id": "EvoEval/54", "solution": "def find_star_map(lst, star):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == star:\n                coordinates.append((i, j))\n    return coordinates", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/12": [{"task_id": "EvoEval/12", "solution": "from typing import List\n\ndef teleporter_energy_signature(flux_values: List[int]) -> int:\n    \"\"\"\n    In the year 7082, teleporters are the primary mode of transportation across cities. Teleporter do\n    not function without a unique energy signature. This unique energy signature is formed by\n    performing certain operations over list of flux values recorded daily.\n\n    Given a list of flux values (integers always >= 0), your task is to determine the unique energy signature \n    by using the following steps:\n    - Find the element with maximum occurrence. If there are multiple, select the smallest one.\n    - Find the sum of all elements in the array.\n    - Multiply the sum of all elements with the most occurred number.\n\n    Return the result.\n\n    >>> teleporter_energy_signature([1, 2, 3, 2, 1, 2, 5, 1, 6])\n    23\n\n    Explanation: The number 2 and 1 appear thrice in the list, but 1 is smaller. \n    The sum of all elements in the array is 23. So, 23 * 1 = 23\n    \"\"\"\n    from collections import Counter\n    counter = Counter(flux_values)\n    max_occurrence = max(counter.values())\n    max_occurrence_numbers = [num for (num, count) in counter.items() if count == max_occurrence]\n    smallest_max_occurrence_number = min(max_occurrence_numbers)\n    sum_of_elements = sum(flux_values)\n    result = sum_of_elements * smallest_max_occurrence_number\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/18": [{"task_id": "EvoEval/18", "solution": "def magical_seven(n: int):\n    \"\"\"\n    magical_seven returns the n-th number that is a multiple of 7 and its digits sum up to 7.\n    \n    >>> magical_seven(1)\n    7\n    >>> magical_seven(2)\n    70\n    >>> magical_seven(3)\n    133\n    >>> magical_seven(4)\n    322\n    >>> magical_seven(5)\n    511\n    \"\"\"\n    count = 0\n    num = 0\n    while count < n:\n        num += 1\n        if num % 7 == 0 and sum((int(digit) for digit in str(num))) == 7:\n            count += 1\n    return num", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/64": [{"task_id": "EvoEval/64", "solution": "def magical_sequence(start, end, divisor):\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    result = []\n    for i in range(start, end + 1):\n        if i % divisor == 0 and is_prime(i):\n            result.append(i)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/66": [{"task_id": "EvoEval/66", "solution": "def prime_anagram_pairs(n):\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_anagram(num1, num2):\n        return sorted(str(num1)) == sorted(str(num2))\n    primes = [num for num in range(2, n + 1) if is_prime(num)]\n    pairs = []\n    for i in range(len(primes)):\n        for j in range(i + 1, len(primes)):\n            if is_anagram(primes[i], primes[j]):\n                pairs.append((primes[i], primes[j]))\n    return pairs", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}]}}