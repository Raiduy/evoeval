{"eval": {"EvoEval/92": [{"task_id": "EvoEval/92", "solution": "\ndef get_common_max_triples(n, l1):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    common = sorted(list(set(a) & set(l1)))\n    count = 0\n    for i in range(len(common)):\n        for j in range(i + 1, len(common)):\n            for k in range(j + 1, len(common)):\n                if (common[i] + common[j] + common[k]) % 3 == 0:\n                    count += 1\n    return (common, count)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[20, [1, 3, 7, 13, 21, 25, 31, 37, 43, 49, 55, 61, 67, 73, 79, 85, 91, 97, 103, 109]]], "plus_fail_tests": []}], "EvoEval/89": [{"task_id": "EvoEval/89", "solution": "\nfrom typing import List\n\ndef md5_substring_filter(strings: List[str], hash_substring: str) -> List[str]:\n    result = []\n    for string in strings:\n        if string:\n            md5_hash = hashlib.md5(string.encode()).hexdigest()\n            if hash_substring in md5_hash:\n                result.append(string)\n    return result if result else None", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["Python", "Hello", "123", ""], "96"]], "plus_fail_tests": []}], "EvoEval/35": [{"task_id": "EvoEval/35", "solution": "def check_dict_happiness(dict):\n\n    def is_happy_string(s):\n        if len(s) < 3:\n            return False\n        for i in range(len(s) - 2):\n            if len(set(s[i:i + 3])) != 3:\n                return False\n        return True\n    if not dict:\n        return False\n    keys = dict.keys()\n    if not all((k.islower() or k.isupper() for k in keys)):\n        return False\n    if not all((is_happy_string(k) for k in keys)):\n        return False\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"aab": "apple", "8": "banana", "a": "apple"}]], "plus_fail_tests": []}], "EvoEval/50": [{"task_id": "EvoEval/50", "solution": "\ndef get_closest_upper_vowel(word):\n    vowels = 'AEIOU'\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels and word[i - 1].isalpha() and word[i + 1].isalpha() and word[i - 1].islower() and word[i + 1].islower():\n            return word[i]\n    return ''", "base_status": "fail", "plus_status": null, "base_fail_tests": [["cAmp"]], "plus_fail_tests": []}], "EvoEval/16": [{"task_id": "EvoEval/16", "solution": "def get_music_notes(word: str, music_string: str):\n    vowels = 'aeiouAEIOU'\n    notes = {'o': 4, 'o|': 2, '.|': 1}\n    result = []\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels and word[i - 1] not in vowels and (word[i + 1] not in vowels):\n            music_notes = music_string.split()\n            for j in range(i, len(word)):\n                result.append(notes[music_notes[j]])\n            break\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["FULL", "o o| .| o| o| .| .| .| .| o o"]], "plus_fail_tests": []}], "EvoEval/38": [{"task_id": "EvoEval/38", "solution": "\ndef even_odd_zero_sum(l, n):\n\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    even_palindromes = [i for i in range(1, n + 1) if is_palindrome(i) and i % 2 == 0]\n    odd_palindromes = [i for i in range(1, n + 1) if is_palindrome(i) and i % 2 != 0]\n    even_sum = len(even_palindromes)\n    odd_sum = len(odd_palindromes)\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            if l[i] + l[j] == even_sum:\n                return (True, False)\n            if l[i] + l[j] == odd_sum:\n                return (False, True)\n    return (False, False)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 3, 2, -3, -1, 5, -2, 14], 101]], "plus_fail_tests": []}], "EvoEval/40": [{"task_id": "EvoEval/40", "solution": "\ndef largest_prime_odd_ends(nums):\n\n    def is_prime(n):\n        if n <= 1 or (n % 2 == 0 and n > 2):\n            return False\n        return all((n % i for i in range(3, int(n ** 0.5) + 1, 2)))\n\n    def is_odd_ends(n):\n        n = abs(n)\n        return int(str(n)[0]) % 2 == 1 and int(str(n)[-1]) % 2 == 1\n    primes = [num for num in nums if num > 10 and is_odd_ends(num) and is_prime(num)]\n    return max(primes) if primes else None", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[51, -73, 14, -15]]], "plus_fail_tests": []}], "EvoEval/44": [{"task_id": "EvoEval/44", "solution": "\nfrom typing import List\n\ndef roman_prefixes(number: int) -> List[str]:\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string in lowercase.\n    Afterwards, return a list of all prefixes of the roman numeral from shortest to longest.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> roman_prefixes(19) == ['x', 'xi', 'xix']\n    >>> roman_prefixes(152) == ['c', 'cl', 'cli', 'clii']\n    >>> roman_prefixes(426) == ['c', 'cd', 'cdx', 'cdxx', 'cdxxv', 'cdxxvi']\n    \"\"\"\n    mapping = [(1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'), (100, 'c'), (90, 'xc'), (50, 'l'), (40, 'xl'), (10, 'x'), (9, 'ix'), (5, 'v'), (4, 'iv'), (1, 'i')]\n    roman = ''\n    for (i, numeral) in mapping:\n        while number >= i:\n            roman += numeral\n            number -= i\n    prefixes = [roman[:i] for i in range(1, len(roman) + 1)]\n    return prefixes", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/22": [{"task_id": "EvoEval/22", "solution": "def binary_planet_distance(planet1, planet2):\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ''\n    else:\n        planet1_index = planets.index(planet1)\n        planet2_index = planets.index(planet2)\n        if planet1_index < planet2_index:\n            planets_between = planets[planet1_index + 1:planet2_index]\n        else:\n            planets_between = planets[planet2_index + 1:planet1_index]\n        binary_string = bin(len(planets_between))[2:]\n        return 'bd' + binary_string + 'bd'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/83": [{"task_id": "EvoEval/83", "solution": "\nimport re\n\n\ndef prime_underscored_length(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with a single underscore (\"-\").\n    \n    After the replacement, check if the length of the new string is a prime number. \n    Return True if it is a prime number, False otherwise. \n\n    prime_underscored_length(\"Example\") == True\n    prime_underscored_length(\"Example 1\") == False\n    prime_underscored_length(\" Example 2\") == False\n    prime_underscored_length(\" Example   3\") == False\n    prime_underscored_length(\" Example    4\") == False\n    \"\"\"\n    text = re.sub('\\\\s{2,}', '_', text)\n    text = text.replace(' ', '_')\n    return is_prime(len(text))", "base_status": "fail", "plus_status": null, "base_fail_tests": [[" Example    4"]], "plus_fail_tests": []}], "EvoEval/32": [{"task_id": "EvoEval/32", "solution": "\nfrom typing import List\n\ndef circular_shift_nested_parens(input: List[str], shift: int) -> List[int]:\n\n    def count_nested_parens(s: str) -> int:\n        max_depth = 0\n        current_depth = 0\n        for char in s:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n        return max_depth\n\n    def circular_shift(num: int, shift: int) -> List[int]:\n        num_str = str(num)\n        if shift > len(num_str):\n            return [int(digit) for digit in reversed(num_str)]\n        else:\n            return [int(digit) for digit in num_str[-shift:] + num_str[:-shift]]\n    depths = [count_nested_parens(s) for s in input]\n    num = int(''.join(map(str, depths)))\n    return circular_shift(num, shift)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/59": [{"task_id": "EvoEval/59", "solution": "def odd_count_base_change(lst, base):\n\n    def base_change(num, base):\n        if num == 0:\n            return '0'\n        nums = []\n        while num:\n            (num, rem) = divmod(num, base)\n            nums.append(str(rem))\n        return ''.join(reversed(nums))\n\n    def count_odd(num):\n        return sum((1 for digit in num if int(digit) % 2 != 0))\n    result = []\n    for (i, num) in enumerate(lst, 1):\n        base_num = base_change(int(num), base)\n        odd_count = count_odd(base_num)\n        result.append(f'the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.')\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["3", "11111111"], 3]], "plus_fail_tests": []}], "EvoEval/91": [{"task_id": "EvoEval/91", "solution": "\ndef sort_prime_even(l: list, x, y):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted. If the sorted element at an even index\n    is prime, replace it with x. Otherwise, replace it with y.\n\n    Examples:\n    sort_prime_even([2, 3, 4, 5, 6], 10, 20) == [10, 3, 20, 5, 20]\n    sort_prime_even([7, 1, 9, 2, 8], 15, 30) == [15, 1, 30, 2, 30]\n    \"\"\"\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    even_indices = [i for i in range(len(l)) if i % 2 == 0]\n    even_values = sorted([l[i] for i in even_indices])\n    for (i, val) in zip(even_indices, even_values):\n        l[i] = x if is_prime(val) else y\n    return l", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/19": [{"task_id": "EvoEval/19", "solution": "from typing import List, Tuple, Optional\n\ndef account_operations(operations: List[int]) -> Tuple[Optional[int], Optional[int], bool]:\n    balance = 0\n    largest_withdrawal = None\n    smallest_deposit = None\n    balance_falls_below_zero = False\n    for operation in operations:\n        balance += operation\n        if operation < 0 and (largest_withdrawal is None or operation < largest_withdrawal):\n            largest_withdrawal = operation\n        if operation > 0 and (smallest_deposit is None or operation < smallest_deposit):\n            smallest_deposit = operation\n        if balance < 0:\n            balance_falls_below_zero = True\n    return (largest_withdrawal, smallest_deposit, balance_falls_below_zero)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, -3, 2, -6, 5]]], "plus_fail_tests": []}], "EvoEval/70": [{"task_id": "EvoEval/70", "solution": "\nfrom typing import List, Tuple\nimport math\n\n\ndef closest_special_factorial(numbers: List[int]) -> Tuple[int, int]:\n\n    def special_factorial(n: int) -> int:\n        if n == 0:\n            return 1\n        else:\n            return n * special_factorial(n - 1)\n    numbers.sort()\n    min_diff = float('inf')\n    result = (0, 0)\n    for i in range(1, len(numbers)):\n        diff = abs(special_factorial(numbers[i]) - special_factorial(numbers[i - 1]))\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i - 1], numbers[i])\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[5, -6, -7]]], "plus_fail_tests": []}], "EvoEval/10": [{"task_id": "EvoEval/10", "solution": "\ndef class_grades_with_flip(name_grade_list):\n\n    def grade_to_letter(gpa):\n        if gpa == 4.0:\n            return 'A+'\n        elif gpa > 3.7:\n            return 'A'\n        elif gpa > 3.3:\n            return 'A-'\n        elif gpa > 3.0:\n            return 'B+'\n        elif gpa > 2.7:\n            return 'B'\n        elif gpa > 2.3:\n            return 'B-'\n        elif gpa > 2.0:\n            return 'C+'\n        elif gpa > 1.7:\n            return 'C'\n        elif gpa > 1.3:\n            return 'C-'\n        elif gpa > 1.0:\n            return 'D+'\n        elif gpa > 0.7:\n            return 'D'\n        elif gpa > 0.0:\n            return 'D-'\n        else:\n            return 'E'\n    return [(name.capitalize(), grade_to_letter(grade)) for (name, grade) in name_grade_list]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/31": [{"task_id": "EvoEval/31", "solution": "\nfrom typing import List\n\ndef special_prime_factorial(n: int) -> int:\n    \"\"\" \n    This function first factorizes the input 'n' into its prime factors and then calculates a special factorial.\n    The 'special factorial' is defined as the product of factorials of all the prime factors of 'n'.\n    The factors should be calculated number of times corresponding to how many times they appear in the factorization.\n    The function should return the product of these factorials.\n    \n    For instance,\n    >>> special_prime_factorial(8)\n    8  # because 8 = 2*2*2; 2! * 2! * 2 = 2 * 2 * 2 = 8\n    >>> special_prime_factorial(25)\n    14400 # because 25 = 5*5; 5!-- 5!-- = 120 * 120 = 14400\n    >>> special_prime_factorial(70)\n    1209600 # because 70 = 2 * 5 * 7; 2!-- 5!-- 7!-- = 2 * 120 * 5040 = 1209600\n    \"\"\"\n\n    def prime_factors(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                factors.append(i)\n        if n > 1:\n            factors.append(n)\n        return factors\n    prime_factor_list = prime_factors(n)\n    prime_factor_counts = {factor: prime_factor_list.count(factor) for factor in prime_factor_list}\n    result = 1\n    for (factor, count) in prime_factor_counts.items():\n        result *= math.factorial(factor) ** count\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[70]], "plus_fail_tests": []}], "EvoEval/88": [{"task_id": "EvoEval/88", "solution": "\ndef process_and_sort_string(s):\n    words = s.replace(',', '').split()\n    even_length_words = [word for word in words if len(word) % 2 == 0]\n    return sorted(even_length_words, key=lambda x: (len(x), x))", "base_status": "fail", "plus_status": null, "base_fail_tests": [[",a,b,c,d,e,f,g,h,i,j,"]], "plus_fail_tests": []}], "EvoEval/82": [{"task_id": "EvoEval/82", "solution": "\ndef odd_fibfib(n: int):\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        fibfib = [0, 0, 1]\n        for i in range(3, n + 1):\n            fibfib.append(fibfib[i - 1] + fibfib[i - 2] + fibfib[i - 3])\n            if fibfib[i] % 2 == 0:\n                digits = [int(d) for d in str(fibfib[i]) if int(d) % 2 != 0]\n                if len(digits) == 0:\n                    fibfib[i] = 0\n                else:\n                    product = 1\n                    for digit in digits:\n                        product *= digit\n                    fibfib[i] = product\n        return fibfib[n]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/62": [{"task_id": "EvoEval/62", "solution": "\ndef strange_word_sort(text):\n    if not text:\n        return ''\n    words = text.split()\n    words.sort(key=str.lower)\n    result = []\n    while words:\n        result.append(words.pop(0))\n        if words:\n            result.append(words.pop())\n    result_str = ''.join(result)\n    result_str = result_str.replace(' ', '_')\n    result_str = result_str.replace('__', '-')\n    return result_str", "base_status": "fail", "plus_status": null, "base_fail_tests": [["House   car"]], "plus_fail_tests": []}], "EvoEval/61": [{"task_id": "EvoEval/61", "solution": "\nfrom typing import List, Optional, Tuple\n\ndef longest_planet_chain(planet1: str, planet2: str, chains: List[Tuple[str, ...]]) -> Optional[Tuple[str, ...]]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return None\n    longest_chain = None\n    for chain in chains:\n        if chain[0] == planet1 and chain[-1] == planet2:\n            if longest_chain is None or len(chain) > len(longest_chain):\n                longest_chain = chain\n    return longest_chain", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/55": [{"task_id": "EvoEval/55", "solution": "import hashlib\n\ndef mini_roman_to_md5(number):\n    \"\"\"\n    Given a positive integer 'number', convert it to its roman numeral equivalent as a string in lowercase.\n    Return the md5 hash of the roman numeral string. If 'number' is zero or negative, return None.\n    Restrictions: 0 <= num <= 1000\n\n    Examples:\n    >>> mini_roman_to_md5(19) == 'deecbfa00b6b28500a8a2b0d2cd484f2'\n    >>> mini_roman_to_md5(152) == 'e63c5e3bfe23f38e0550b1aa0602d67b'\n    >>> mini_roman_to_md5(426) == '47863739f1551f4cfb83b7d0101a1d0b'\n    \"\"\"\n    if number <= 0:\n        return None\n    val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    syb = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n    roman_num = ''\n    i = 0\n    while number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syb[i]\n            number -= val[i]\n        i += 1\n    return hashlib.md5(roman_num.encode()).hexdigest()", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/57": [{"task_id": "EvoEval/57", "solution": "def palindromic_and_odd_digit_array(arr):\n    n = len(arr)\n    changes = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            changes += 1\n        if arr[i] % 2 == 0 or arr[n - i - 1] % 2 == 0:\n            changes += 1\n    if n % 2 == 1 and arr[n // 2] % 2 == 0:\n        changes += 1\n    return changes", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 2, 5]]], "plus_fail_tests": []}], "EvoEval/75": [{"task_id": "EvoEval/75", "solution": "def transform_dict(input_dict):\n    if not input_dict or not all((isinstance(k, str) for k in input_dict.keys())):\n        return {}\n    if not all((k.isupper() for k in input_dict.keys())) and (not all((k.islower() for k in input_dict.keys()))):\n        return {}\n    return {k: round(float(v)) for (k, v) in input_dict.items()}", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"A": "10.5", "B": "-15.5"}]], "plus_fail_tests": []}], "EvoEval/94": [{"task_id": "EvoEval/94", "solution": "\ndef sort_count_nums(arr):\n    count = sum((sum((int(digit) for digit in str(abs(num)))) > 0 for num in arr))\n    sorted_arr = sorted(arr, reverse=count % 2 == 0)\n    return sorted_arr", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[15, -23, 56, 78, -90, 0, 34, 23, -45, 67]]], "plus_fail_tests": []}], "EvoEval/76": [{"task_id": "EvoEval/76", "solution": "def sort_prime_digit_sum(lst):\n    new_lst = []\n    for num in lst:\n        if is_prime(num):\n            new_lst.append(sum_of_digits(num))\n        else:\n            new_lst.append(num)\n    if (new_lst[0] + new_lst[-1]) % 2 == 0:\n        return sorted(new_lst, reverse=True)\n    else:\n        return sorted(new_lst)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]]], "plus_fail_tests": []}], "EvoEval/26": [{"task_id": "EvoEval/26", "solution": "\nfrom typing import List, Tuple\n\ndef sort_and_pluck(values: List[str]) -> Tuple[str, int]:\n    numeral_map = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    min_even_value = float('inf')\n    min_even_index = float('inf')\n    min_even_numeral = ''\n    for (i, value) in enumerate(values):\n        nums = value.split()\n        nums.sort(key=lambda x: numeral_map[x])\n        for (j, num) in enumerate(nums):\n            if numeral_map[num] % 2 == 0 and numeral_map[num] < min_even_value:\n                min_even_value = numeral_map[num]\n                min_even_index = j\n                min_even_numeral = num\n    return (min_even_numeral, min_even_index) if min_even_numeral else ()", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["three two one", "five four zero", "six zero eight"]]], "plus_fail_tests": []}], "EvoEval/24": [{"task_id": "EvoEval/24", "solution": "from typing import List\n\ndef sort_happy_numbers(numbers: str) -> str:\n    word_to_num = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    num_to_word = {v: k for (k, v) in word_to_num.items()}\n    words = numbers.split()\n    for i in range(len(words) - 2):\n        if words[i] == words[i + 1] or words[i] == words[i + 2] or words[i + 1] == words[i + 2]:\n            return 'Not a happy string'\n    numbers = sorted([word_to_num[word] for word in words])\n    sorted_words = ' '.join([num_to_word[num] for num in numbers])\n    return sorted_words", "base_status": "fail", "plus_status": null, "base_fail_tests": [["three one five"]], "plus_fail_tests": []}], "EvoEval/78": [{"task_id": "EvoEval/78", "solution": "\ndef solve_and_count(s):\n    vowels = 'AEIOU'\n    result = ''\n    count = 0\n    has_letter = False\n    for i in range(len(s)):\n        if s[i].isalpha():\n            has_letter = True\n            if s[i].islower():\n                result += s[i].upper()\n                if i % 2 == 0 and s[i].upper() in vowels:\n                    count += 1\n            else:\n                result += s[i].lower()\n                if i % 2 == 0 and s[i].lower() in vowels:\n                    count += 1\n        else:\n            result += s[i]\n    if not has_letter:\n        result = s[::-1]\n    return (result, count)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/71": [{"task_id": "EvoEval/71", "solution": "\nimport math\n\ndef special_brazilian_balloon(n, w):\n\n    def brazilian_factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * brazilian_factorial(n - 1)\n    max_weight = brazilian_factorial(n)\n    total_weight = sum(w)\n    if total_weight > max_weight:\n        return False\n    if w != w[::-1]:\n        return False\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[3, [3, 2, 3]]], "plus_fail_tests": []}], "EvoEval/85": [{"task_id": "EvoEval/85", "solution": "def next_smallest_sorted_binary(lst):\n    lst = [(bin(i).count('1'), i) for i in lst]\n    lst.sort()\n    return lst[1][1] if len(lst) > 1 else None", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 1]]], "plus_fail_tests": []}], "EvoEval/2": [{"task_id": "EvoEval/2", "solution": "\nfrom typing import List\n\ndef modp_intersperse(numbers: List[int], n: int, p: int) -> List[int]:\n    \"\"\" Insert the result of 2^n modulo p between every two consecutive elements of input list `numbers'\n    >>> modp_intersperse([], 3, 5)\n    []\n    >>> modp_intersperse([1, 2, 3], 3, 5)\n    [1, 3, 2, 3, 3]\n    >>> modp_intersperse([10, 20, 30], 1101, 101)\n    [10, 2, 20, 2, 30]\n    \"\"\"\n    result = []\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i < len(numbers) - 1:\n            result.append(2 ** n % p)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/47": [{"task_id": "EvoEval/47", "solution": "def count_odd_upper(s, lst):\n    vowels = ['A', 'E', 'I', 'O', 'U']\n    n = sum((1 for i in range(len(s)) if i % 2 == 0 and s[i] in vowels))\n    result = []\n    for string in lst:\n        m = sum((1 for char in string if int(char) % 2 != 0))\n        result.append(f'In the string, the number of uppercase vowels in even indices is {n}, and the number of odd digits is {m}.')\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/74": [{"task_id": "EvoEval/74", "solution": "def sum_exchange(lst1, lst2, x, y, z):\n    \"\"\"\n    In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, the answer is \"YES\".\n    Otherwise, the answer is \"NO\".\n    After that, the function also takes in three more integers, x, y and z.\n    It will check if one of these integers is equal to the sum of the other two.\n    If this is true, append \"SUM\" to the front of the answer string.\n    Otherwise, append \"NO_SUM\" to the front of the answer string.\n    For example:\n    sum_exchange([1, 2, 3, 4], [1, 2, 3, 4], 5, 2, 2) => \"NO_SUM YES\"\n    sum_exchange([1, 2, 3, 4], [1, 5, 3, 4], 4, 2, 2) => \"SUM NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    if x == y + z or y == x + z or z == x + y:\n        sum_str = 'SUM'\n    else:\n        sum_str = 'NO_SUM'\n    for num in lst1:\n        if num % 2 != 0:\n            if num in lst2:\n                lst2.remove(num)\n                lst1.remove(num)\n    for num in lst1:\n        if num % 2 != 0:\n            return sum_str + ' NO'\n    return sum_str + ' YES'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 4], [1, 5, 3, 4], 4, 2, 2]], "plus_fail_tests": []}], "EvoEval/52": [{"task_id": "EvoEval/52", "solution": "def pluck_and_prod(arr):\n    if not arr:\n        return ([], None)\n    min_even = float('inf')\n    min_index = -1\n    for (i, num) in enumerate(arr):\n        if num % 2 == 0 and num < min_even:\n            min_even = num\n            min_index = i\n    if min_index == -1:\n        return ([], None)\n    arr.pop(min_index)\n    if not arr:\n        return ([min_even, min_index], None)\n    product = 1\n    sum_magnitude = 0\n    for num in arr:\n        product *= 1 if num == 0 else -1 if num < 0 else 1\n        sum_magnitude += abs(num)\n    return ([min_even, min_index], product * sum_magnitude)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[-5, -2, 3, 0, -4]]], "plus_fail_tests": []}], "EvoEval/13": [{"task_id": "EvoEval/13", "solution": "def filter_exchange(arr, lst1):\n    arr = [num for num in arr if sum((int(digit) for digit in str(abs(num)))) > 0]\n    even_count = sum((1 for num in lst1 if num % 2 == 0))\n    odd_count = sum((1 for num in arr if num % 2 != 0))\n    return 'YES' if even_count >= odd_count else 'NO'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[], [1, 2, 3, 4]]], "plus_fail_tests": []}], "EvoEval/34": [{"task_id": "EvoEval/34", "solution": "from typing import List\n\ndef md5_nested_parens(paren_string: str) -> List[str]:\n\n    def is_balanced(s: str) -> bool:\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    def deepest_level(s: str) -> int:\n        max_depth = 0\n        current_depth = 0\n        for char in s:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n        return max_depth\n    if not paren_string:\n        return []\n    result = []\n    groups = paren_string.split()\n    for group in groups:\n        if is_balanced(group):\n            depth = str(deepest_level(group))\n            result.append(hashlib.md5(depth.encode()).hexdigest())\n        else:\n            result.append(hashlib.md5('None'.encode()).hexdigest())\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["(()()) (((((()))()((())()()))))"]], "plus_fail_tests": []}], "EvoEval/25": [{"task_id": "EvoEval/25", "solution": "\nfrom typing import List, Tuple\n\ndef sum_product_triples(n: int) -> Tuple[int, int]:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    valid_triples = [(a[i], a[j], a[k]) for i in range(n) for j in range(i + 1, n) for k in range(j + 1, n) if (a[i] + a[j] + a[k]) % 3 == 0]\n    if not valid_triples:\n        return (0, 1)\n    else:\n        return (sum((triple[0] for triple in valid_triples)), eval('*'.join((str(triple[0]) for triple in valid_triples))))", "base_status": "fail", "plus_status": null, "base_fail_tests": [[100]], "plus_fail_tests": []}], "EvoEval/98": [{"task_id": "EvoEval/98", "solution": "\ndef check_dict_bracketing(dict):\n    if not dict:\n        return False\n    if not all((k.islower() for k in dict.keys())) and (not all((k.isupper() for k in dict.keys()))):\n        return False\n    for v in dict.values():\n        if not all((c in '()' for c in v)):\n            return False\n        if v.count('(') != v.count(')'):\n            return False\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"A": "((((()))))", "B": "([])"}]], "plus_fail_tests": []}], "EvoEval/63": [{"task_id": "EvoEval/63", "solution": "\ndef sort_planets(planet1: str, planet2: str, order: str) -> str:\n    planet_names = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    planet_numbers = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven']\n    if planet1 not in planet_names or planet2 not in planet_names:\n        return 'Invalid'\n    order_list = order.split()\n    if len(order_list) != len(set(order_list)) or not all((i in planet_numbers for i in order_list)):\n        return 'Invalid'\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        planets_between = order_list[planet1_index + 1:planet2_index]\n    else:\n        planets_between = order_list[planet2_index + 1:planet1_index]\n    return ' '.join(planets_between)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Earth", "Mercury", "seven six five four three two one zero"]], "plus_fail_tests": []}], "EvoEval/20": [{"task_id": "EvoEval/20", "solution": "\ndef grade_and_case(s, grades):\n\n    def get_grade(gpa):\n        if gpa == 4.0:\n            return 'A+'\n        elif gpa > 3.7:\n            return 'A'\n        elif gpa > 3.3:\n            return 'A-'\n        elif gpa > 3.0:\n            return 'B+'\n        elif gpa > 2.7:\n            return 'B'\n        elif gpa > 2.3:\n            return 'B-'\n        elif gpa > 2.0:\n            return 'C+'\n        elif gpa > 1.7:\n            return 'C'\n        elif gpa > 1.3:\n            return 'C-'\n        elif gpa > 1.0:\n            return 'D+'\n        elif gpa > 0.7:\n            return 'D'\n        elif gpa > 0.0:\n            return 'D-'\n        else:\n            return 'E'\n    return [(name[::-1].swapcase(), get_grade(grade)) for (name, grade) in zip(s, grades)]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["Amy", "BOB", "miLEs"], [4.0, 3, 1.7]]], "plus_fail_tests": []}], "EvoEval/33": [{"task_id": "EvoEval/33", "solution": "\ndef roman_happiness(s):\n    roman_dict = {'i': 1, 'v': 5, 'x': 10, 'l': 50, 'c': 100, 'd': 500, 'm': 1000}\n    if len(s) < 3 or len(set(s)) < 3:\n        return False\n    num = 0\n    for i in range(len(s)):\n        if i > 0 and roman_dict[s[i]] > roman_dict[s[i - 1]]:\n            num += roman_dict[s[i]] - 2 * roman_dict[s[i - 1]]\n        else:\n            num += roman_dict[s[i]]\n    if num > 1000:\n        return False\n    return num", "base_status": "fail", "plus_status": null, "base_fail_tests": [["cmxlii"]], "plus_fail_tests": []}], "EvoEval/96": [{"task_id": "EvoEval/96", "solution": "\ndef common_pairs_with_zero_sum(l1: list, l2: list) -> bool:\n    common_elements = set(l1) & set(l2)\n    for element in common_elements:\n        if -element in common_elements:\n            return True\n    return False", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 3, 5, -3, 0], [0, -3, 1, 5, 2]]], "plus_fail_tests": []}], "EvoEval/90": [{"task_id": "EvoEval/90", "solution": "\ndef vowels_in_dict_keys(dict):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    result = {}\n    for key in dict.keys():\n        if not isinstance(key, str):\n            return {}\n        if not key.islower() and (not key.isupper()):\n            return {}\n        count = 0\n        for char in key:\n            if char.lower() in vowels:\n                count += 1\n        result[key] = count\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"a": "apple", "A": "banana", "B": "banana"}]], "plus_fail_tests": []}], "EvoEval/67": [{"task_id": "EvoEval/67", "solution": "\nfrom typing import List\n\ndef max_close_element_difference(numbers: List[float], threshold: float) -> float:\n    \"\"\"\n    Given a list of numbers and a threshold, find two elements that are closer to each other than the threshold and return their difference. If multiple pairs meet the criteria, return the maximum difference. If no such pairs exist, return 0.\n    >>> max_close_element_difference([1.0, 2.0, 3.0], 0.5)\n    0\n    >>> max_close_element_difference([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    0.2\n    >>> max_close_element_difference([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 5)\n    4\n    \"\"\"\n    numbers.sort()\n    max_diff = 0\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < threshold and diff > max_diff:\n            max_diff = diff\n    return max_diff", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1000000000.0, 1000000001.0, 1000000002.0, 1000000003.0, 1000000004.0], 5]], "plus_fail_tests": []}], "EvoEval/42": [{"task_id": "EvoEval/42", "solution": "\ndef check_expression(expression: str):\n    if not expression.startswith('<') or not expression.endswith('>'):\n        return False\n    expression = expression[1:-1]\n    fractions = expression.split(',')\n    product = 1\n    for fraction in fractions:\n        (numerator, denominator) = map(int, fraction.split('/'))\n        product *= numerator / denominator\n    return product.is_integer()", "base_status": "fail", "plus_status": null, "base_fail_tests": [["<1/2,2/1><2/3,3/2>"]], "plus_fail_tests": []}], "EvoEval/15": [{"task_id": "EvoEval/15", "solution": "from typing import List\n\ndef balance_triples(operations: List[int]) -> bool:\n    balance = 0\n    sums = []\n    for operation in operations:\n        balance += operation\n        sums.append(balance)\n        if balance < 0:\n            return False\n    sums.sort()\n    for i in range(len(sums) - 2):\n        if sums[i] == sums[i + 1] == sums[i + 2]:\n            return True\n    return False", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[2, -2, 2, -1, 1]]], "plus_fail_tests": []}], "EvoEval/30": [{"task_id": "EvoEval/30", "solution": "\nfrom typing import List\n\ndef parse_music_simplify(x: str, music_string: str) -> List[bool]:\n    (numerator, denominator) = map(int, x.split('/'))\n    x_value = numerator / denominator\n    note_values = {'o': 4, 'o|': 2, '.|': 1}\n    notes = music_string.split()\n    results = []\n    for note in notes:\n        beat_value = note_values[note]\n        if x_value * beat_value == int(x_value * beat_value):\n            results.append(True)\n        else:\n            results.append(False)\n    return results", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/37": [{"task_id": "EvoEval/37", "solution": "\nimport math\n\ndef minSubArraySumEvenOdd(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums. Then, return a tuple that has the number of even and odd digits in \n    this minimum sum respectively.\n\n    Example:\n    minSubArraySumEvenOdd([2, 3, 4, 1, 2, 4]) == (0, 1)  # minimum sum is 1 which has 0 even digit and 1 odd digit\n    minSubArraySumEvenOdd([-1, -2, -3]) == (1, 0)  # minimum sum is -6 which has 1 even digit and 0 odd digit\n    \"\"\"\n    min_sum = float('inf')\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            min_sum = min(min_sum, sum(nums[i:j + 1]))\n    even_count = 0\n    odd_count = 0\n    for digit in str(abs(min_sum)):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/97": [{"task_id": "EvoEval/97", "solution": "\ndef fib_max_triples(n):\n    fib = [0, 0, 1]\n    for i in range(3, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2] + fib[i - 3] + i * i - i + 1)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (fib[i] + fib[j] + fib[k]) % 3 == 0:\n                    count += 1\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [[5]], "plus_fail_tests": []}], "EvoEval/21": [{"task_id": "EvoEval/21", "solution": "\nfrom typing import List\n\ndef base_change_prefixes(x: int, base: int) -> List[str]:\n    base_x = ''\n    while x > 0:\n        base_x = str(x % base) + base_x\n        x //= base\n    prefixes = [base_x[0:i] for i in range(1, len(base_x) + 1)]\n    return prefixes", "base_status": "fail", "plus_status": null, "base_fail_tests": [[0, 2]], "plus_fail_tests": []}], "EvoEval/3": [{"task_id": "EvoEval/3", "solution": "\nfrom typing import List\n\ndef sort_parentheses(lst: List[str]) -> str:\n    \"\"\"\n    You are given a list of strings, each string consist of open parentheses '(' or close parentheses ')' \n    and numberals from 'zero' to 'nine' in text form.\n    Your job is to sort the numbers from smallest to largest and then check if it is possible to concatenate \n    the strings in this order so that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S are balanced. \n    For example: the string '(three)(one)(five)' is good, while the string '(three)(one(five)' is not.\n    Return 'Yes' if there's a way to make a good string after sorting, and return 'No' otherwise.\n\n    Examples:\n    sort_parentheses(['(three)(', '(five)', '(one)']) == 'No'\n    sort_parentheses(['(five)', '(three)', '(one)']) == 'Yes'\n    \"\"\"\n    num_dict = {'zero': '0', 'one': '1', 'two': '2', 'three': '3', 'four': '4', 'five': '5', 'six': '6', 'seven': '7', 'eight': '8', 'nine': '9'}\n    lst = [''.join((num_dict[num] if num in num_dict else num for num in s)) for s in lst]\n    lst.sort()\n    lst = [''.join((next((k for (k, v) in num_dict.items() if v == num), num) for num in s)) for s in lst]\n    s = ''.join(lst)\n    count = 0\n    for c in s:\n        if c == '(':\n            count += 1\n        elif c == ')':\n            count -= 1\n            if count < 0:\n                return 'No'\n    return 'Yes' if count == 0 else 'No'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["(one)", "(two)", "(three)", "(four", "five)", "(six)", "(seven)", "(eight)", "(nine", "zero)"]]], "plus_fail_tests": []}], "EvoEval/68": [{"task_id": "EvoEval/68", "solution": "\ndef minOddDigitsProductSubArray(nums):\n    min_product = float('inf')\n    for i in range(len(nums)):\n        product = 1\n        for j in range(i, len(nums)):\n            for digit in str(nums[j]):\n                if int(digit) % 2 != 0:\n                    product *= int(digit)\n            if product < min_product:\n                min_product = product\n    return min_product if min_product != float('inf') else 0", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[2, 3, 4, 1, 2, 4]]], "plus_fail_tests": []}], "EvoEval/27": [{"task_id": "EvoEval/27", "solution": "\ndef list_prime_exchange(lst1, lst2, x, y):\n    for num in lst1:\n        if not is_prime(num):\n            if num in lst2:\n                lst2.remove(num)\n            else:\n                return y\n    return x", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 4], [6, 7, 8, 12], 30, 40]], "plus_fail_tests": []}], "EvoEval/23": [{"task_id": "EvoEval/23", "solution": "\ndef special_stone_factorial(n):\n\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    def brazilian_factorial(n):\n        result = 1\n        for i in range(1, n + 1):\n            result *= factorial(i)\n        return result\n    result = []\n    for i in range(n):\n        if n % 2 == 0:\n            n += 1\n        else:\n            n += 2\n        result.append(brazilian_factorial(n))\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1]], "plus_fail_tests": []}], "EvoEval/8": [{"task_id": "EvoEval/8", "solution": "\ndef correct_bracket_sequence_and_count(string: str, bracket: str) -> tuple:\n    count = 0\n    stack = []\n    for char in string:\n        if char == bracket:\n            count += 1\n            stack.append(char)\n        elif stack:\n            stack.pop()\n        else:\n            return (False, count)\n    return (not stack, count)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["><<>", ">"]], "plus_fail_tests": []}], "EvoEval/99": [{"task_id": "EvoEval/99", "solution": "\ndef len_base_conversion(x: int, base: int) -> int:\n    \"\"\" \n    Convert the numerical base of input number x to base and \n    return the length of string representation after the conversion. \n    base numbers are less than 10.\n    \n    >>> len_base_conversion(8, 3)\n    2\n    >>> len_base_conversion(8, 2)\n    4\n    >>> len_base_conversion(7, 2)\n    3\n    \"\"\"\n    if base < 2 or base > 10:\n        raise ValueError('Base must be between 2 and 10')\n    if x < 0:\n        raise ValueError('x must be a non-negative integer')\n    if x == 0:\n        return 1\n    length = 0\n    while x > 0:\n        x //= base\n        length += 1\n    return length", "base_status": "fail", "plus_status": null, "base_fail_tests": [[0, 2]], "plus_fail_tests": []}], "EvoEval/1": [{"task_id": "EvoEval/1", "solution": "def round_and_flip(value: str) -> str:\n    \"\"\"\n    Create a function that takes a value representing two parts (number and string)\n    and returns a string with two parts: 1) The closest integer to the number,\n    and 2) The string with its case flipped. If the number is equidistant from two integers,\n    round it away from zero. Between these two parts, add a space. \n\n    Examples\n    >>> round_and_flip(\"10.5abc\")\n    '11 ABC'\n    >>> round_and_flip(\"15.3ABC\")\n    '15 abc'\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example round_and_flip(\"14.5abc\") should\n    return '15 ABC' and round_and_flip(\"-14.5ABC\") should return '-15 abc'.\n    \"\"\"\n    (num_part, str_part) = (value.split('.')[0], value.split('.')[1])\n    num_part = round(float(num_part))\n    str_part = str_part.swapcase()\n    return f'{num_part} {str_part}'", "base_status": "fail", "plus_status": null, "base_fail_tests": [["15.3ABC"]], "plus_fail_tests": []}], "EvoEval/11": [{"task_id": "EvoEval/11", "solution": "\ndef planet_vowel_count(planet1, planet2):\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    if planet1 not in planets or planet2 not in planets:\n        return 0\n    planet1_index = planets.index(planet1)\n    planet2_index = planets.index(planet2)\n    if planet1_index > planet2_index:\n        (planet1_index, planet2_index) = (planet2_index, planet1_index)\n    planet_subset = planets[planet1_index + 1:planet2_index]\n    vowel_count = 0\n    for planet in planet_subset:\n        for char in planet:\n            if char.lower() in vowels:\n                vowel_count += 1\n    return vowel_count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/95": [{"task_id": "EvoEval/95", "solution": "\nfrom typing import List\n\ndef filter_sort_strings(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain a given substring and have an even length. \n    Return the resulted list in ascending order by the length of each word. \n    If two words have the same length, sort the list alphabetically.\n    The list may contain duplicate strings.\n    \n    For example:\n    >>> filter_sort_strings([], 'a')\n    []\n    >>> filter_sort_strings(['abc', 'bacd', 'cd', 'array'], 'a')\n    ['bacd']\n    >>> filter_sort_strings(['abc', 'bacd', 'cd', 'array', 'play'], 'a')\n    ['bacd', 'play']\n    \"\"\"\n    filtered_strings = [s for s in strings if substring in s and len(s) % 2 == 0]\n    sorted_strings = sorted(filtered_strings, key=lambda s: (len(s), s))\n    return sorted_strings", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/14": [{"task_id": "EvoEval/14", "solution": "\ndef prime_avg_range(n, m):\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    primes = [i for i in range(n, m + 1) if is_prime(i)]\n    if not primes:\n        return -1\n    avg = round(sum(primes) / len(primes))\n    return bin(avg)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/6": [{"task_id": "EvoEval/6", "solution": "\ndef pile_median(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the median number of stones in all levels in the pile.\n\n    You should return the answer as a float if the number of levels is even,\n    and as an integer if the number of levels is odd.\n\n    Examples:\n    >>> pile_median(3)\n    5\n    >>> pile_median(4)\n    7.0\n    \"\"\"\n    total_stones = n * (n + 1) // 2\n    if n % 2 == 0:\n        return total_stones / 2\n    else:\n        return total_stones // 2 + 1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[2]], "plus_fail_tests": []}], "EvoEval/43": [{"task_id": "EvoEval/43", "solution": "\ndef sorted_fib4_sequence(n: int):\n    if n == 0:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 0]\n    elif n == 3:\n        return [0, 0, 2]\n    else:\n        fib4 = [0, 0, 2, 0]\n        for i in range(4, n):\n            fib4.append(fib4[i - 1] + fib4[i - 2] + fib4[i - 3] + fib4[i - 4])\n        if (fib4[0] + fib4[-1]) % 2 == 0:\n            fib4.sort(reverse=True)\n        else:\n            fib4.sort()\n        return fib4", "base_status": "fail", "plus_status": null, "base_fail_tests": [[3]], "plus_fail_tests": []}], "EvoEval/46": [{"task_id": "EvoEval/46", "solution": "\ndef get_max_even_positive(l: list):\n    \"\"\"This function takes a list of positive and negative numbers, filters \n    out the negative numbers, and returns the largest even number among the \n    remaining elements. If there are no positive even numbers in the list, \n    the function should return -1.\n\n    For example:\n    get_max_even_positive([-1, 2, -4, 5, 6]) = 6\n    get_max_even_positive([1, 3, 5, 7]) = -1\n    \"\"\"\n    positive_even_numbers = [num for num in l if num > 0 and num % 2 == 0]\n    if not positive_even_numbers:\n        return -1\n    return max(positive_even_numbers)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/39": [{"task_id": "EvoEval/39", "solution": "def smallest_change_and_sum(arr, x, y):\n    n = len(arr)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = i or j\n            elif arr[i - 1] == arr[n - j]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1])\n    return dp[n][n] + x + y", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 4, 3, 2, 2], 1, 2]], "plus_fail_tests": []}], "EvoEval/93": [{"task_id": "EvoEval/93", "solution": "\ndef prime_vowel(string):\n    vowels = 'aeiouAEIOU'\n    if not is_prime(len(string)):\n        return ''\n    for i in range(len(string) - 2, 0, -1):\n        if string[i] in vowels and string[i - 1] not in vowels and (string[i + 1] not in vowels):\n            return string[i]\n    return ''", "base_status": "fail", "plus_status": null, "base_fail_tests": [["ab"]], "plus_fail_tests": []}], "EvoEval/41": [{"task_id": "EvoEval/41", "solution": "\ndef shifted_upper_count(s, shift):\n    \"\"\"\n    Given a string s and an integer shift, perform a circular shift on the ASCII values of the characters in string \n    by the shift value. Return the count of uppercase vowels in even indices after the shift.\n\n    If shift > length of string, reverse the string before counting.\n\n    For example:\n    shifted_upper_count('aBCdEf', 1) returns 0\n    shifted_upper_count('abcdefg', 2) returns 0\n    shifted_upper_count('dBBE', 3) returns 1\n    \"\"\"\n    vowels = 'AEIOU'\n    if shift > len(s):\n        s = s[::-1]\n    else:\n        s = s[-shift:] + s[:-shift]\n    return sum((1 for (i, c) in enumerate(s) if i % 2 == 0 and c in vowels))", "base_status": "fail", "plus_status": null, "base_fail_tests": [["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", 25]], "plus_fail_tests": []}], "EvoEval/49": [{"task_id": "EvoEval/49", "solution": "\ndef modp_count(arr, n: int, p: int):\n    \"\"\"\n    Write a function modp_count which takes an array of integers and two integers n and p as inputs.\n    The function should first calculate 2^n modulo p. \n    It then counts the number of elements in the array which has a sum of digits > the result of 2^n modulo p.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> modp_count([], 2, 5) == 0\n    >>> modp_count([-1, 11, -11], 4, 5) == 1\n    >>> modp_count([1, 1, 2], 0, 101) == 1\n    >>> modp_count([12, 15, 20], 11, 3) == 2\n    \"\"\"\n    mod_result = 2 ** n % p\n    count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n        digit_sum = sum((int(digit) for digit in str(num)))\n        if digit_sum > mod_result:\n            count += 1\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[-1, 11, -11], 4, 5]], "plus_fail_tests": []}], "EvoEval/9": [{"task_id": "EvoEval/9", "solution": "def planet_to_roman_distance(planet1, planet2):\n    planet_distance = {'mercury': 1, 'venus': 2, 'earth': 3, 'mars': 4, 'jupiter': 5, 'saturn': 6, 'uranus': 7, 'neptune': 8}\n    roman_numerals = {1: 'i', 2: 'ii', 3: 'iii', 4: 'iv', 5: 'v', 6: 'vi', 7: 'vii', 8: 'viii'}\n    planet1 = planet1.lower()\n    planet2 = planet2.lower()\n    if planet1 not in planet_distance or planet2 not in planet_distance:\n        return {}\n    planet1_distance = planet_distance[planet1]\n    planet2_distance = planet_distance[planet2]\n    if planet1_distance > planet2_distance:\n        (planet1_distance, planet2_distance) = (planet2_distance, planet1_distance)\n    planets_between = {planet: roman_numerals[distance] for (planet, distance) in planet_distance.items() if planet1_distance < distance < planet2_distance}\n    return planets_between", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Uranus", 1]], "plus_fail_tests": []}], "EvoEval/84": [{"task_id": "EvoEval/84", "solution": "\nfrom typing import List, Dict\n\ndef prefixes_histogram(string: str) -> Dict[str, Dict[str, int]]:\n    result = {}\n    for i in range(len(string)):\n        prefix = string[:i + 1]\n        histogram = {}\n        max_count = 0\n        for char in prefix:\n            histogram[char] = histogram.get(char, 0) + 1\n            max_count = max(max_count, histogram[char])\n        result[prefix] = {char: count for (char, count) in histogram.items() if count == max_count}\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/77": [{"task_id": "EvoEval/77", "solution": "\ndef mixed_solution(arr):\n\n    def sum_of_digits(n):\n        return sum((int(digit) for digit in str(abs(n))))\n    return sum((n for (i, n) in enumerate(arr) if i % 2 == 0 and n % 2 != 0 and (sum_of_digits(n) > 0)))", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 3, -3, 3, 3]]], "plus_fail_tests": []}], "EvoEval/29": [{"task_id": "EvoEval/29", "solution": "def largest_prime_factor_or_value(n, x, y):\n    \"\"\"A program which should return the largest prime factor of n if n is not a prime number, should return the value of x if n is a prime number and y if n is 1. \n\n    Examples:\n    for largest_prime_factor_or_value(13195, 34, 12) == 29\n    for largest_prime_factor_or_value(7, 8, 5) == 8\n    for largest_prime_factor_or_value(1, 8, 5) == 5\n    \"\"\"\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def largest_prime_factor(n):\n        max_prime = -1\n        while n % 2 == 0:\n            max_prime = 2\n            n >>= 1\n        while n % 3 == 0:\n            max_prime = 3\n            n = n / 3\n        for i in range(5, int(n ** 0.5) + 1, 6):\n            while n % i == 0:\n                max_prime = i\n                n = n / i\n            while n % (i + 2) == 0:\n                max_prime = i + 2\n                n = n / (i + 2)\n        if n > 4:\n            max_prime = n\n        return int(max_prime)\n    if n == 1:\n        return y\n    elif is_prime(n):\n        return x\n    else:\n        return largest_prime_factor(n)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/56": [{"task_id": "EvoEval/56", "solution": "def product_of_odd_prime_factors(n):\n    \"\"\"Given a positive integer n, return the product of its unique odd prime factors.\n    If all prime factors are even, return 0.\n    Assume n > 1 and is not a prime.\n    For example:\n    product_of_odd_prime_factors(9) == 3\n    product_of_odd_prime_factors(15) == 15\n    product_of_odd_prime_factors(20) == 5\n    product_of_odd_prime_factors(32) == 0\n    \"\"\"\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_odd(num):\n        return num % 2 != 0\n    product = 1\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i) and is_odd(i):\n            product *= i\n    return product if product != 1 else 0", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/60": [{"task_id": "EvoEval/60", "solution": "\ndef smallest_even_triple(arr, n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    smallest_triple = None\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    if smallest_triple is None or a[i] < smallest_triple[0]:\n                        smallest_triple = (a[i], a[j], a[k])\n    if smallest_triple is not None:\n        arr.append(smallest_triple[0])\n        even_values = [(val, idx) for (idx, val) in enumerate(arr) if val % 2 == 0]\n        if even_values:\n            return min(even_values, key=lambda x: (x[0], x[1]))\n    return []", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[4, 2, 3], 5]], "plus_fail_tests": []}], "EvoEval/73": [{"task_id": "EvoEval/73", "solution": "\nfrom typing import List\nfrom fractions import Fraction\n\ndef filter_and_simplify(fractions: List[str], n: str) -> List[bool]:\n    n_fraction = Fraction(n)\n    result = []\n    for fraction in fractions:\n        fraction_obj = Fraction(fraction)\n        product = fraction_obj * n_fraction\n        result.append(product.denominator == 1)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/87": [{"task_id": "EvoEval/87", "solution": "\ndef match_and_remove_unbalanced(text):\n    stack = []\n    vowels = set('aeiouAEIOU')\n    result = []\n    for char in text:\n        if char == '(':\n            stack.append(char)\n            result.append(char)\n        elif char == ')':\n            if stack and stack[-1] == '(':\n                stack.pop()\n                result.append(char)\n        else:\n            result.append(char)\n    if stack:\n        result = [char for char in result if char not in vowels]\n    return ''.join(result)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["ab)c(de)f"]], "plus_fail_tests": []}], "EvoEval/7": [{"task_id": "EvoEval/7", "solution": "\ndef sum_square_cube_to_n(n: int):\n    \"\"\"\n    This function takes an integer n. The function generates a list of integers from 1 to n inclusive. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n\n    Examples:\n    For n = 3 the output should be 12\n    For n = 1 the output should be 1\n    For n = 5 the output should be 81\n    For n = 10 the output should be 727\n    \"\"\"\n    result = 0\n    for i in range(1, n + 1):\n        if i % 3 == 0:\n            result += i ** 2\n        elif i % 4 == 0:\n            result += i ** 3\n        else:\n            result += i\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/5": [{"task_id": "EvoEval/5", "solution": "\nfrom typing import List\n\ndef sort_and_check(numbers: List[float], threshold: float) -> List[float]:\n    \"\"\"\n    Given an array of numbers, check if any two numbers in the array are closer to each other \n    than the given threshold. If yes, sort the array according to the following rules:\n\n    - If the sum of the first and last numbers in the array is even, sort the array in descending order.\n    - If the sum of the first and last numbers in the array is odd, sort the array in ascending order.\n    \n    If no two numbers are closer than the threshold, return the array as it is.\n    \n    Note: Consider the sum as even or odd after rounding off to the nearest integer.\n\n    Examples:\n    * sort_and_check([1.0, 2.0, 3.0], 0.5) => [1.0, 2.0, 3.0]\n    * sort_and_check([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) => [1.0, 2.0, 2.8, 3.0, 4.0, 5.0]\n    * sort_and_check([4.0, 2.0, 3.0, 0.0], 2.0) => [4.0, 3.0, 2.0, 0.0]\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                first_last_sum = round(numbers[0] + numbers[-1])\n                if first_last_sum % 2 == 0:\n                    numbers.sort(reverse=True)\n                else:\n                    numbers.sort()\n                return numbers\n    return numbers", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/54": [{"task_id": "EvoEval/54", "solution": "\nimport math\n\ndef max_sum_of_prime_subarray(nums):\n    \"\"\"\n    Given an array of integers nums, find the maximum sum of any non-empty sub-array\n    of prime nums. If no prime subarray exists, return 0.\n    A prime number is a number that has exactly two distinct positive divisors: 1 and itself.\n    You may assume that all numbers in the array are greater than 0.\n    \n    Example\n    max_sum_of_prime_subarray([1, 2, 3, 4, 5, 6]) == 5  # The subarray [2, 3] is a subarray with primes, and it has the maximum sum, so their sum, 5, is returned\n    max_sum_of_prime_subarray([4, 6, 8, 10]) == 0 # There are no primes in the list\n    max_sum_of_prime_subarray([2, 3, 5, 7, 11, 13]) == 41 # All numbers in this list are primes, so their sum, 41, is returned\n    \"\"\"\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        sqrt_n = math.isqrt(n)\n        for i in range(3, sqrt_n + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    max_sum = 0\n    current_sum = 0\n    for num in nums:\n        if is_prime(num):\n            current_sum += num\n            max_sum = max(max_sum, current_sum)\n        else:\n            current_sum = 0\n    return max_sum", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/51": [{"task_id": "EvoEval/51", "solution": "\ndef modify_and_compare(a, b):\n    if isinstance(a, str):\n        if any((c.isalpha() for c in a)):\n            a = a.swapcase()\n        else:\n            a = a[::-1]\n    if isinstance(b, str):\n        if any((c.isalpha() for c in b)):\n            b = b.swapcase()\n        else:\n            b = b[::-1]\n    if isinstance(a, str) or isinstance(b, str):\n        return b\n    else:\n        a = float(str(a).replace(',', '.'))\n        b = float(str(b).replace(',', '.'))\n        if a > b:\n            return a\n        elif a < b:\n            return b\n        else:\n            return None", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1, "1"]], "plus_fail_tests": []}], "EvoEval/28": [{"task_id": "EvoEval/28", "solution": "\ndef grade_with_same_chars(grades: list, s0: str, s1: str):\n\n    def get_grade(gpa):\n        if gpa == 4.0:\n            return 'A+'\n        elif gpa > 3.7:\n            return 'A'\n        elif gpa > 3.3:\n            return 'A-'\n        elif gpa > 3.0:\n            return 'B+'\n        elif gpa > 2.7:\n            return 'B'\n        elif gpa > 2.3:\n            return 'B-'\n        elif gpa > 2.0:\n            return 'C+'\n        elif gpa > 1.7:\n            return 'C'\n        elif gpa > 1.3:\n            return 'C-'\n        elif gpa > 1.0:\n            return 'D+'\n        elif gpa > 0.7:\n            return 'D'\n        elif gpa > 0.0:\n            return 'D-'\n        else:\n            return 'E'\n    if set(s0) == set(s1):\n        return [get_grade(gpa) for gpa in grades]\n    else:\n        return []", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[-4.0, -3.3, -2.7, -2.0], "abcd", "dcba"]], "plus_fail_tests": []}], "EvoEval/69": [{"task_id": "EvoEval/69", "solution": "def sorted_happy_strings(lst):\n\n    def is_happy(s):\n        return len(s) >= 3 and all((len(set(s[i:i + 3])) == 3 for i in range(len(s) - 2)))\n    happy_strings = [s for s in lst if is_happy(s)]\n    happy_strings.sort(key=lambda s: (len(s), s))\n    return happy_strings", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["abcd", "aaa", "abc", "abccba", "cd"]]], "plus_fail_tests": []}], "EvoEval/66": [{"task_id": "EvoEval/66", "solution": "\ndef find_max_triple_sum(x, y, n):\n    max_even = -1\n    for i in range(y, x - 1, -1):\n        if i % 2 == 0:\n            max_even = i\n            break\n    if max_even == -1:\n        return -1\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    a.sort(reverse=True)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    return a[i] + a[j] + a[k] + max_even\n    return -1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[10, 15, 20]], "plus_fail_tests": []}], "EvoEval/36": [{"task_id": "EvoEval/36", "solution": "\ndef mod_shift_sort(arr, n: int, p: int):\n    if not arr:\n        return True\n    max_shift = pow(2, n, p)\n    sorted_arr = sorted(arr)\n    for i in range(len(arr)):\n        if arr == sorted_arr:\n            return True\n        else:\n            arr = arr[-1:] + arr[:-1]\n    return False", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 4, 5, 1, 2], 0, 101]], "plus_fail_tests": []}], "EvoEval/79": [{"task_id": "EvoEval/79", "solution": "\ndef happy_case_string(s):\n    if len(s) < 3:\n        return s[::-1]\n    for i in range(len(s) - 2):\n        if s[i].lower() == s[i + 1].lower() or s[i].lower() == s[i + 2].lower() or s[i + 1].lower() == s[i + 2].lower():\n            return s[::-1]\n    result = ''\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                result += char.upper()\n            else:\n                result += char.lower()\n        else:\n            result += char\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["*#@"]], "plus_fail_tests": []}], "EvoEval/86": [{"task_id": "EvoEval/86", "solution": "\ndef evaluate_common_expressions(operators, operand_lists):\n    common_operands = set(operand_lists[0]).intersection(*operand_lists)\n    common_operands = sorted(list(common_operands))\n    if not common_operands:\n        return None\n    expression = str(common_operands[0])\n    for i in range(1, len(common_operands)):\n        expression += ' ' + operators[i - 1] + ' ' + str(common_operands[i])\n    return eval(expression)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/4": [{"task_id": "EvoEval/4", "solution": "\ndef largest_prime_divisor_digit_sum(lst: list) -> int:\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def largest_prime_divisor(n):\n        largest = 2\n        for i in range(2, n):\n            if n % i == 0 and is_prime(i):\n                largest = i\n        return largest\n\n    def digit_sum(n):\n        return sum((int(digit) for digit in str(n)))\n    largest_prime_divisors = [largest_prime_divisor(n) for n in lst]\n    return max((digit_sum(n) for n in largest_prime_divisors))", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[84, 91, 97, 101, 105]]], "plus_fail_tests": []}], "EvoEval/48": [{"task_id": "EvoEval/48", "solution": "\nfrom typing import List\n\ndef prime_prefixed_strings(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Write a function that takes a list of strings and a prefix, it should return a list of \n    strings from the input list which start with the given prefix and their lengths are prime numbers.\n    \n    Examples\n    prime_prefixed_strings([], 'a') == []\n    prime_prefixed_strings(['abc', 'bcd', 'cde', 'array'], 'a') == ['abc', 'array']\n    prime_prefixed_strings(['abcd', 'bcd', 'cde', 'array'], 'a') == ['array']\n    prime_prefixed_strings(['apple', 'avocado', 'banana', 'apricot'], 'a') == ['apple', 'avocado', 'apricot']\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix) and is_prime(len(s))]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["apple", "avocado", "banana", "apricot"], "a"]], "plus_fail_tests": []}], "EvoEval/45": [{"task_id": "EvoEval/45", "solution": "\nfrom typing import List, Tuple\n\ndef primes_sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the prime numbers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1. Non-prime numbers should be ignored.\n    >>> primes_sum_product([])\n    (0, 1)\n    >>> primes_sum_product([1, 2, 3, 4])\n    (5, 6)\n    >>> primes_sum_product([5, 6, 7, 101, 11])\n    (124, 38885)\n    \"\"\"\n\n    def is_prime(n: int) -> bool:\n        \"\"\" Check if a number is prime. \"\"\"\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    prime_sum = 0\n    prime_product = 1\n    for num in numbers:\n        if is_prime(num):\n            prime_sum += num\n            prime_product *= num\n    return (prime_sum, prime_product)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/58": [{"task_id": "EvoEval/58", "solution": "def max_freq_and_sum_check(lst, a, b):\n    from collections import Counter\n    counter = Counter(lst)\n    max_freq = -1\n    for (num, freq) in counter.items():\n        if freq >= num and num > max_freq:\n            max_freq = num\n    if max_freq == -1:\n        return (max_freq, False)\n    else:\n        return (max_freq, max_freq + min(a, b) == max(a, b))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/18": [{"task_id": "EvoEval/18", "solution": "\ndef min_triplets_sum(nums: list):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array of size three. \n\n    If no such sub-array exists, return 0. A sub-array is a contiguous part of an array.\n\n    Examples:\n    min_triplets_sum([2, 3, 4, 1, -7, 4]) == -2   # The sub-array is [1, -7, 4]\n    min_triplets_sum([1, 2, 3, -6, 5, 1, 2]) == -1  # The sub-array is [2, 3, -6]\n    min_triplets_sum([2, 3]) == 0   # No such sub-array exists\n    min_triplets_sum([-1, -2, -3]) == -6   # The sub-array is [-1, -2, -3]\n    \"\"\"\n    if len(nums) < 3:\n        return 0\n    min_sum = float('inf')\n    for i in range(len(nums) - 2):\n        current_sum = sum(nums[i:i + 3])\n        if current_sum < min_sum:\n            min_sum = current_sum\n    return min_sum", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/53": [{"task_id": "EvoEval/53", "solution": "\ndef hex_grade_calculator(grades):\n    hex_grades = []\n    prime_grades = ['D', 'B', '7', '5', '3']\n    for grade in grades:\n        if grade >= 4.0:\n            hex_grades.append('F')\n        elif grade > 3.7:\n            hex_grades.append('E')\n        elif grade > 3.3:\n            hex_grades.append('D')\n        elif grade > 3.0:\n            hex_grades.append('C')\n        elif grade > 2.7:\n            hex_grades.append('B')\n        elif grade > 2.3:\n            hex_grades.append('A')\n        elif grade > 2.0:\n            hex_grades.append('9')\n        elif grade > 1.7:\n            hex_grades.append('8')\n        elif grade > 1.3:\n            hex_grades.append('7')\n        elif grade > 1.0:\n            hex_grades.append('6')\n        elif grade > 0.7:\n            hex_grades.append('5')\n        elif grade > 0.0:\n            hex_grades.append('4')\n        else:\n            hex_grades.append('3')\n    return len([grade for grade in hex_grades if grade in prime_grades])", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/12": [{"task_id": "EvoEval/12", "solution": "\ndef grade_students(student_info, n):\n\n    def count_consonants(name):\n        return sum((1 for c in name.lower() if c in 'bcdfghjklmnpqrstvwxyz'))\n\n    def get_grade(gpa):\n        if gpa == 4.0:\n            return 'A+'\n        elif gpa > 3.7:\n            return 'A'\n        elif gpa > 3.3:\n            return 'A-'\n        elif gpa > 3.0:\n            return 'B+'\n        elif gpa > 2.7:\n            return 'B'\n        elif gpa > 2.3:\n            return 'B-'\n        elif gpa > 2.0:\n            return 'C+'\n        elif gpa > 1.7:\n            return 'C'\n        elif gpa > 1.3:\n            return 'C-'\n        elif gpa > 1.0:\n            return 'D+'\n        elif gpa > 0.7:\n            return 'D'\n        elif gpa > 0.0:\n            return 'D-'\n        else:\n            return 'E'\n    result = []\n    for student in student_info:\n        consonants = count_consonants(student['name'])\n        if consonants == n:\n            student['GPA'] = min(student['GPA'] + 0.3, 4.0)\n        student['grade'] = get_grade(student['GPA'])\n        result.append({'name': student['name'], 'grade': student['grade']})\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[{"name": "Zoe", "GPA": 4.0}, {"name": "Yves", "GPA": 3.7}, {"name": "Xander", "GPA": 3.3}, {"name": "William", "GPA": 3.0}, {"name": "Violet", "GPA": 2.7}, {"name": "Ursula", "GPA": 2.3}, {"name": "Trevor", "GPA": 2.0}, {"name": "Samantha", "GPA": 1.7}, {"name": "Roger", "GPA": 1.3}, {"name": "Quincy", "GPA": 1.0}, {"name": "Pippa", "GPA": 0.7}, {"name": "Oliver", "GPA": 0.0}], 3]], "plus_fail_tests": []}], "EvoEval/80": [{"task_id": "EvoEval/80", "solution": "def cyclic_encode_delete(s: str, c: str) -> tuple:\n\n    def encode(s: str) -> str:\n        return s[2:] + s[:2]\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def decode(s: str) -> str:\n        return s[1:] + s[0]\n    encoded = ''.join((encode(s[i:i + 3]) for i in range(0, len(s), 3)))\n    filtered = ''.join((ch for ch in encoded if ch not in c))\n    is_palindrome_result = is_palindrome(filtered)\n    if is_palindrome_result:\n        return (filtered, is_palindrome_result)\n    else:\n        decoded = ''.join((decode(filtered[i:i + 3]) for i in range(0, len(filtered), 3)))\n        return (decoded, is_palindrome_result)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["abceedcba", "ab"]], "plus_fail_tests": []}], "EvoEval/0": [{"task_id": "EvoEval/0", "solution": "def compare_happiness(a, b):\n\n    def is_happy(s):\n        if len(s) < 3:\n            return False\n        for i in range(len(s) - 2):\n            if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n                return False\n        return True\n    a_happy = is_happy(a)\n    b_happy = is_happy(b)\n    if not a_happy and (not b_happy):\n        return None\n    elif a_happy and (not b_happy):\n        return a\n    elif not a_happy and b_happy:\n        return b\n    else:\n        a = float(a.replace(',', '.'))\n        b = float(b.replace(',', '.'))\n        if a > b:\n            return a\n        elif a < b:\n            return b\n        else:\n            return None", "base_status": "fail", "plus_status": null, "base_fail_tests": [["1,234", "5,678"]], "plus_fail_tests": []}], "EvoEval/64": [{"task_id": "EvoEval/64", "solution": "\ndef modp_prime_numbers(n: int, p: int):\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    modulo_result = pow(2, n, p)\n    prime_numbers = [i for i in range(2, modulo_result) if is_prime(i)]\n    return prime_numbers", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/65": [{"task_id": "EvoEval/65", "solution": "\ndef modp_largest_divisor(n: int, p: int) -> int:\n    \"\"\"Return the largest number smaller than 'p' which divides (2^n modulo p) evenly. \n    If no such number exists, return 1.\n    \n    >>> modp_largest_divisor(3, 5)\n    3\n    >>> modp_largest_divisor(1101, 101)\n    2\n    >>> modp_largest_divisor(0, 101)\n    1\n    >>> modp_largest_divisor(3, 11)\n    8\n    \"\"\"\n    mod = pow(2, n, p)\n    if mod == 0:\n        return p\n    for i in range(p - 1, 0, -1):\n        if mod % i == 0:\n            return i\n    return 1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[10, 2]], "plus_fail_tests": []}], "EvoEval/72": [{"task_id": "EvoEval/72", "solution": "\nfrom typing import List\nfrom math import factorial\n\ndef special_close_factorials(numbers: List[int], threshold: int) -> bool:\n    \"\"\" \n    Check if in given list of numbers, are any two special factorials closer to each other than \n    given threshold. The special factorial (Brazilian factorial) is defined as n! * (n-1)! * (n-2)! * ... * 1! \n    where n > 0.\n\n    For example:\n    >>> special_close_factorials([2, 3], 10)\n    False\n    >>> special_close_factorials([1, 2, 3, 4], 100)\n    True\n    \"\"\"\n\n    def special_factorial(n: int) -> int:\n        \"\"\"\n        Calculate the special factorial of a number.\n        \"\"\"\n        result = 1\n        for i in range(1, n + 1):\n            result *= factorial(i)\n        return result\n    factorials = [special_factorial(n) for n in numbers]\n    for i in range(len(factorials)):\n        for j in range(i + 1, len(factorials)):\n            if abs(factorials[i] - factorials[j]) < threshold:\n                return True\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/81": [{"task_id": "EvoEval/81", "solution": "\nfrom typing import List\n\ndef mean_absolute_deviation_fibfib(n: int) -> float:\n    \"\"\"\n    Given an integer n, calculate the mean absolute deviation of the first n elements of a modified Fibonacci sequence,\n    called the FibFib sequence. The FibFib sequence is defined as follows:\n    \n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    \n    Then, compute the Mean Absolute Deviation (MAD) of these n elements. The MAD is the average absolute difference\n    between each element and the mean of this set:\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation_fibfib(1)\n    0.0\n    >>> mean_absolute_deviation_fibfib(5)\n    0.64\n    >>> mean_absolute_deviation_fibfib(8)\n    3.375\n    \"\"\"\n\n    def fibfib(n: int) -> int:\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 0\n        elif n == 2:\n            return 1\n        else:\n            return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n    fibfib_sequence = [fibfib(i) for i in range(n)]\n    mean = sum(fibfib_sequence) / n\n    absolute_deviations = [abs(x - mean) for x in fibfib_sequence]\n    mad = sum(absolute_deviations) / n\n    return round(mad, 3)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[100]], "plus_fail_tests": []}], "EvoEval/17": [{"task_id": "EvoEval/17", "solution": "\ndef fibfib_search(n: int, lst: list) -> int:\n\n    def fibfib(n: int) -> int:\n        if n == 0 or n == 1:\n            return 0\n        elif n == 2:\n            return 1\n        else:\n            return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n    freq_dict = {}\n    for num in lst:\n        if num > 0:\n            freq_dict[num] = freq_dict.get(num, 0) + 1\n    for num in sorted(freq_dict.keys(), reverse=True):\n        if freq_dict[num] >= fibfib(n):\n            return num\n    return -1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[100, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]], "plus_fail_tests": []}]}}