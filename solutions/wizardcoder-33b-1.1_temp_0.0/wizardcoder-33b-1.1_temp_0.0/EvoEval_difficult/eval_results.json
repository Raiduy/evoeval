{"eval": {"EvoEval/76": [{"task_id": "EvoEval/76", "solution": "def complex_power(x, n, m):\n    if n == 1 or m == 1:\n        return False\n    else:\n        return n ** m == x", "base_status": "fail", "plus_status": null, "base_fail_tests": [[16, 2, 2]], "plus_fail_tests": []}], "EvoEval/94": [{"task_id": "EvoEval/94", "solution": "def complexity_increased(lst, n):\n    if not any((i > 0 for i in lst)):\n        return -1\n    primes = [i for i in lst if is_prime(i)]\n    if not primes:\n        return -1\n    total = 0\n    for prime in primes:\n        for digit in str(prime):\n            total += int(digit) ** n\n    return total", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3], 2]], "plus_fail_tests": []}], "EvoEval/35": [{"task_id": "EvoEval/35", "solution": "def max_element_diff(l: list, n: int):\n    if n > len(l):\n        return None\n    else:\n        l.sort(reverse=True)\n        nth_max = l[n - 1]\n        diff = l[0] - nth_max\n        return (nth_max, diff)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/55": [{"task_id": "EvoEval/55", "solution": "def fib(n: int, x: int, operation: str) -> int:\n    if n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    else:\n        fib_numbers = [0, 1, 1]\n        for i in range(3, n + 1):\n            if i % x == 0:\n                if operation == 'square':\n                    fib_numbers.append(fib_numbers[i - 1] ** 2)\n                elif operation == 'add_two':\n                    fib_numbers.append(fib_numbers[i - 1] + 2)\n                else:\n                    fib_numbers.append(0)\n            else:\n                fib_numbers.append(fib_numbers[i - 1] + fib_numbers[i - 2])\n        return fib_numbers[n]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[10, 5, "square"]], "plus_fail_tests": []}], "EvoEval/19": [{"task_id": "EvoEval/19", "solution": "from typing import List, Tuple\n\n\ndef sort_numbers(numbers: str, order: List[str]) -> str:\n    num_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    num_list = numbers.split()\n    num_list.sort(key=lambda x: (order.index(x) if x in order else len(order), num_dict[x]))\n    return ' '.join(num_list)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["five four three two one zero five four three two one zero", []]], "plus_fail_tests": []}], "EvoEval/89": [{"task_id": "EvoEval/89", "solution": "def advanced_encrypt(s, n):\n    result = ''\n    for char in s:\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            if n % 2 == 0:\n                result += chr((ord(char) - ascii_offset + 2 * n) % 26 + ascii_offset)\n            else:\n                result += chr((ord(char) - ascii_offset - 2 * n) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["asdfghjkl", 3]], "plus_fail_tests": []}], "EvoEval/81": [{"task_id": "EvoEval/81", "solution": "def numerical_letter_grade_with_weightage(grades):\n    letter_grades = []\n    for grade in grades:\n        weighted_gpa = min(grade[0] * grade[1], 4.0)\n        if weighted_gpa >= 3.7:\n            letter_grades.append('A')\n        elif weighted_gpa >= 3.3:\n            letter_grades.append('A-')\n        elif weighted_gpa >= 3.0:\n            letter_grades.append('B+')\n        elif weighted_gpa >= 2.7:\n            letter_grades.append('B')\n        elif weighted_gpa >= 2.3:\n            letter_grades.append('B-')\n        elif weighted_gpa >= 2.0:\n            letter_grades.append('C+')\n        elif weighted_gpa >= 1.7:\n            letter_grades.append('C')\n        elif weighted_gpa >= 1.3:\n            letter_grades.append('C-')\n        elif weighted_gpa >= 1.0:\n            letter_grades.append('D+')\n        elif weighted_gpa >= 0.7:\n            letter_grades.append('D')\n        elif weighted_gpa >= 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[4.0, 0.8], [3, 1.2], [1.7, 0.9], [2, 1], [3.5, 1.1]]]], "plus_fail_tests": []}], "EvoEval/44": [{"task_id": "EvoEval/44", "solution": "def change_base(x: str, base: int, new_base: int):\n    try:\n        base_10 = int(x, base)\n    except ValueError:\n        return 'invalid base'\n    alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    if base_10 == 0:\n        return '0'\n    else:\n        result = ''\n        while base_10:\n            (base_10, remainder) = divmod(base_10, new_base)\n            result = alphabet[remainder] + result\n        return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/57": [{"task_id": "EvoEval/57", "solution": "def monotonic_sublist(l: list, k: int):\n    for i in range(len(l) - k + 1):\n        sublist = l[i:i + k]\n        if all((sublist[i] <= sublist[i + 1] for i in range(len(sublist) - 1))) or all((sublist[i] >= sublist[i + 1] for i in range(len(sublist) - 1))):\n            return True\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/82": [{"task_id": "EvoEval/82", "solution": "def prime_length(string, opt=None):\n    if opt == 'letters':\n        return is_prime(len(set(string)))\n    elif opt == 'words':\n        return is_prime(len([word for word in string.split() if word]))\n    else:\n        return is_prime(len(string))", "base_status": "fail", "plus_status": null, "base_fail_tests": [["hello,      world", "words"]], "plus_fail_tests": []}], "EvoEval/65": [{"task_id": "EvoEval/65", "solution": "def circular_shift(x, shift, direction):\n    if not isinstance(x, int) or x < 0 or (not isinstance(shift, int)) or (shift < 0) or (direction not in ['R', 'L']):\n        return 'Invalid Input'\n    x = str(x)\n    if shift > len(x):\n        return x[::-1]\n    if direction == 'R':\n        return x[-shift:] + x[:-shift]\n    else:\n        return x[shift:] + x[:shift]", "base_status": "fail", "plus_status": null, "base_fail_tests": [["", 2, "R"]], "plus_fail_tests": []}], "EvoEval/92": [{"task_id": "EvoEval/92", "solution": "def any_int_complex(x, y, z):\n    try:\n        x = int(x)\n        y = int(y)\n        z = int(z)\n    except ValueError:\n        return 'Invalid Input'\n    if x == y + z or y == x + z or z == x + y:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/83": [{"task_id": "EvoEval/83", "solution": "def starts_one_ends(n, x, y):\n    if not 1 <= n <= 5 or not 0 <= x <= 9 or (not 0 <= y <= 9):\n        return -1\n    count = 0\n    start = int('1' + '0' * (n - 1))\n    end = int('1' + '0' * n)\n    for i in range(start, end):\n        if int(str(i)[0]) == x or int(str(i)[-1]) == y:\n            count += 1\n    return count if count > 0 else -1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1, 0, 0]], "plus_fail_tests": []}], "EvoEval/31": [{"task_id": "EvoEval/31", "solution": "def is_prime_sum(lst, n):\n    prime_set = set()\n    for num in lst:\n        if is_prime(num):\n            prime_set.add(num)\n        if n - num in prime_set:\n            return True\n    return False", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 7, 5, 2, 11], 12]], "plus_fail_tests": []}], "EvoEval/25": [{"task_id": "EvoEval/25", "solution": "from typing import List, Tuple\n\ndef factorize_and_count(n: int) -> List[Tuple[int, int]]:\n    primes = sieve_of_eratosthenes(int(math.sqrt(n)) + 1)\n    factors = []\n    for prime in primes:\n        if prime * prime > n:\n            break\n        count = 0\n        while n % prime == 0:\n            n //= prime\n            count += 1\n        if count > 0:\n            factors.append((prime, count))\n    if n != 1:\n        factors.append((n, 1))\n    return factors", "base_status": "fail", "plus_status": null, "base_fail_tests": [[8]], "plus_fail_tests": []}], "EvoEval/75": [{"task_id": "EvoEval/75", "solution": "def is_multiply_prime(a, b):\n    primes = [i for i in range(2, a + 1) if is_prime(i)]\n    factors = []\n    for prime in primes:\n        while a % prime == 0:\n            factors.append(prime)\n            a /= prime\n    return (len(set(factors)) == b, sorted(list(set(factors))))", "base_status": "fail", "plus_status": null, "base_fail_tests": [[30, 3]], "plus_fail_tests": []}], "EvoEval/70": [{"task_id": "EvoEval/70", "solution": "def strange_sort_list(lst, lst2):\n    merged_list = lst + lst2\n    merged_list = list(set(merged_list))\n    odd_numbers = [num for num in merged_list if num % 2 != 0]\n    even_numbers = [num for num in merged_list if num % 2 == 0]\n    odd_numbers.sort()\n    even_numbers.sort()\n    result = []\n    while odd_numbers or even_numbers:\n        if odd_numbers:\n            result.append(odd_numbers.pop(0))\n        if even_numbers:\n            result.append(even_numbers.pop())\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 4], [3, 4, 5, 6]]], "plus_fail_tests": []}], "EvoEval/32": [{"task_id": "EvoEval/32", "solution": "import math\nfrom typing import Tuple\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n.\n    The coefficients xs are integers and -10^6 <= xs[i] <= 10^6 where 0 <= i <= n.\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zeros_interval(xs: list, interval: Tuple[float, float]):\n    \"\"\"\n    xs are coefficients of a polynomial.\n    find_zeros_interval finds one x such that poly(x) = 0 within the given interval (inclusive).\n    The interval is given as a tuple\n    of two floats in the form (start, end), where -10^6 <= start < end <= 10^6.\n    If poly(start) and poly(end) have opposite signs, return a zero point (round to two decimal places).\n    Otherwise, return None.\n    >>> find_zeros_interval([1, 2], (-5, 1))\n    -0.5\n    >>> find_zeros_interval([-6, 11, -6, 1], (0, 4))\n    2.0\n    \"\"\"\n    (start, end) = interval\n    if poly(xs, start) * poly(xs, end) < 0:\n        while abs(end - start) > 0.01:\n            mid = (start + end) / 2\n            if poly(xs, mid) == 0:\n                return round(mid, 2)\n            elif poly(xs, mid) * poly(xs, start) < 0:\n                end = mid\n            else:\n                start = mid\n        return round((start + end) / 2, 2)\n    else:\n        return None", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[10, -15, 56, -40], [-10, 10]]], "plus_fail_tests": []}], "EvoEval/91": [{"task_id": "EvoEval/91", "solution": "def detect_boredom(S, substrings):\n    placeholders = ['{}', '()', '[]']\n    for p in placeholders:\n        S = re.sub('\\\\{.*?\\\\}'.format(p), 'placeholder', S)\n    S = re.sub('\"[^\"]*\"', 'placeholder', S)\n    S = re.sub(\"'[^']*'\", 'placeholder', S)\n    sentences = re.split('[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        for substring in substrings:\n            if sentence.strip().startswith(substring):\n                count += 1\n                break\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [["\"Hello! How are you?\" He asked. Hello, I replied", ["Hello"]]], "plus_fail_tests": []}], "EvoEval/10": [{"task_id": "EvoEval/10", "solution": "def is_palindrome(string: str) -> bool:\n    \"\"\" \n    Test if given string is a palindrome.\n    \"\"\"\n\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\"\n    Find the shortest palindrome that begins with a supplied string and is case insensitive.\n    Algorithm idea:\n    - Find the longest postfix of supplied string that is a palindrome considering case insensitivity.\n    - Append to the end of the string, in the reverse order, the string prefix that comes before the palindromic suffix.\n    - Special case: If the string is already a palindrome, return the string as is.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('Cat')\n    'CataC'\n    >>> make_palindrome('cAta')\n    'cAtac'\n    \"\"\"\n    string = string.lower()\n    if is_palindrome(string):\n        return string\n    for i in range(len(string)):\n        suffix = string[i:]\n        if is_palindrome(suffix):\n            prefix = string[:i]\n            return string + prefix[::-1]", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Cat"]], "plus_fail_tests": []}], "EvoEval/38": [{"task_id": "EvoEval/38", "solution": "def encode_complex(s: str, k: int):\n    \"\"\"\n    returns encoded string by cycling groups of k characters, where k is a positive integer.\n    The encoded string should also not contain any vowels.\n    \"\"\"\n    # split string to groups. Each of length k.\n    groups = [s[(k * i):min((k * i + k), len(s))] for i in range((len(s) + (k-1)) // k)]\n    # cycle elements in each group. Unless group has fewer elements than k.\n    groups = [(group[1:] + group[0]) if len(group) == k else group for group in groups]\n    # remove vowels from encoded strings\n    groups = [group.replace(vowel, '') for group in groups for vowel in 'aeiou']\n    return \"\".join(groups)\n\n\ndef decode_complex(s: str, k: int):\n    \"\"\"\n    takes as input string encoded with encode_complex function and the original length of the string before encoding. \n    Returns decoded string.\n    Remember, the original string before encoding did not contain any vowels.\n    \"\"\"\n    groups = [s[k * i:min(k * i + k, len(s))] for i in range((len(s) + (k - 1)) // k)]\n    groups = [group[-1] + group[:-1] if len(group) == k else group for group in groups]\n    return ''.join(groups)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["pogpogpogpgpog", 3]], "plus_fail_tests": []}], "EvoEval/50": [{"task_id": "EvoEval/50", "solution": "def encode_shift(s: str, n: int, offset: str):\n    \"\"\"\n    Returns an encoded string by shifting every character in the string by 'n' in the alphabet. \n    The function also takes an offset, which is a string of the same length as 's'. \n    This offset is used to add a level of customization to the encoding.\n    The shift for each character in 's' is determined by the corresponding character in 'offset'.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + n + ord(offset[i]) - ord(\"a\")) % 26) + ord(\"a\")) for i, ch in enumerate(s)])\n\n\ndef decode_shift(s: str, n: int, offset: str) -> str:\n    \"\"\"\n    Takes as input a string encoded with the encode_shift function and returns the decoded string. \n    The function also takes an offset, which is a string of the same length as 's'. \n    This offset is used to decode the string in a manner consistent with the encoding process.\n    The shift for each character in 's' is determined by the corresponding character in 'offset'.\n    \"\"\"\n    return ''.join([chr((ord(ch) - ord('a') - n - ord(offset[i]) + ord('a')) % 26 + ord('a')) for (i, ch) in enumerate(s)])", "base_status": "fail", "plus_status": null, "base_fail_tests": [["asd", 2, "dcd"]], "plus_fail_tests": []}], "EvoEval/61": [{"task_id": "EvoEval/61", "solution": "def correct_bracketing_advanced(brackets: str):\n    stack = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    for bracket in brackets:\n        if bracket in bracket_pairs.values():\n            stack.append(bracket)\n        elif bracket in bracket_pairs.keys():\n            if stack == [] or bracket_pairs[bracket] != stack.pop():\n                return False\n    return stack == []", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/26": [{"task_id": "EvoEval/26", "solution": "from typing import List, Tuple\n\n\ndef remove_duplicates_and_count(numbers: List[int]) -> Tuple[List[int], List[int]]:\n    counts = {}\n    unique_numbers = []\n    unique_counts = []\n    for num in numbers:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    for num in numbers:\n        if counts[num] == 1:\n            unique_numbers.append(num)\n            unique_counts.append(counts[num])\n    return (unique_numbers, unique_counts)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/62": [{"task_id": "EvoEval/62", "solution": "def derivative(xs: list, x: float):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return derivative of this polynomial at the given value of x\n    >>> derivative([3, 1, 2, 4, 5], 2)\n    217\n    >>> derivative([1, 2, 3], -1)\n    -4\n    >>> derivative([4, -2, 0, 1], 0)\n    -2\n    >>> derivative([1, 1, 1, 1, 1], 10)\n    4321\n    \"\"\"\n    derivative = 0\n    for i in range(1, len(xs)):\n        derivative += i * xs[i] * x ** (i - 1)\n    return derivative", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/88": [{"task_id": "EvoEval/88", "solution": "def sort_array(array, pivot):\n    copy_array = array[:]\n    pivot_value = copy_array[pivot]\n    (copy_array[pivot], copy_array[0]) = (copy_array[0], copy_array[pivot])\n    i = 1\n    for j in range(1, len(copy_array)):\n        if copy_array[j] < pivot_value:\n            (copy_array[i], copy_array[j]) = (copy_array[j], copy_array[i])\n            i += 1\n    (copy_array[0], copy_array[i - 1]) = (copy_array[i - 1], copy_array[0])\n    if (copy_array[0] + pivot_value) % 2 == 1:\n        copy_array[:i] = sorted(copy_array[:i])\n    else:\n        copy_array[:i] = sorted(copy_array[:i], reverse=True)\n    copy_array[i:] = sorted(copy_array[i:])\n    return copy_array", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[], 0]], "plus_fail_tests": []}], "EvoEval/14": [{"task_id": "EvoEval/14", "solution": "from typing import List, Tuple\n\ndef all_prefix_suffix_pairs(string: str, min_length: int) -> List[Tuple[str, str]]:\n    result = []\n    for i in range(min_length, len(string)):\n        for j in range(min_length, len(string) - i + 1):\n            result.append((string[:i], string[-j:]))\n    result.sort(key=lambda x: (len(x[0]), x[0], len(x[1]), x[1]))\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["abcadg", 2]], "plus_fail_tests": []}], "EvoEval/78": [{"task_id": "EvoEval/78", "solution": "def hex_key_primes(num):\n    primes = ['2', '3', '5', '7', 'B', 'D']\n    prime_count = 0\n    prime_sum = 0\n    for digit in num:\n        if digit in primes:\n            prime_count += 1\n            if digit == '2':\n                prime_sum += 2\n            elif digit == '3':\n                prime_sum += 3\n            elif digit == '5':\n                prime_sum += 5\n            elif digit == '7':\n                prime_sum += 7\n            elif digit == 'B':\n                prime_sum += 11\n            elif digit == 'D':\n                prime_sum += 13\n    if prime_count > len(num) - prime_count:\n        return (prime_count, 'Dominant', prime_sum)\n    else:\n        return (prime_count, 'Non-dominant', prime_sum)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["2020"]], "plus_fail_tests": []}], "EvoEval/2": [{"task_id": "EvoEval/2", "solution": "def truncate_number(number: float, digit_limit: int) -> str:\n    (integer_part, decimal_part) = str(number).split('.')\n    decimal_part = decimal_part[:digit_limit]\n    decimal_part += '0' * (digit_limit - len(decimal_part))\n    return '0.' + decimal_part", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1.2345e-05, 6]], "plus_fail_tests": []}], "EvoEval/71": [{"task_id": "EvoEval/71", "solution": "def triangle_area(a, b, c, d, e, f):\n    if (d - b) * (c - a) == (f - b) * (e - a):\n        return 'Invalid'\n    else:\n        area = 0.5 * abs(a * (d - f) + c * (f - b) + e * (b - d))\n        return round(area, 3)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[0, 0, 0, 1, 1, 0]], "plus_fail_tests": []}], "EvoEval/85": [{"task_id": "EvoEval/85", "solution": "def add(lst, n):\n    total = 0\n    prime_count = 0\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            total += lst[i]\n        if is_prime(lst[i]):\n            prime_count += 1\n    if prime_count == 0:\n        return -1\n    else:\n        return total * prime_count", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 11, 6, 7], 4]], "plus_fail_tests": []}], "EvoEval/47": [{"task_id": "EvoEval/47", "solution": "def weighted_median(l: list, w: list):\n    \"\"\"Return weighted median of elements in the list l with corresponding weights in list w. \n    If there are two middles, return the one associated with higher weight. If equal, return their average.\n    All weights are non-negative integers.\n\n    >>> weighted_median([3, 1, 2, 4, 5], [2, 1, 3, 2, 1])\n    3\n    >>> weighted_median([-10, 4, 6, 1000, 10, 20], [1, 2, 3, 4, 2, 1])\n    10\n    >>> weighted_median([1, 2], [1, 1])\n    1.5\n    \"\"\"\n    lw = list(zip(l, w))\n    lw.sort()\n    total_weight = sum(w)\n    cum_weight = [0]\n    for i in range(len(lw)):\n        cum_weight.append(cum_weight[i] + lw[i][1])\n    for i in range(len(cum_weight)):\n        if cum_weight[i] >= total_weight / 2 and cum_weight[i - 1] < total_weight / 2:\n            if total_weight % 2 == 0:\n                return (lw[i - 1][0] + lw[i][0]) / 2\n            else:\n                return lw[i][0]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 1, 2, 4, 5], [2, 1, 3, 2, 1]]], "plus_fail_tests": []}], "EvoEval/52": [{"task_id": "EvoEval/52", "solution": "def below_above_threshold(l: list, t1: int, t2: int, s: str):\n    if s == 'below':\n        for (i, num) in enumerate(l):\n            if num >= t1:\n                return i\n        return True\n    elif s == 'above':\n        for (i, num) in enumerate(l):\n            if num <= t2:\n                return i\n        return True\n    else:\n        return -1", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/40": [{"task_id": "EvoEval/40", "solution": "def triples_sum_to_target(l: list, k: int):\n    l.sort()\n    count = 0\n    for i in range(len(l) - 2):\n        left = i + 1\n        right = len(l) - 1\n        while left < right:\n            if l[i] + l[left] + l[right] == k:\n                count += 1\n                left += 1\n                right -= 1\n            elif l[i] + l[left] + l[right] < k:\n                left += 1\n            else:\n                right -= 1\n    return count if count > 0 else -1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 0]], "plus_fail_tests": []}], "EvoEval/74": [{"task_id": "EvoEval/74", "solution": "def total_match(lst1, lst2, k):\n    total_chars_lst1 = sum((len(s) for s in lst1))\n    total_chars_lst2 = sum((len(s) for s in lst2))\n    count_lst1 = sum((1 for s in lst1 if len(s) <= k))\n    count_lst2 = sum((1 for s in lst2 if len(s) <= k))\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    elif count_lst1 > count_lst2:\n        return lst1\n    elif count_lst1 < count_lst2:\n        return lst2\n    else:\n        return lst1", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/13": [{"task_id": "EvoEval/13", "solution": "from typing import List\n\ndef multiple_greatest_common_divisors(numbers: List[int]) -> int:\n    \"\"\" \n    Return the greatest common divisor of a list of integers. The list can contain 2 to 10 elements, all are positive integers and unique. If the GCD is 1, return -1.\n    >>> multiple_greatest_common_divisors([3,5])\n    -1\n    >>> multiple_greatest_common_divisors([25, 15, 35])\n    5\n    >>> multiple_greatest_common_divisors([48, 60, 36])\n    12\n    >>> multiple_greatest_common_divisors([5, 10, 15, 20, 25])\n    5\n    \"\"\"\n    num1 = numbers[0]\n    num2 = numbers[1]\n    gcd = math.gcd(num1, num2)\n    for i in range(2, len(numbers)):\n        gcd = math.gcd(gcd, numbers[i])\n    if gcd == 1:\n        return -1\n    else:\n        return gcd", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 5]]], "plus_fail_tests": []}], "EvoEval/98": [{"task_id": "EvoEval/98", "solution": "def count_spec_chars(s, m, n):\n    if len(s) < m or len(s) > n:\n        return -1\n    vowels = 'AEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    ascii_sum_vowels = 0\n    ascii_sum_consonants = 0\n    for i in range(len(s)):\n        if s[i].isalpha():\n            if i % 2 == 0:\n                if s[i] in vowels:\n                    ascii_sum_vowels += ord(s[i])\n            elif s[i] in consonants:\n                ascii_sum_consonants += ord(s[i])\n    return (ascii_sum_vowels, ascii_sum_consonants)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/34": [{"task_id": "EvoEval/34", "solution": "def unique(l: list, from_index: int, to_index: int):\n    if from_index < 0 or to_index >= len(l) or from_index > to_index:\n        return 'Invalid range'\n    sublist = l[from_index:to_index + 1]\n    unique_elements = []\n    for i in sublist:\n        if i not in unique_elements:\n            unique_elements.append(i)\n    for i in range(len(unique_elements)):\n        for j in range(i + 1, len(unique_elements)):\n            if unique_elements[i] > unique_elements[j]:\n                (unique_elements[i], unique_elements[j]) = (unique_elements[j], unique_elements[i])\n    return unique_elements", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/63": [{"task_id": "EvoEval/63", "solution": "def customFibFib(n: int, startSequence: list, p: int):\n    if n < 3:\n        return startSequence[n]\n    else:\n        sequence = startSequence\n        for i in range(3, n + 1):\n            next_element = sequence[i - 1] + sequence[i - 2] + sequence[i - 3]\n            if next_element > p:\n                return 'Limit Exceeded'\n            sequence.append(next_element)\n        return sequence[n]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/22": [{"task_id": "EvoEval/22", "solution": "from typing import List, Any, Union\n\ndef filter_and_sort_integers(values: List[Any]) -> Union[List[int], str]:\n    integers = [i for i in values if isinstance(i, int)]\n    if not integers:\n        return 'No integers found'\n    for i in range(len(integers)):\n        for j in range(len(integers) - 1):\n            if integers[j] > integers[j + 1]:\n                (integers[j], integers[j + 1]) = (integers[j + 1], integers[j])\n    return integers", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/20": [{"task_id": "EvoEval/20", "solution": "from typing import List, Tuple\n\ndef find_subset_closest_elements(numbers: List[float], subset_size: int) -> Tuple[float, ...]:\n    numbers.sort()\n    min_diff = float('inf')\n    min_sum = float('inf')\n    min_first = float('inf')\n    result = ()\n    for i in range(len(numbers) - subset_size + 1):\n        subset = numbers[i:i + subset_size]\n        diff = subset[-1] - subset[0]\n        sum_subset = sum(subset)\n        if diff < min_diff or (diff == min_diff and sum_subset < min_sum) or (diff == min_diff and sum_subset == min_sum and (subset[0] < min_first)):\n            min_diff = diff\n            min_sum = sum_subset\n            min_first = subset[0]\n            result = tuple(subset)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/33": [{"task_id": "EvoEval/33", "solution": "def sort_third_modified(l: list, m: list):\n    concat_list = l + m\n    divisible_by_3 = [concat_list[i] for i in range(len(concat_list)) if i % 3 == 0]\n    divisible_by_3.sort(reverse=True)\n    for i in range(len(concat_list)):\n        if i % 3 == 0:\n            concat_list[i] = divisible_by_3.pop(0)\n    return concat_list", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/90": [{"task_id": "EvoEval/90", "solution": "def next_smallest_and_largest(lst):\n    if len(lst) < 2:\n        return (None, None)\n    smallest = second_smallest = float('inf')\n    largest = second_largest = float('-inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest and num != smallest:\n            second_smallest = num\n        if num > largest:\n            second_largest = largest\n            largest = num\n        elif largest > num > second_largest and num != largest:\n            second_largest = num\n    if second_smallest == float('inf') or second_largest == float('-inf'):\n        return (None, None)\n    return (second_smallest, second_largest)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/67": [{"task_id": "EvoEval/67", "solution": "def advanced_fruit_distribution(s, n, m):\n    words = s.split()\n    apples = int(words[0])\n    oranges = int(words[2])\n    mangoes = n - apples - oranges\n    if mangoes < m:\n        return -1\n    else:\n        return mangoes", "base_status": "fail", "plus_status": null, "base_fail_tests": [["5 apples and 6 oranges", 19, 10]], "plus_fail_tests": []}], "EvoEval/42": [{"task_id": "EvoEval/42", "solution": "def incr_list_conditionally(l: list, ignore: list):\n    if all((isinstance(i, int) for i in ignore)):\n        return [i + 1 if i not in ignore else i for i in l]\n    else:\n        return 'Ignore list should only contain integers'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/30": [{"task_id": "EvoEval/30", "solution": "def get_positive_and_index(l: list):\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    return [(val, idx) for (idx, val) in enumerate(l) if val > 0 and is_prime(idx)]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/37": [{"task_id": "EvoEval/37", "solution": "def sort_even_odd(l: list, m: list):\n    l_with_indices = [(val, idx) for (idx, val) in enumerate(l)]\n    even_indices = [tup for tup in l_with_indices if tup[1] % 2 == 0]\n    even_indices.sort(key=lambda x: m.index(x[0]) if x[0] in m else len(m))\n    result = [None] * len(l)\n    for i in range(0, len(l), 2):\n        result[i] = l[i]\n    for (i, tup) in enumerate(even_indices):\n        result[2 * i + 1] = tup[0]\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3], [3, 2, 1]]], "plus_fail_tests": []}], "EvoEval/84": [{"task_id": "EvoEval/84", "solution": "def enhanced_solve(N, M):\n    \"\"\"Given two positive integers N and M, compute the total sum of their digits in binary,\n    then multiply by the number of primes between N and M, inclusive.\n    Final result should be a binary string\n    \"\"\"\n    sum_of_digits = sum((int(digit) for digit in bin(N)[2:] + bin(M)[2:]))\n    num_of_primes = sum((is_prime(i) for i in range(N, M + 1)))\n    result = sum_of_digits * num_of_primes\n    return bin(result)[2:]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[147, 247]], "plus_fail_tests": []}], "EvoEval/97": [{"task_id": "EvoEval/97", "solution": "def multiplyComplex(a, b):\n    (a_real, a_imag) = map(int, a[:-1].split('+' if '+' in a else '-'))\n    (b_real, b_imag) = map(int, b[:-1].split('+' if '+' in b else '-'))\n    real = a_real * b_real - a_imag * b_imag\n    imaginary = a_real * b_imag + a_imag * b_real\n    return {'real': real, 'imaginary': imaginary}", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/21": [{"task_id": "EvoEval/21", "solution": "from typing import List, Optional\n\ndef rescale_to_unit(numbers: List[Optional[float]]) -> List[Optional[float]]:\n    non_none_numbers = [num for num in numbers if num is not None]\n    min_num = min(non_none_numbers)\n    max_num = max(non_none_numbers)\n    range_num = max_num - min_num\n    rescaled_numbers = [round((num - min_num) / range_num, 2) if num is not None else None for num in numbers]\n    return rescaled_numbers", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/3": [{"task_id": "EvoEval/3", "solution": "from typing import List, Tuple\n\ndef account_balance(operations: List[Tuple[str, int]], daily_limit: int) -> str:\n    balance = 0\n    daily_withdrawal = 0\n    for (operation, amount) in operations:\n        if operation == 'deposit':\n            balance += amount\n        elif operation == 'withdrawal':\n            if amount > daily_limit:\n                return 'Daily limit exceeded'\n            if daily_withdrawal + amount > daily_limit:\n                return 'Daily limit exceeded'\n            daily_withdrawal += amount\n            balance -= amount\n        if balance < 0:\n            return 'Balance below zero'\n    return 'All operations successful'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[["deposit", 200], ["withdrawal", 50], ["withdrawal", 100], ["deposit", 500], ["withdrawal", 650]], 700]], "plus_fail_tests": []}], "EvoEval/68": [{"task_id": "EvoEval/68", "solution": "def pluck_and_replace(arr, replacement):\n    if not arr:\n        return []\n    if replacement in arr:\n        return [-1, -1, replacement, -1]\n    even_values = [x for x in arr if x % 2 == 0]\n    if not even_values:\n        return []\n    smallest_value = min(even_values)\n    index = arr.index(smallest_value)\n    arr[index] = replacement\n    return [smallest_value, index, replacement, arr.index(replacement)]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/46": [{"task_id": "EvoEval/46", "solution": "def fib4_memo(n: int, m: int):\n    if n < 0 or m > n:\n        return 'Invalid input'\n    fib4 = [0, 0, 2, 0]\n    for i in range(4, n + 1):\n        fib4.append(fib4[i - 1] + fib4[i - 2] + fib4[i - 3] + fib4[i - 4])\n    return fib4[-m]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/27": [{"task_id": "EvoEval/27", "solution": "def flip_case_special(string: str, special_index: int) -> str:\n    special_index = special_index % len(string)\n    result = ''\n    for i in range(len(string)):\n        if i == special_index:\n            if string[i].isupper():\n                result += string[i].lower()\n            else:\n                result += string[i]\n        elif string[i].isupper():\n            result += string[i].lower()\n        else:\n            result += string[i].upper()\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/23": [{"task_id": "EvoEval/23", "solution": "def strlen_custom(string: str, ignore_whitespace: bool=False, count_only_alphabets: bool=False) -> int:\n    if ignore_whitespace and count_only_alphabets:\n        return len([char for char in string if char.isalpha()])\n    elif ignore_whitespace:\n        return len([char for char in string if not char.isspace()])\n    elif count_only_alphabets:\n        return len([char for char in string if char.isalpha()])\n    else:\n        return len(string)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["\t\n", true, false]], "plus_fail_tests": []}], "EvoEval/8": [{"task_id": "EvoEval/8", "solution": "from typing import List, Tuple\n\n\ndef sum_product_odd_even(numbers: List[int]) -> Tuple[int, int, int, int]:\n    sum_odd = 0\n    product_odd = 1\n    sum_even = 0\n    product_even = 1\n    for num in numbers:\n        if num % 2 == 0:\n            sum_even += num\n            product_even *= num\n        else:\n            sum_odd += num\n            product_odd *= num\n    return (sum_odd, product_odd, sum_even, product_even)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/99": [{"task_id": "EvoEval/99", "solution": "def closest_integer(value, base):\n    if '.' in value:\n        (integer_part, fractional_part) = value.split('.')\n        decimal_value = int(integer_part, base)\n        fractional_value = 0\n        for (i, digit) in enumerate(fractional_part):\n            fractional_value += int(digit, base) * base ** (-(i + 1))\n        decimal_value += fractional_value\n        decimal_value = round(decimal_value)\n        result = ''\n        while decimal_value:\n            result = str(decimal_value % base) + result\n            decimal_value //= base\n        return result\n    else:\n        decimal_value = int(value, base)\n        return str(decimal_value)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["10", 2]], "plus_fail_tests": []}], "EvoEval/1": [{"task_id": "EvoEval/1", "solution": "from typing import List, Tuple\n\ndef separate_paren_groups(paren_string: str, remove_unbalanced: bool=False) -> Tuple[List[str], int]:\n    groups = []\n    current_group = ''\n    unbalanced_count = 0\n    open_count = 0\n    for char in paren_string:\n        if char == '(':\n            open_count += 1\n            current_group += char\n        elif char == ')':\n            if open_count > 0:\n                open_count -= 1\n                current_group += char\n            else:\n                unbalanced_count += 1\n        elif char == ' ':\n            if open_count == 0 and current_group != '':\n                groups.append(current_group)\n                current_group = ''\n    if current_group != '':\n        if open_count > 0 and remove_unbalanced:\n            unbalanced_count += 1\n        else:\n            groups.append(current_group)\n    return (groups, unbalanced_count)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["()()", true]], "plus_fail_tests": []}], "EvoEval/11": [{"task_id": "EvoEval/11", "solution": "from typing import List, Tuple\n\ndef string_xor_advanced(a: str, b: str, c: str, rotation: Tuple[int, int]) -> str:\n    a = a[rotation[0]:] + a[:rotation[0]]\n    b = b[rotation[1]:] + b[:rotation[1]]\n    c = c[rotation[1]:] + c[:rotation[1]]\n    result = ''\n    for i in range(len(a)):\n        result += str(int(a[i]) ^ int(b[i]) ^ int(c[i]))\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/95": [{"task_id": "EvoEval/95", "solution": "def check_dict_case_content(dict):\n    if not dict:\n        return False\n    key_length = len(next(iter(dict.keys())))\n    for (key, value) in dict.items():\n        if not isinstance(key, str) or not isinstance(value, str):\n            return False\n        if not (key.islower() or key.isupper()) or len(key) != key_length:\n            return False\n        if not value.istitle():\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/29": [{"task_id": "EvoEval/29", "solution": "from typing import List, Tuple\n\ndef filter_by_prefix_suffix(strings: List[str], prefix_suffix: Tuple[str, str]) -> List[str]:\n    (prefix, suffix) = prefix_suffix\n    filtered_strings = [s for s in strings if s.startswith(prefix) and s.endswith(suffix)]\n    return sorted(list(set(filtered_strings)))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/6": [{"task_id": "EvoEval/6", "solution": "from typing import List, Tuple\n\ndef parse_nested_parens(paren_string: str) -> List[Tuple[str, int]]:\n    groups = paren_string.split()\n    result = []\n    for group in groups:\n        stack = []\n        max_depth = {'()': 0, '[]': 0, '{}': 0}\n        cur_depth = 0\n        for char in group:\n            if char in '([{':\n                stack.append(char)\n                cur_depth += 1\n                if cur_depth > max_depth[stack[-1] + stack[-2]]:\n                    max_depth[stack[-1] + stack[-2]] = cur_depth\n            elif char in ')]}':\n                cur_depth -= 1\n                stack.pop()\n        result.append((group, {k: v for (k, v) in max_depth.items() if v > 0}))\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["(()[]) (([{}])) [] () (([])()[])"]], "plus_fail_tests": []}], "EvoEval/15": [{"task_id": "EvoEval/15", "solution": "def string_sequence_modified(n: int, m: int) -> str:\n    result = []\n    for i in range(n + 1):\n        if (i + 1) % m == 0:\n            result.append('Fizz')\n        else:\n            result.append(str(i))\n    return ' '.join(result)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/24": [{"task_id": "EvoEval/24", "solution": "def largest_prime_divisor(n: int, k: int) -> int:\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    primes = [i for i in range(2, n) if n % i == 0 and is_prime(i)]\n    primes.sort(reverse=True)\n    return primes[k - 1] if k <= len(primes) else -1", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/43": [{"task_id": "EvoEval/43", "solution": "def multi_pairs_sum_to_zero(l, n):\n    if n > len(l):\n        return False\n    else:\n        l.sort()\n        for i in range(len(l)):\n            for j in range(i + 1, len(l)):\n                if l[i] + l[j] == 0:\n                    n -= 1\n                    if n == 0:\n                        return True\n        return False", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[2, 4, -5, 3, 5, 7], 3]], "plus_fail_tests": []}], "EvoEval/39": [{"task_id": "EvoEval/39", "solution": "def prime_fib_matrix(n: int, m: int):\n    matrix = []\n    for i in range(n):\n        row = []\n        for j in range(m):\n            k = i * j\n            while not is_prime(k) or not is_fibonacci(k):\n                k += 1\n            row.append(k)\n        matrix.append(row)\n    return matrix", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1, 2]], "plus_fail_tests": []}], "EvoEval/56": [{"task_id": "EvoEval/56", "solution": "def correct_bracketing_advanced(brackets: str, scope: tuple):\n    stack = []\n    open_brackets = {scope[0]: scope[1]}\n    close_brackets = {v: k for (k, v) in open_brackets.items()}\n    for bracket in brackets:\n        if bracket in open_brackets:\n            stack.append(bracket)\n        elif bracket in close_brackets:\n            if not stack or open_brackets[stack.pop()] != bracket:\n                return False\n    return not stack", "base_status": "fail", "plus_status": null, "base_fail_tests": [["[(<{<>>})]", ["<", ">"]]], "plus_fail_tests": []}], "EvoEval/93": [{"task_id": "EvoEval/93", "solution": "def encode_complex(message, shift, key):\n    vowels = 'aeiouAEIOU'\n    alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    encoded_message = ''\n    for char in message:\n        if char in vowels:\n            if char.islower():\n                encoded_message += chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                encoded_message += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n        elif char.isalpha():\n            if char.islower():\n                encoded_message += key[ord(char) - ord('a')]\n            else:\n                encoded_message += key[ord(char) - ord('A')]\n        else:\n            encoded_message += char\n    return encoded_message.swapcase()", "base_status": "fail", "plus_status": null, "base_fail_tests": [["This is a message", 4, "zyxwvutsrqponmlkjihgfedcba"]], "plus_fail_tests": []}], "EvoEval/49": [{"task_id": "EvoEval/49", "solution": "def modp(n: int, p: int, m: int):\n    if m % p == 0:\n        return -1\n    return (pow(2, n, p) + m) % p", "base_status": "fail", "plus_status": null, "base_fail_tests": [[100, 100, 10]], "plus_fail_tests": []}], "EvoEval/41": [{"task_id": "EvoEval/41", "solution": "def car_race_collision(n: int, speeds: list):\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line with multiple lanes.\n    n cars are driving left to right each with different speeds given in array speeds; simultaneously, a different set of n cars with the same speeds \n    are driving right to left on their respective lanes. The two sets of cars start out being very far from\n    each other. Two cars are said to collide when a car that's moving left to right hits a car that's moving right to left, or if one moving car hits a car that is not moving (zero speed).\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving in their trajectory as if they did not collide.\n\n    This function should output the number of such collisions.\n    \"\"\"\n    collisions = 0\n    for i in range(n):\n        if speeds[i] != 0:\n            collisions += 1\n    return collisions", "base_status": "fail", "plus_status": null, "base_fail_tests": [[2, [1000, 0]]], "plus_fail_tests": []}], "EvoEval/16": [{"task_id": "EvoEval/16", "solution": "def count_distinct_characters_substrings(string: str, length: int) -> dict:\n    if length > len(string):\n        return {}\n    else:\n        result = {}\n        for i in range(len(string) - length + 1):\n            substring = string[i:i + length]\n            distinct_characters = len(set(substring))\n            result[substring] = distinct_characters\n        return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/96": [{"task_id": "EvoEval/96", "solution": "def prime_sequences(n, m):\n    if n == 0 or m == 0:\n        return []\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    primes = [i for i in range(n) if is_prime(i)]\n    if len(primes) < m:\n        return []\n    return [primes[i:i + m] for i in range(len(primes) - m + 1)]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/54": [{"task_id": "EvoEval/54", "solution": "def same_chars_in_order(s0: str, s1: str):\n    \"\"\"\n    Check if characters in s0 appears in the same order in s1.\n    \"\"\"\n    it = iter(s1)\n    return all((c in it for c in s0))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/7": [{"task_id": "EvoEval/7", "solution": "from typing import List, Optional\n\n\ndef filter_by_substring(strings: List[str], substring: str, start: Optional[int]=None, end: Optional[int]=None) -> List[str]:\n    filtered_strings = []\n    for string in strings:\n        if start is not None and end is not None:\n            string = string[start:end + 1]\n        elif start is not None:\n            string = string[start:]\n        elif end is not None:\n            string = string[:end + 1]\n        if substring in string:\n            filtered_strings.append(string)\n    return filtered_strings", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["abc", "bacd", "cde", "array"], "a", 1]], "plus_fail_tests": []}], "EvoEval/77": [{"task_id": "EvoEval/77", "solution": "def iscube(a, b):\n    if a < 0 or b < 0:\n        return False\n    else:\n        a_cube_root = round(a ** (1.0 / 3))\n        b_square_root = round(b ** 0.5)\n        if a_cube_root ** 3 == a and b_square_root ** 2 == b and ((a + b) % 2 == 0):\n            return True\n        else:\n            return False", "base_status": "fail", "plus_status": null, "base_fail_tests": [[0, 64]], "plus_fail_tests": []}], "EvoEval/73": [{"task_id": "EvoEval/73", "solution": "def smallest_change(arr, k):\n    n = len(arr)\n    changes = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            changes += 1\n    if changes % k != 0:\n        changes += k - changes % k\n    return changes", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 5, 4, 7, 9, 6], 14]], "plus_fail_tests": []}], "EvoEval/87": [{"task_id": "EvoEval/87", "solution": "def get_row(lst, x, y):\n    result = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            for k in range(len(lst[i][j])):\n                if lst[i][j][k] == x and lst[i][j][k] != y:\n                    result.append((i, j, k))\n    result.sort(key=lambda x: (x[0], -x[1], x[2]))\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[[1]]], 1, 1]], "plus_fail_tests": []}], "EvoEval/64": [{"task_id": "EvoEval/64", "solution": "def vowels_count(s, l=None):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    if l is not None:\n        vowels = [v.lower() for v in l]\n    s = s.lower()\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n        elif char == 'y' and s.index(char) == len(s) - 1:\n            count += 1\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [["ACEDY", ["a", "e", "d"]]], "plus_fail_tests": []}], "EvoEval/60": [{"task_id": "EvoEval/60", "solution": "def sum_to_n_positive_odd(n: int):\n    if not isinstance(n, int) or n < 1:\n        return 'Input must be a positive integer.'\n    else:\n        return sum((i for i in range(1, n + 1) if i % 2 != 0)) % 107", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/17": [{"task_id": "EvoEval/17", "solution": "from typing import List, Tuple\n\n\ndef parse_music_advanced(music_string: str) -> Tuple[List[int], List[str]]:\n    music_items = music_string.split()\n    beats = []\n    types = []\n    last_beat = 0\n    for item in music_items:\n        if item == 'o':\n            beats.append(4)\n            types.append('note')\n            last_beat = 4\n        elif item == 'o|':\n            beats.append(2)\n            types.append('note')\n            last_beat = 2\n        elif item == '.|':\n            beats.append(1)\n            types.append('note')\n            last_beat = 1\n        elif item == 'r':\n            beats.append(4)\n            types.append('rest')\n            last_beat = 4\n        elif item == 'r|':\n            beats.append(2)\n            types.append('rest')\n            last_beat = 2\n        elif item == 'r.':\n            beats.append(1)\n            types.append('rest')\n            last_beat = 1\n        else:\n            beats.append(last_beat)\n            types.append('rest')\n    return (beats, types)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/28": [{"task_id": "EvoEval/28", "solution": "from typing import List, Tuple\n\ndef interleave_and_concatenate(strings: List[str], integers: List[int]) -> Tuple[str, int]:\n    interleaved = [val for pair in zip(strings, integers) for val in pair]\n    interleaved_strings = [val for val in interleaved if isinstance(val, str)]\n    interleaved_integers = [val for val in interleaved if isinstance(val, int)]\n    concatenated_string = ''.join(interleaved_strings)\n    sum_integers = sum(interleaved_integers)\n    return (concatenated_string, sum_integers)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["a", "b"], [1, 2, 3]]], "plus_fail_tests": []}], "EvoEval/69": [{"task_id": "EvoEval/69", "solution": "def advanced_search(lst, f):\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    sorted_dict = dict(sorted(freq_dict.items(), reverse=True))\n    for (num, freq) in sorted_dict.items():\n        if f % freq == 0 and freq >= num:\n            return num\n    return -1", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/36": [{"task_id": "EvoEval/36", "solution": "from typing import List\n\ndef advanced_fizz_buzz(n: int, divisors: List[int], target: int) -> int:\n    fib = [0, 1]\n    while fib[-1] < n:\n        fib.append(fib[-1] + fib[-2])\n    fib.pop()\n    fib = [x for x in fib if any((x % d == 0 for d in divisors))]\n    return sum((str(x).count(str(target)) for x in fib))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/5": [{"task_id": "EvoEval/5", "solution": "from typing import List, Union\n\ndef intersperse(numbers: List[Union[int, float]], delimeter: Union[int, float], limit: int) -> List[Union[int, float]]:\n    result = []\n    for (i, num) in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1 and i < limit:\n            result.append(delimeter)\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 4], 0.5, 2]], "plus_fail_tests": []}], "EvoEval/79": [{"task_id": "EvoEval/79", "solution": "def decimal_to_binary(decimal, padding_length):\n    if not isinstance(decimal, int) or not isinstance(padding_length, int) or decimal < 0 or (padding_length < 0):\n        return 'Invalid Input'\n    binary = bin(decimal)[2:]\n    if len(binary) > padding_length:\n        return 'Padding length is too small'\n    return 'db' + binary.zfill(padding_length) + 'db'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/66": [{"task_id": "EvoEval/66", "solution": "def advancedDigitSum(s, t):\n    sum_s = sum((ord(c) for c in s if c.isupper()))\n    sum_t = sum((ord(c) for c in t if c.islower()))\n    return (sum_s, sum_t)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/86": [{"task_id": "EvoEval/86", "solution": "def advanced_anti_shuffle(s, n):\n    words = s.split(' ')\n    result = []\n    for word in words:\n        punctuation = ''\n        while not word[-1].isalpha():\n            punctuation = word[-1] + punctuation\n            word = word[:-1]\n        word = ''.join(sorted(word))\n        word = word[-n:] + word[:-n]\n        result.append(word + punctuation)\n    return ' '.join(result)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["", 6]], "plus_fail_tests": []}], "EvoEval/4": [{"task_id": "EvoEval/4", "solution": "from typing import List, Tuple\n\n\ndef weighted_mean_absolute_deviation(numbers: List[Tuple[float, float]]) -> float:\n    weights_sum = sum((weight for (_, weight) in numbers))\n    if any((weight < 0 for (_, weight) in numbers)) or weights_sum != 1:\n        return 'Weights must be positive and sum to 1'\n    weighted_mean = sum((x * weight for (x, weight) in numbers))\n    wmad = sum((weight * abs(x - weighted_mean) for (x, weight) in numbers)) / weights_sum\n    return wmad", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/72": [{"task_id": "EvoEval/72", "solution": "def will_it_fly_advanced(q, w, r):\n    q_new = [q[i] for i in range(len(q)) if i not in r]\n    if q_new != q_new[::-1]:\n        return False\n    if sum(q_new) > w:\n        return None\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 2, 3], 1, []]], "plus_fail_tests": []}], "EvoEval/58": [{"task_id": "EvoEval/58", "solution": "def common(l1: list, l2: list, n: int):\n    common_strings = [value for value in l1 if value in l2]\n    common_strings.sort(key=lambda x: (-len(x), l1.index(x)))\n    return common_strings[:n]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["apple", "banana", "cherry", "date", "elderberry"], ["banana", "date", "fig", "grape", "elderberry"], 3]], "plus_fail_tests": []}], "EvoEval/48": [{"task_id": "EvoEval/48", "solution": "def is_palindrome_sentence(sentence: str):\n    sentence = sentence.lower()\n    sentence = ''.join((e for e in sentence if e.isalnum()))\n    return sentence == sentence[::-1]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/45": [{"task_id": "EvoEval/45", "solution": "def triangle_area(vertices):\n    (x1, y1) = vertices[0]\n    (x2, y2) = vertices[1]\n    (x3, y3) = vertices[2]\n    area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2)\n    if area == 0:\n        return 'Not a triangle'\n    else:\n        return area", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/53": [{"task_id": "EvoEval/53", "solution": "def add_elements(list1: list, list2: list, index: int):\n    try:\n        result = list1[index] + list2[index]\n        return (result, False)\n    except IndexError:\n        return (None, True)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/51": [{"task_id": "EvoEval/51", "solution": "def remove_vowels_and_count(text):\n    vowels = 'aeiouAEIOU'\n    count_dict = {v: 0 for v in vowels if v in text}\n    new_text = ''\n    for char in text:\n        if char in vowels:\n            count_dict[char] += 1\n        else:\n            new_text += char\n    return (new_text, {k: v for (k, v) in count_dict.items() if v > 0})", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/0": [{"task_id": "EvoEval/0", "solution": "from typing import List, Tuple\n\ndef has_close_elements_in_range(numbers: List[Tuple[float, float]], threshold: float) -> bool:\n    numbers.sort(key=lambda x: x[0])\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i][0] - numbers[i + 1][0]) < threshold and abs(numbers[i][1] - numbers[i + 1][1]) < threshold:\n            return True\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/80": [{"task_id": "EvoEval/80", "solution": "def is_happy_advanced(s, n):\n    if len(s) < n:\n        return False\n    if not any((c.isalnum() for c in s)):\n        return False\n    for i in range(len(s) - n + 1):\n        if len(set(s[i:i + n])) != n:\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/12": [{"task_id": "EvoEval/12", "solution": "from typing import List, Optional, Tuple\n\n\ndef longest_substring(strings: List[str]) -> Tuple[Optional[str], Optional[int]]:\n    vowels = 'aeiouAEIOU'\n    longest_substring = None\n    longest_substring_index = None\n    longest_substring_length = 0\n    for (i, string) in enumerate(strings):\n        for j in range(len(string)):\n            if string[j] in vowels:\n                for k in range(j + 1, len(string) + 1):\n                    if k - j > longest_substring_length:\n                        longest_substring = string[j:k]\n                        longest_substring_index = i\n                        longest_substring_length = k - j\n    return (longest_substring, longest_substring_index)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/59": [{"task_id": "EvoEval/59", "solution": "def largest_prime_factor(n: int, m: int):\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    if is_prime(m):\n        largest = 0\n        for i in range(2, n + 1):\n            if n % i == 0 and is_prime(i) and (i > largest):\n                largest = i\n        return largest\n    else:\n        smallest = n\n        for i in range(2, n + 1):\n            if n % i == 0 and is_prime(i) and (i < smallest):\n                smallest = i\n        return smallest", "base_status": "fail", "plus_status": null, "base_fail_tests": [[9999999967, 3]], "plus_fail_tests": []}], "EvoEval/18": [{"task_id": "EvoEval/18", "solution": "def how_many_times(string: str, substrings: list) -> dict:\n    if any((sub == '' for sub in substrings)):\n        return 'Substrings cannot be empty'\n    counts = {sub: 0 for sub in substrings}\n    for sub in substrings:\n        start = 0\n        while start < len(string):\n            pos = string.find(sub, start)\n            if pos != -1:\n                counts[sub] += 1\n                start = pos + 1\n            else:\n                break\n    return counts", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/9": [{"task_id": "EvoEval/9", "solution": "from typing import List, Tuple\n\ndef rolling_max_min(numbers: List[int]) -> List[Tuple[int, int]]:\n    if not numbers:\n        return []\n    rolling_max = numbers[0]\n    rolling_min = numbers[0]\n    result = [(rolling_max, rolling_min)]\n    for num in numbers[1:]:\n        if num > rolling_max:\n            rolling_max = num\n        if num < rolling_min:\n            rolling_min = num\n        result.append((rolling_max, rolling_min))\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}]}}