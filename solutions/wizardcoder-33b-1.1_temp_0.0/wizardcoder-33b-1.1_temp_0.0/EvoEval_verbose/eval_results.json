{"eval": {"HumanEval/68": [{"task_id": "HumanEval/68", "solution": "\ndef pluck(arr):\n    even_numbers = [num for num in arr if num % 2 == 0]\n    if not even_numbers:\n        return []\n    smallest_even_number = min(even_numbers)\n    index_of_smallest_even_number = arr.index(smallest_even_number)\n    return [smallest_even_number, index_of_smallest_even_number]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/47": [{"task_id": "HumanEval/47", "solution": "\n\ndef median(l: list):\n    \"\"\"\n    This function calculates and returns the median value of a given list of numbers named 'l'. If the list 'l' has an \n    odd number of elements, the median is the middle number. If the list 'l' has an even number of elements, the median \n    is calculated as the average of the two middle numbers. \n\n    The median is a measure of central tendency that can give a better sense of the typical value of a set of numbers \n    in the list 'l' compared to the average, especially in skewed distributions.\n\n    Args:\n    l (list of int/float): A list of numbers. This list must be non-empty and can contain any number of elements. \n    The numbers can be any real numbers (integers or floating point).\n\n    Returns:\n    int/float: The function will return the median value as an integer if the list 'l' has an odd number of elements. \n    If the list 'l' has an even number of elements, the median value will be returned as a float.\n\n    Examples:\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    l.sort()\n    n = len(l)\n    if n % 2:\n        return l[n // 2]\n    else:\n        return (l[n // 2 - 1] + l[n // 2]) / 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/124": [{"task_id": "HumanEval/124", "solution": "\ndef valid_date(date):\n    if not date:\n        return False\n    match = re.match('(\\\\d{2})-(\\\\d{2})-(\\\\d{4})', date)\n    if not match:\n        return False\n    (month, day, year) = map(int, match.groups())\n    if month < 1 or month > 12:\n        return False\n    if day < 1 or day > 31:\n        return False\n    if month in [4, 6, 9, 11] and day > 30:\n        return False\n    if month == 2:\n        if day > 29:\n            return False\n        if year % 4 != 0:\n            if day > 28:\n                return False\n        elif year % 100 != 0:\n            if day > 29:\n                return False\n        elif year % 400 != 0:\n            if day > 28:\n                return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["03-11-2000"]], "plus_fail_tests": [["12-31-1999"]]}], "HumanEval/72": [{"task_id": "HumanEval/72", "solution": "\ndef will_it_fly(q, w):\n    is_palindromic = q == q[::-1]\n    total_weight = sum(q)\n    can_fly = total_weight <= w\n    return is_palindromic and can_fly", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/119": [{"task_id": "HumanEval/119", "solution": "\ndef match_parens(lst):\n    str1 = lst[0] + lst[1]\n    str2 = lst[1] + lst[0]\n    if is_good_string(str1) or is_good_string(str2):\n        return 'Yes'\n    else:\n        return 'No'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["()(", ")"]]], "plus_fail_tests": [[["(", "("]]]}], "HumanEval/75": [{"task_id": "HumanEval/75", "solution": "\ndef is_multiply_prime(a):\n    if a < 100:\n        primes = [i for i in range(2, a) if is_prime(i)]\n        for i in primes:\n            for j in primes:\n                for k in primes:\n                    if i * j * k == a:\n                        return True\n        return False\n    else:\n        return 'Undefined'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[33]]}], "HumanEval/101": [{"task_id": "HumanEval/101", "solution": "\ndef words_string(s):\n    return s.replace(',', '').split()", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["Elephant,giraffe,,lion,zebra"]]}], "HumanEval/4": [{"task_id": "HumanEval/4", "solution": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the Mean Absolute Deviation (MAD) for a provided list of numbers.\n\n    The Mean Absolute Deviation is a measure of statistical dispersion. It is calculated as the average absolute difference \n    between each value in a dataset and the mean of the dataset.\n\n    This function takes as input a list of floating point numbers, calculates the mean of these numbers, then finds the absolute \n    difference between each number in the list and the calculated mean. The average of these absolute differences is returned \n    as the Mean Absolute Deviation.\n\n    The formula for Mean Absolute Deviation is: MAD = average | x - x_mean |\n\n    Args:\n        numbers (List[float]): A list of floating point numbers.\n\n    Returns:\n        float: The Mean Absolute Deviation of the numbers in the input list.\n\n    Example:\n        >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n        1.0\n\n    Note that the Mean Absolute Deviation gives equal weight to all values in the input list, irrespective of their magnitude. \n    This makes it a robust measure of dispersion, resistant to outliers in the data.    \n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(number - mean) for number in numbers]\n    mad = sum(absolute_differences) / len(absolute_differences)\n    return mad", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/71": [{"task_id": "HumanEval/71", "solution": "\ndef triangle_area(a, b, c):\n    if a + b > c and a + c > b and (b + c > a):\n        s = (a + b + c) / 2\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        return round(area, 2)\n    else:\n        return -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 4, 5]], "plus_fail_tests": [[8, 9, 15]]}], "HumanEval/104": [{"task_id": "HumanEval/104", "solution": "\ndef unique_digits(x):\n    result = []\n    for num in x:\n        if all((int(digit) % 2 != 0 for digit in str(num))):\n            result.append(num)\n    return sorted(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/105": [{"task_id": "HumanEval/105", "solution": "\ndef by_length(arr):\n    arr = [i for i in arr if 1 <= i <= 9]\n    arr.sort()\n    arr.reverse()\n    word_map = {1: 'One', 2: 'Two', 3: 'Three', 4: 'Four', 5: 'Five', 6: 'Six', 7: 'Seven', 8: 'Eight', 9: 'Nine'}\n    arr = [word_map[i] for i in arr]\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/87": [{"task_id": "HumanEval/87", "solution": "\ndef get_row(lst, x):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n    return coordinates", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/107": [{"task_id": "HumanEval/107", "solution": "\ndef even_odd_palindrome(n):\n    even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        str_num = str(num)\n        if str_num == str_num[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/82": [{"task_id": "HumanEval/82", "solution": "\ndef prime_length(string):\n    length = len(string)\n    if length < 2:\n        return False\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/66": [{"task_id": "HumanEval/66", "solution": "\ndef digitSum(s):\n    return sum((ord(c) for c in s if c.isupper()))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/93": [{"task_id": "HumanEval/93", "solution": "\ndef encode(message):\n    vowels = 'aeiouAEIOU'\n    trans = str.maketrans('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', 'cdefghijklmnopqrstuvwxyzabCDEFGHIJKLMNOPQRSTUVWXYZ123', 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    message = message.translate(trans)\n    for v in vowels:\n        message = message.replace(v, chr(ord(v) + 2))\n    return message.swapcase()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["TEST"]], "plus_fail_tests": [["abcdefghijklmnopqrstuvwxyz"]]}], "HumanEval/156": [{"task_id": "HumanEval/156", "solution": "\ndef int_to_mini_roman(number):\n    val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    syb = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n    roman_num = ''\n    i = 0\n    while number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syb[i]\n            number -= val[i]\n        i += 1\n    return roman_num", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/102": [{"task_id": "HumanEval/102", "solution": "\ndef choose_num(x, y):\n    if x > y:\n        return -1\n    else:\n        max_even = y if y % 2 == 0 else y - 1\n        return max_even if max_even >= x else -1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/125": [{"task_id": "HumanEval/125", "solution": "\ndef split_words(txt):\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum((1 for c in txt if c.islower() and (ord(c) - ord('a')) % 2 != 0))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/44": [{"task_id": "HumanEval/44", "solution": "\n\ndef change_base(x: int, base: int) -> str:\n    \"\"\"\n    Convert and change the numerical base of a given input number 'x' into a different base 'base'.\n    \"\"\"\n    if x == 0:\n        return '0'\n    digits = []\n    while x:\n        digits.append(str(x % base))\n        x //= base\n    return ''.join(digits[::-1])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/86": [{"task_id": "HumanEval/86", "solution": "\ndef anti_shuffle(s):\n    words = s.split(' ')\n    sorted_words = []\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        sorted_words.append(sorted_word)\n    return ' '.join(sorted_words)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/14": [{"task_id": "HumanEval/14", "solution": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    return [string[:i] for i in range(1, len(string) + 1)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/120": [{"task_id": "HumanEval/120", "solution": "\ndef maximum(arr, k):\n    arr.sort(reverse=True)\n    return arr[:k]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-3, -4, 5], 3]], "plus_fail_tests": [[[1, 2, 3, 4, 5], 3]]}], "HumanEval/88": [{"task_id": "HumanEval/88", "solution": "\ndef sort_array(array):\n    if not array:\n        return []\n    elif len(array) == 1:\n        return array\n    else:\n        first_last_sum = array[0] + array[-1]\n        if first_last_sum % 2 == 0:\n            return sorted(array, reverse=True)\n        else:\n            return sorted(array)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/97": [{"task_id": "HumanEval/97", "solution": "\ndef multiply(a, b):\n    last_digit_a = abs(a) % 10\n    last_digit_b = abs(b) % 10\n    return last_digit_a * last_digit_b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/23": [{"task_id": "HumanEval/23", "solution": "\n\ndef strlen(string: str) -> int:\n    if not isinstance(string, str):\n        raise TypeError('The input to this function should be a string.')\n    return len(string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/35": [{"task_id": "HumanEval/35", "solution": "\n\ndef max_element(l: list):\n    \"\"\"\n    This function, 'max_element', is designed to find and return the maximum element in a given list. It takes one \n    argument, 'l', which is a list of elements. The function iterates through this list, comparing each element in order \n    to find the one with the highest value.\n    \n    Examples:\n    \n    If we pass [1, 2, 3] to the function as its input:\n    >>> max_element([1, 2, 3])\n    It will return 3, as 3 is the highest number in the list.\n    \n    If we pass [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10] to the function as its input:\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    It will return 123, as 123 is the highest number in the list.\n    \"\"\"\n    max_elem = l[0]\n    for elem in l:\n        if elem > max_elem:\n            max_elem = elem\n    return max_elem", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/96": [{"task_id": "HumanEval/96", "solution": "\ndef count_up_to(n):\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    primes = []\n    for i in range(n):\n        if is_prime(i):\n            primes.append(i)\n    return primes", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/84": [{"task_id": "HumanEval/84", "solution": "\ndef solve(N):\n    binary = bin(N)[2:]\n    digit_sum = sum((int(digit) for digit in binary))\n    return bin(digit_sum)[2:]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1000]], "plus_fail_tests": [[10]]}], "HumanEval/13": [{"task_id": "HumanEval/13", "solution": "\n\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    This function, 'greatest_common_divisor', takes in two integers, 'a' and 'b', as input arguments and returns\n    the greatest common divisor (GCD) of these two integers.\n\n    The greatest common divisor of two numbers is the largest positive integer that divides each of the integers without a remainder.\n    For example, the GCD of 8 and 12 is 4.\n\n    Args:\n    a (int): The first input integer.\n    b (int): The second input integer.\n\n    Returns:\n    int: The greatest common divisor of integers 'a' and 'b'.\n    \n    Examples:\n    >>> greatest_common_divisor(3, 5)\n    1\n    This example returns 1 because 1 is the only positive integer that divides both 3 and 5 without a remainder.\n\n    >>> greatest_common_divisor(25, 15)\n    5\n    This example returns 5 because 5 is the largest positive integer that divides both 25 and 15 without a remainder.  \n    \"\"\"\n    while b != 0:\n        (a, b) = (b, a % b)\n    return abs(a)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/31": [{"task_id": "HumanEval/31", "solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/157": [{"task_id": "HumanEval/157", "solution": "\ndef right_angle_triangle(a, b, c):\n    (a, b, c) = sorted([a, b, c], reverse=True)\n    return a ** 2 == b ** 2 + c ** 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/43": [{"task_id": "HumanEval/43", "solution": "\n\ndef pairs_sum_to_zero(l):\n    elements = set(l)\n    for element in l:\n        if -element in elements:\n            if -element != element:\n                return True\n    return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[0, 0]]]}], "HumanEval/110": [{"task_id": "HumanEval/110", "solution": "\ndef exchange(lst1, lst2):\n    odd_in_lst1 = sum((1 for i in lst1 if i % 2 != 0))\n    odd_in_lst2 = sum((1 for i in lst2 if i % 2 != 0))\n    if odd_in_lst1 > odd_in_lst2:\n        return 'NO'\n    else:\n        return 'YES'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4], [1, 5, 3, 4]]], "plus_fail_tests": [[[1, 3, 5], [2, 4, 6]]]}], "HumanEval/95": [{"task_id": "HumanEval/95", "solution": "\ndef check_dict_case(dict):\n    if not dict:\n        return False\n    is_lower = all((key.islower() for key in dict.keys() if isinstance(key, str)))\n    is_upper = all((key.isupper() for key in dict.keys() if isinstance(key, str)))\n    return is_lower or is_upper", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/98": [{"task_id": "HumanEval/98", "solution": "\ndef count_upper(s):\n    count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in 'AEIOU':\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/81": [{"task_id": "HumanEval/81", "solution": "\ndef numerical_letter_grade(grades):\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa >= 3.7:\n            letter_grades.append('A')\n        elif gpa >= 3.3:\n            letter_grades.append('A-')\n        elif gpa >= 3.0:\n            letter_grades.append('B+')\n        elif gpa >= 2.7:\n            letter_grades.append('B')\n        elif gpa >= 2.3:\n            letter_grades.append('B-')\n        elif gpa >= 2.0:\n            letter_grades.append('C+')\n        elif gpa >= 1.7:\n            letter_grades.append('C')\n        elif gpa >= 1.3:\n            letter_grades.append('C-')\n        elif gpa >= 1.0:\n            letter_grades.append('D+')\n        elif gpa >= 0.7:\n            letter_grades.append('D')\n        elif gpa >= 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[4.0, 3, 1.7, 2, 3.5]]], "plus_fail_tests": [[[3.8, 2.5, 3.9, 2.2, 1.0]]]}], "HumanEval/73": [{"task_id": "HumanEval/73", "solution": "\ndef smallest_change(arr: List[int]) -> int:\n    changes = 0\n    (i, j) = (0, len(arr) - 1)\n    while i < j:\n        if arr[i] != arr[j]:\n            changes += 1\n        i += 1\n        j -= 1\n    return changes", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/160": [{"task_id": "HumanEval/160", "solution": "\ndef do_algebra(operator, operand):\n    operator_dict = {'+': lambda x, y: x + y, '-': lambda x, y: x - y, '*': lambda x, y: x * y, '//': lambda x, y: x // y, '**': lambda x, y: x ** y}\n    result = operand[0]\n    for i in range(1, len(operand)):\n        result = operator_dict[operator[i - 1]](result, operand[i])\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["+", "*", "-"], [2, 3, 4, 5]]], "plus_fail_tests": [[["+", "-", "*", "//"], [5, 2, 3, 4, 7]]]}], "HumanEval/108": [{"task_id": "HumanEval/108", "solution": "\ndef count_nums(arr):\n    count = 0\n    for num in arr:\n        digit_sum = sum((int(digit) for digit in str(num) if digit.isdigit()))\n        if digit_sum > 0:\n            count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, -2, 0]]], "plus_fail_tests": [[[-1, 0, 1]]]}], "HumanEval/146": [{"task_id": "HumanEval/146", "solution": "def specialFilter(nums):\n    count = 0\n    odd_digits = {'1', '3', '5', '7', '9'}\n    for num in nums:\n        if num > 10:\n            num_str = str(num)\n            if num_str[0] in odd_digits and num_str[-1] in odd_digits:\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/60": [{"task_id": "HumanEval/60", "solution": "\n\ndef sum_to_n(n: int) -> int:\n    \"\"\"\n    The function sum_to_n is a mathematical function that calculates the cumulative sum of all integer numbers starting \n    from 1 to the input integer number n inclusive. This calculation can also be understood as finding the sum of an \n    arithmetic series.\n\n    The function takes one argument:\n    - n (int): An integer number which is the end point for the series sum. This number is included in the series. \n               It is expected to be a positive integer, as the function does not handle negative numbers or zero.\n\n    The function returns an integer that is the sum of all integers from 1 to n.\n\n    Here are some example uses of the function:\n\n    >>> sum_to_n(30)\n    465\n    This means that the sum of all integers from 1 to 30 is 465.\n\n    >>> sum_to_n(100)\n    5050\n    This means that the sum of all integers from 1 to 100 is 5050.\n\n    >>> sum_to_n(5)\n    15\n    This means that the sum of all integers from 1 to 5 is 15.\n\n    >>> sum_to_n(10)\n    55\n    This means that the sum of all integers from 1 to 10 is 55.\n\n    >>> sum_to_n(1)\n    1\n    This means that the sum of all integers from 1 to 1 is 1, i.e., just the number itself.\n    \"\"\"\n    return n * (n + 1) // 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/147": [{"task_id": "HumanEval/147", "solution": "\ndef get_max_triples(n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1]]}], "HumanEval/144": [{"task_id": "HumanEval/144", "solution": "\ndef simplify(x, n):\n    (x_num, x_denom) = map(int, x.split('/'))\n    (n_num, n_denom) = map(int, n.split('/'))\n    result_num = x_num * n_num\n    result_denom = x_denom * n_denom\n    if result_num % result_denom == 0:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/26": [{"task_id": "HumanEval/26", "solution": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    result = []\n    for num in numbers:\n        if num not in result:\n            result.append(num)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 2, 4, 3, 5]]], "plus_fail_tests": [[[1, 1, 2, 2, 3, 3, 4, 4]]]}], "HumanEval/6": [{"task_id": "HumanEval/6", "solution": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    groups = paren_string.split()\n    max_depths = []\n    for group in groups:\n        current_depth = 0\n        max_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        max_depths.append(max_depth)\n    return max_depths", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/20": [{"task_id": "HumanEval/20", "solution": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i - 1], numbers[i])\n    return closest_pair", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/51": [{"task_id": "HumanEval/51", "solution": "\n\ndef remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/45": [{"task_id": "HumanEval/45", "solution": "\n\ndef triangle_area(a, h):\n    \"\"\"\n    Calculates and returns the area of a triangle based on the length of one side and the height from that side to the opposite vertex.\n\n    This function takes two parameters: the length of a side (a) and the height (h). The length of a side and the height must be non-negative numbers. If other types of inputs are given, the function may behave unpredictably.\n\n    The area of the triangle is calculated with the formula '0.5 * a * h'. This formula is derived from the geometric characteristics of the triangle.\n\n    Args:\n    a (float): The length of a side of the triangle. Must be a non-negative number.\n    h (float): The height from one side to the opposite vertex. Must be a non-negative number.\n\n    Returns:\n    float: The area of the triangle. Returns a floating point number that represents the calculated area.\n\n    Example:\n    >>> triangle_area(5, 3)\n    7.5\n\n    The example demonstrates that if the length of a side of the triangle is 5 and the height from that side to the opposite vertex is 3, the function returns the area of the triangle, which is 7.5.\n    \"\"\"\n    return 0.5 * a * h", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/114": [{"task_id": "HumanEval/114", "solution": "import math\n\ndef minSubArraySum(nums):\n    min_ending_here = min_so_far = nums[0]\n    for x in nums[1:]:\n        min_ending_here = min(x, min_ending_here + x)\n        min_so_far = min(min_so_far, min_ending_here)\n    return min_so_far", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/89": [{"task_id": "HumanEval/89", "solution": "\ndef encrypt(s):\n    result = ''\n    for char in s:\n        if char.isalpha():\n            ascii_val = ord(char)\n            if ascii_val >= 65 and ascii_val <= 90:\n                result += chr((ascii_val - 65 + 4) % 26 + 65)\n            elif ascii_val >= 97 and ascii_val <= 122:\n                result += chr((ascii_val - 97 + 4) % 26 + 97)\n        else:\n            result += char\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/55": [{"task_id": "HumanEval/55", "solution": "\n\ndef fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError('n must be a positive integer')\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        return fib(n - 1) + fib(n - 2)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0]]}], "HumanEval/77": [{"task_id": "HumanEval/77", "solution": "\ndef iscube(a):\n    \"\"\"\n    The purpose of this function is to determine if a given integer ('a') is a perfect cube of another integer.\n    \n    This function accepts one input argument:\n    a (int): An integer value for which the function will determine if it is a cube root of another integer. \n             The input can be positive, negative, or zero. \n\n    The function will return a boolean value:\n    - It returns True if the input integer is a perfect cube of another integer.\n    - It returns False if the input integer is not a perfect cube of another integer.\n\n    Please, note that the function always assumes valid input, hence there is no error/exception handling\n    implemented for invalid input scenarios.\n\n    Here are some examples to demonstrate how this function works:\n\n    If the function is called with 1 as the argument (i.e., iscube(1)), it will return True because 1 is a cube of 1.\n\n    If the function is called with 2 as the argument (i.e., iscube(2)), it will return False because 2 is not a cube of any integer.\n\n    If the function is called with -1 as the argument (i.e., iscube(-1)), it will return True because -1 is a cube of -1.\n\n    If the function is called with 64 as the argument (i.e., iscube(64)), it will return True because 64 is a cube of 4.\n\n    If the function is called with 0 as the argument (i.e., iscube(0)), it will return True because 0 is a cube of 0.\n\n    If the function is called with 180 as the argument (i.e., iscube(180)), it will return False because 180 is not a cube of any integer.\n\n    \"\"\"\n    return round(a ** (1.0 / 3)) ** 3 == a", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[-1]], "plus_fail_tests": [[-8]]}], "HumanEval/92": [{"task_id": "HumanEval/92", "solution": "\ndef any_int(x, y, z):\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        if x == y + z or y == x + z or z == x + y:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/46": [{"task_id": "HumanEval/46", "solution": "\n\ndef fib4(n: int):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    else:\n        fib_sequence = [0, 0, 2, 0]\n        for i in range(4, n + 1):\n            fib_sequence.append(fib_sequence[i - 1] + fib_sequence[i - 2] + fib_sequence[i - 3] + fib_sequence[i - 4])\n        return fib_sequence[n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/16": [{"task_id": "HumanEval/16", "solution": "\n\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"\n    This function takes a string as its input and returns the total number of distinct characters it contains, \n    without considering the case of the characters. That means, 'a' and 'A' will be considered as the same character.\n\n    It uses the built-in Python data structure set to accomplish this task. \n    The set data structure in Python, by definition, contains unique elements, \n    which makes it perfect for this sort of problem where we need to count the number of unique items.\n    \n    Parameters:\n    string (str): The input string whose distinct characters need to be counted. \n\n    Returns:\n    int: The number of distinct characters in the input string irrespective of their case.\n\n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n\n    Explanation: Although visually the string appears to have 6 characters, \n    but since we are not considering case, 'x' and 'X' are considered as the same character. \n    Similarly 'y' and 'Y', 'z' and 'Z' are considered as same characters. Hence, the total number of distinct characters is 3.\n\n    >>> count_distinct_characters('Jerry')\n    4\n\n    Explanation: In this case, the distinct characters are 'J', 'e', 'r', 'y'. \n    Although 'r' appears twice, it is considered as one unique character. Hence, the total number of distinct characters is 4.\n    \"\"\"\n    string = string.lower()\n    distinct_characters = set(string)\n    return len(distinct_characters)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/141": [{"task_id": "HumanEval/141", "solution": "\ndef file_name_check(file_name):\n    if len(re.findall('\\\\d', file_name)) > 3:\n        return 'No'\n    (name, extension) = file_name.split('.')\n    if not name[0].isalpha() or extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["example.txt"]], "plus_fail_tests": [["example.py"]]}], "HumanEval/7": [{"task_id": "HumanEval/7", "solution": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/36": [{"task_id": "HumanEval/36", "solution": "\n\ndef fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7')\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/67": [{"task_id": "HumanEval/67", "solution": "\ndef fruit_distribution(s, n):\n    words = s.split()\n    num_apples = int(words[0])\n    num_oranges = int(words[2])\n    num_mangoes = n - (num_apples + num_oranges)\n    return num_mangoes", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["5 apples and 6 oranges", 19]], "plus_fail_tests": [["10 apples and 20 oranges", 50]]}], "HumanEval/129": [{"task_id": "HumanEval/129", "solution": "\ndef minPath(grid, k):\n    N = len(grid)\n    dp = [[[float('inf')] * (k + 1) for _ in range(N)] for _ in range(N)]\n    path = [[[[] for _ in range(k + 1)] for _ in range(N)] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            dp[i][j][1] = grid[i][j]\n            path[i][j][1] = [grid[i][j]]\n    for l in range(2, k + 1):\n        for i in range(N):\n            for j in range(N):\n                for (x, y) in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                    if 0 <= x < N and 0 <= y < N:\n                        if dp[i][j][l] > dp[x][y][l - 1] + grid[i][j]:\n                            dp[i][j][l] = dp[x][y][l - 1] + grid[i][j]\n                            path[i][j][l] = path[x][y][l - 1] + [grid[i][j]]\n    min_path = min((path[i][j][k] for i in range(N) for j in range(N)))\n    return min_path", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9]], "plus_fail_tests": [[[[2, 3, 4], [5, 6, 7], [8, 9, 1]], 5]]}], "HumanEval/54": [{"task_id": "HumanEval/54", "solution": "\n\ndef same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/29": [{"task_id": "HumanEval/29", "solution": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    return [s for s in strings if s.startswith(prefix)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/145": [{"task_id": "HumanEval/145", "solution": "def order_by_points(nums):\n\n    def sum_of_digits(n):\n        return sum((int(digit) for digit in str(abs(n))))\n    nums.sort(key=sum_of_digits)\n    return nums", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 11, -1, -11, -12]]], "plus_fail_tests": [[[-5, -12, 9, 15]]]}], "HumanEval/59": [{"task_id": "HumanEval/59", "solution": "\n\ndef largest_prime_factor(n: int):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/78": [{"task_id": "HumanEval/78", "solution": "\ndef hex_key(num):\n    prime_digits = ['2', '3', '5', '7', 'B', 'D']\n    count = 0\n    for digit in num:\n        if digit in prime_digits:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/153": [{"task_id": "HumanEval/153", "solution": "\ndef Strongest_Extension(class_name, extensions):\n    strongest_extension = extensions[0]\n    strongest_strength = sum((1 for c in strongest_extension if c.isupper())) - sum((1 for c in strongest_extension if c.islower()))\n    for extension in extensions[1:]:\n        strength = sum((1 for c in extension if c.isupper())) - sum((1 for c in extension if c.islower()))\n        if strength > strongest_strength:\n            strongest_extension = extension\n            strongest_strength = strength\n    return class_name + '.' + strongest_extension", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/69": [{"task_id": "HumanEval/69", "solution": "\ndef search(lst):\n    from collections import Counter\n    counter = Counter(lst)\n    for num in sorted(counter.keys(), reverse=True):\n        if counter[num] >= num:\n            return num\n    return -1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/122": [{"task_id": "HumanEval/122", "solution": "\ndef add_elements(arr, k):\n    total = 0\n    for i in range(k):\n        if arr[i] < 100:\n            total += arr[i]\n    return total", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[-100, -89, -77, -55, 900, -44, -22, -11], 7]]}], "HumanEval/11": [{"task_id": "HumanEval/11", "solution": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    result = ''\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += '0'\n        else:\n            result += '1'\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/2": [{"task_id": "HumanEval/2", "solution": "\n\ndef truncate_number(number: float) -> float:\n    \"\"\" \n    This function is designed to process a positive floating point number and isolate its decimal part. \n\n    First, a given floating point number is decomposed into two components: \n    1. An integer part, which is the largest integer that is smaller than or equal to the given number.\n    2. A decimal part, which is the leftover part of the number after subtracting the integer part. This part is always smaller than 1.\n\n    The function then returns just the decimal part of the number, effectively truncating the integer part.\n\n    Parameters: \n    number (float): The positive floating point number that will be processed by the function. \n    \n    Returns: \n    This function returns a float, representing the decimal part of the input number.\n\n    Example:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    if number < 0:\n        raise ValueError('The number must be positive.')\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return decimal_part", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/103": [{"task_id": "HumanEval/103", "solution": "\ndef rounded_avg(n, m):\n    if n > m:\n        return -1\n    else:\n        avg = round(sum(range(n, m + 1)) / (m - n + 1))\n        return bin(avg)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/138": [{"task_id": "HumanEval/138", "solution": "\ndef is_equal_to_sum_even(n):\n    if n < 8:\n        return False\n    else:\n        return n % 4 == 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[22]]}], "HumanEval/5": [{"task_id": "HumanEval/5", "solution": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    result = []\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i < len(numbers) - 1:\n            result.append(delimeter)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/61": [{"task_id": "HumanEval/61", "solution": "\n\ndef correct_bracketing(brackets: str):\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif bracket == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    return len(stack) == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/127": [{"task_id": "HumanEval/127", "solution": "\ndef intersection(interval1, interval2):\n    intersection_start = max(interval1[0], interval2[0])\n    intersection_end = min(interval1[1], interval2[1])\n    if intersection_start > intersection_end:\n        return 'NO'\n    intersection_length = intersection_end - intersection_start + 1\n    if intersection_length > 1:\n        for i in range(2, intersection_length):\n            if intersection_length % i == 0:\n                return 'NO'\n        else:\n            return 'YES'\n    else:\n        return 'NO'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-1, 1], [0, 4]]], "plus_fail_tests": [[[10, 20], [15, 25]]]}], "HumanEval/161": [{"task_id": "HumanEval/161", "solution": "\ndef solve(s):\n    if any((c.isalpha() for c in s)):\n        return ''.join((c.lower() if c.isupper() else c.upper() for c in s))\n    else:\n        return s[::-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/30": [{"task_id": "HumanEval/30", "solution": "\n\ndef get_positive(l: list):\n    return [num for num in l if num > 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/27": [{"task_id": "HumanEval/27", "solution": "\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/151": [{"task_id": "HumanEval/151", "solution": "\ndef double_the_difference(lst):\n    return sum((i ** 2 for i in lst if i > 0 and i % 2 == 1))", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1.0, 3.5, -4.6]]]}], "HumanEval/85": [{"task_id": "HumanEval/85", "solution": "\ndef add(lst):\n    total = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/113": [{"task_id": "HumanEval/113", "solution": "\ndef odd_count(lst):\n    output = []\n    for string in lst:\n        odd_count = sum((1 for digit in string if int(digit) % 2 != 0))\n        output.append(f'the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.')\n    return output", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/134": [{"task_id": "HumanEval/134", "solution": "\ndef check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) > 1 and txt[-2].isalpha():\n        return False\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["aaaaa aaaaa 1A"]]}], "HumanEval/142": [{"task_id": "HumanEval/142", "solution": "def sum_squares(lst):\n    result = []\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            result.append(lst[i] ** 2)\n        elif i % 4 == 0:\n            result.append(lst[i] ** 3)\n        else:\n            result.append(lst[i])\n    return sum(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/28": [{"task_id": "HumanEval/28", "solution": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    return ''.join(strings)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/42": [{"task_id": "HumanEval/42", "solution": "\n\ndef incr_list(l: list):\n    return [i + 1 for i in l]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/38": [{"task_id": "HumanEval/38", "solution": "\ndef encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n    \ndef decode_cyclic(s: str):\n    \"\"\"\n    The function 'decode_cyclic' accepts a single argument, 's', which is a string that has previously been encoded by the \n    corresponding 'encode_cyclic' function. The purpose of this function is to decode that input and restore its original \n    content.\n    \"\"\"\n    groups = [s[3 * i:min(3 * i + 3, len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [group[-1] + group[:-1] if len(group) == 3 else group for group in groups]\n    return ''.join(groups)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/12": [{"task_id": "HumanEval/12", "solution": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    else:\n        return max(strings, key=len)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/18": [{"task_id": "HumanEval/18", "solution": "\n\ndef how_many_times(string: str, substring: str) -> int:\n    count = start = 0\n    while start < len(string):\n        pos = string.find(substring, start)\n        if pos != -1:\n            count += 1\n            start = pos + 1\n        else:\n            break\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/53": [{"task_id": "HumanEval/53", "solution": "\n\ndef add(x: int, y: int) -> int:\n    \"\"\"\n    The function 'add' takes in two arguments, 'x' and 'y', both of which are integers.\n    It calculates the sum of these two integers and returns the result.\n    It demonstrates the basic operation of addition in Python, and is a fundamental building block in many more complex algorithms.\n    \n    Args:\n    x (int): The first integer to be added.\n    y (int): The second integer to be added.\n\n    Returns:\n    The result of the addition operation, which is the sum of 'x' and 'y'.\n\n    Examples:\n    >>> add(2, 3)\n    5\n    This means that if we input 2 and 3 into the function, it will return 5.\n\n    >>> add(5, 7)\n    12\n    This means that if we input 5 and 7 into the function, it will return 12.\n    \"\"\"\n    return x + y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/111": [{"task_id": "HumanEval/111", "solution": "\ndef histogram(test):\n    hist = {}\n    words = test.split()\n    for word in words:\n        for char in word:\n            if char in hist:\n                hist[char] += 1\n            else:\n                hist[char] = 1\n    max_count = max(hist.values())\n    max_hist = {char: count for (char, count) in hist.items() if count == max_count}\n    return max_hist", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[""]], "plus_fail_tests": [[""]]}], "HumanEval/106": [{"task_id": "HumanEval/106", "solution": "\ndef f(n):\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(math.factorial(i))\n        else:\n            result.append(sum(range(1, i + 1)))\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[2]]}], "HumanEval/139": [{"task_id": "HumanEval/139", "solution": "\ndef special_factorial(n):\n    ...", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[4]], "plus_fail_tests": [[2]]}], "HumanEval/32": [{"task_id": "HumanEval/32", "solution": "\nimport math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n    \ndef find_zero(xs: list, initial_guess: float=0.0, tolerance: float=1e-06, max_iterations: int=100):\n    \"\"\"\n    This function, find_zero, processes a list, xs, which contains the coefficients of a polynomial. The order of the coefficients\n    should align with the degree of the terms of the polynomial, from the constant term to the highest degree term.\n\n    The purpose of find_zero is to determine a value x such that when it is substituted into the polynomial, the result of the resulting calculation equals 0.\n    This represents one of the roots of the polynomial expression, where the curve represented by the polynomial intersects the x-axis.\n\n    Despite polynomials potentially having multiple roots (zero points), this function will return only one of them. This is due to its intended purpose,\n    which is to quickly identify a single root rather than find all of them.\n\n    For the function to guarantee a valid root or zero point, it only accepts input lists, xs, that contain an even number of coefficients. These coefficients\n    should include a largest non-zero coefficient. As these features would assure the polynomial has at least one root.\n\n    Thus, this function helps to find a root for polynomial functions in a simple and quick manner with certain assumptions about the polynomial's properties\n    based on the input coefficient list.\n\n    Examples:\n    >>> round(find_zero([1, 2]), 2) # For the polynomial f(x) = 1 + 2x, one of the roots is x = -0.5\n    -0.5\n\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # For the polynomial f(x) = -6 + 11x - 6x^2 + x^3 which expands to (x - 1) * (x - 2) * (x - 3), one of the roots is x = 1.0\n    1.0\n    \"\"\"\n    derivative = [i * coeff for (i, coeff) in enumerate(xs)][1:]\n    guess = initial_guess\n    for _ in range(max_iterations):\n        value = poly(xs, guess)\n        derivative_value = poly(derivative, guess)\n        if derivative_value == 0:\n            return None\n        next_guess = guess - value / derivative_value\n        if abs(next_guess - guess) < tolerance:\n            return next_guess\n        guess = next_guess\n    return None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-10, -2]]], "plus_fail_tests": [[[5, 10, -3, 1]]]}], "HumanEval/143": [{"task_id": "HumanEval/143", "solution": "\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["This is a test"]], "plus_fail_tests": [["cats and dogs"]]}], "HumanEval/91": [{"task_id": "HumanEval/91", "solution": "\ndef is_bored(S):\n    sentences = S.replace('!', '.').replace('?', '.').split('.')\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith('I ') or sentence.startswith('I.'):\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/121": [{"task_id": "HumanEval/121", "solution": "\ndef solution(lst):\n    return sum((lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/22": [{"task_id": "HumanEval/22", "solution": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    return [value for value in values if isinstance(value, int)]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[true, false, null, 0, -10, "test", [], {}, 3.14]]]}], "HumanEval/9": [{"task_id": "HumanEval/9", "solution": "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_numbers = []\n    for i in range(len(numbers)):\n        if i == 0:\n            max_numbers.append(numbers[i])\n        else:\n            max_numbers.append(max(max_numbers[i - 1], numbers[i]))\n    return max_numbers", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/49": [{"task_id": "HumanEval/49", "solution": "\n\ndef modp(n: int, p: int) -> int:\n    \"\"\"\n    This function calculates the modulus of the power of 2 raised to a given integer, n, by another given integer, p. \n    The operation performed is 2^n modulo p. This function can be used for calculations involving large powers and moduli,\n    but it's important to keep numerical stability in mind.\n\n    Parameters:\n    n (int): This is the exponent to which 2 is raised. This must be a non-negative integer.\n    p (int): This is the modulus. It must be a positive integer.\n\n    Returns:\n    int: The result of the operation 2^n modulo p is returned as an integer.\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    The above example returns 3 because 2^3 = 8, and 8 modulo 5 equals 3.\n\n    >>> modp(1101, 101)\n    2\n    This is a case with larger numbers. It returns 2 because 2^1101 modulo 101 equals 2.\n\n    >>> modp(0, 101)\n    1\n    This returns 1 because 2^0 = 1, and 1 modulo any number equals 1.\n\n    >>> modp(3, 11)\n    8\n    This returns 8 because 2^3 = 8, and 8 modulo 11 equals 8 (as 11 > 8).\n\n    >>> modp(100, 101)\n    1\n    This returns 1 because 2^100 modulo 101 equals 1.\n    \"\"\"\n    return pow(2, n, p)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/24": [{"task_id": "HumanEval/24", "solution": "def largest_divisor(n: int) -> int:\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/80": [{"task_id": "HumanEval/80", "solution": "\ndef is_happy(s):\n    if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/136": [{"task_id": "HumanEval/136", "solution": "\ndef largest_smallest_integers(lst):\n    negatives = [i for i in lst if i < 0]\n    positives = [i for i in lst if i > 0]\n    a = max(negatives) if negatives else None\n    b = min(positives) if positives else None\n    return (a, b)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/21": [{"task_id": "HumanEval/21", "solution": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n    return [(num - min_val) / range_val for num in numbers]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/0": [{"task_id": "HumanEval/0", "solution": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/40": [{"task_id": "HumanEval/40", "solution": "def triples_sum_to_zero(l: list):\n    if len(l) < 3:\n        return False\n    for triple in combinations(l, 3):\n        if sum(triple) == 0:\n            return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 3, 5, 0]]], "plus_fail_tests": [[[0, 0, 0]]]}], "HumanEval/140": [{"task_id": "HumanEval/140", "solution": "\ndef fix_spaces(text):\n    text = text.replace(' ', '_')\n    text = re.sub('_+', '-', text)\n    if text[0] == '_':\n        text = '-' + text[1:]\n    return text", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Example"]], "plus_fail_tests": [["Hello,   world!"]]}], "HumanEval/58": [{"task_id": "HumanEval/58", "solution": "\n\ndef common(l1: list, l2: list):\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1 & set2\n    sorted_common_elements = sorted(list(common_elements))\n    return sorted_common_elements", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/41": [{"task_id": "HumanEval/41", "solution": "\n\ndef car_race_collision(n: int) -> int:\n    \"\"\"\n    Calculate the total number of collisions between two groups of cars moving in opposite directions.\n    \"\"\"\n    return n * (n + 1) // 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[5]]}], "HumanEval/109": [{"task_id": "HumanEval/109", "solution": "\ndef move_one_ball(arr):\n    if not arr:\n        return True\n    else:\n        min_index = arr.index(min(arr))\n        return arr[min_index:] + arr[:min_index] == sorted(arr)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/52": [{"task_id": "HumanEval/52", "solution": "\n\ndef below_threshold(l: list, t: int) -> bool:\n    for num in l:\n        if num >= t:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/33": [{"task_id": "HumanEval/33", "solution": "\n\ndef sort_third(l: list):\n    divisible_by_3 = [l[i] for i in range(len(l)) if i % 3 == 0]\n    divisible_by_3.sort()\n    l_prime = l.copy()\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l_prime[i] = divisible_by_3.pop(0)\n    return l_prime", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/3": [{"task_id": "HumanEval/3", "solution": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/123": [{"task_id": "HumanEval/123", "solution": "\ndef get_odd_collatz(n):\n    if n < 1:\n        raise ValueError('Input must be a positive integer')\n    if n == 1:\n        return [1]\n    collatz_sequence = []\n    while n != 1:\n        collatz_sequence.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = n * 3 + 1\n    collatz_sequence.append(1)\n    odd_collatz_sequence = [num for num in collatz_sequence if num % 2 != 0]\n    return sorted(odd_collatz_sequence)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/137": [{"task_id": "HumanEval/137", "solution": "def compare_one(a, b):\n    if isinstance(a, str):\n        a = float(a.replace(',', '.'))\n    if isinstance(b, str):\n        b = float(b.replace(',', '.'))\n    if a == b:\n        return None\n    elif a > b:\n        return a\n    else:\n        return b", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, "2,3"]], "plus_fail_tests": [["-4,1", "-4.0"]]}], "HumanEval/128": [{"task_id": "HumanEval/128", "solution": "\ndef prod_signs(arr):\n    if not arr:\n        return None\n    sum_abs = sum((abs(x) for x in arr))\n    prod_sign = None\n    for x in arr:\n        if x > 0:\n            if prod_sign is None:\n                prod_sign = 1\n            else:\n                prod_sign *= 1\n        elif x < 0:\n            if prod_sign is None:\n                prod_sign = -1\n            else:\n                prod_sign *= -1\n        else:\n            return 0\n    return sum_abs * prod_sign", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/115": [{"task_id": "HumanEval/115", "solution": "\ndef max_fill(grid, capacity):\n    total_water = sum((sum(row) for row in grid))\n    if total_water % capacity == 0:\n        return total_water // capacity\n    else:\n        return total_water // capacity + 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 1, 1, 1], [1, 1, 1, 1]], 9]], "plus_fail_tests": [[[[1, 0, 0, 1], [0, 1, 1, 1], [0, 0, 0, 0], [1, 0, 1, 1]], 2]]}], "HumanEval/62": [{"task_id": "HumanEval/62", "solution": "\n\ndef derivative(xs: list):\n    \"\"\"\n    This function computes the derivative of a polynomial represented by its coefficients.\n    \n    The input argument 'xs' is a list that contains the coefficients of a polynomial. Each element in the\n    list corresponds to the coefficient of a polynomial term. The index of the coefficient in the list \n    determines the power of the term it is associated with. \n\n    In other words, the polynomial is represented as follows: xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    \n    The function will return a list of coefficients that represents the derivative of this polynomial. The \n    derivative is represented in the same form as the input polynomial. \n\n    Here are a couple of examples to illustrate the functionality of this function.\n\n    If the input is [3, 1, 2, 4, 5], the function will return [1, 4, 12, 20]. This is because the original \n    polynomial is 3 + x + 2x^2 + 4x^3 + 5x^4, and its derivative is 1 + 4x + 12x^2 + 20x^3\n\n    If the input is [1, 2, 3], the function will return [2, 6]. This is because the original polynomial is \n    1 + 2x + 3x^2, and its derivative is 2 + 6x.\n\n    Args:\n    xs: A list of numbers representing the coefficients of a polynomial.\n\n    Returns:\n    A list of numbers representing the coefficients of the derivative of the input polynomial.\n    \"\"\"\n    return [i * coeff for (i, coeff) in enumerate(xs)][1:]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/1": [{"task_id": "HumanEval/1", "solution": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    groups = []\n    start = 0\n    count = 0\n    for (i, char) in enumerate(paren_string):\n        if char == '(':\n            if count == 0:\n                start = i\n            count += 1\n        elif char == ')':\n            count -= 1\n            if count == 0:\n                groups.append(paren_string[start:i + 1])\n    return groups", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/112": [{"task_id": "HumanEval/112", "solution": "\ndef reverse_delete(s, c):\n    for char in c:\n        s = s.replace(char, '')\n    is_palindrome = s == s[::-1]\n    return (s, is_palindrome)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/131": [{"task_id": "HumanEval/131", "solution": "\ndef digits(n):\n    product = 1\n    for digit in str(n):\n        if int(digit) % 2 != 0:\n            product *= int(digit)\n    return product", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2468]], "plus_fail_tests": [[246]]}], "HumanEval/57": [{"task_id": "HumanEval/57", "solution": "\n\ndef monotonic(l: list):\n    increasing = decreasing = True\n    for i in range(len(l) - 1):\n        if l[i] > l[i + 1]:\n            increasing = False\n        if l[i] < l[i + 1]:\n            decreasing = False\n    return increasing or decreasing", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/148": [{"task_id": "HumanEval/148", "solution": "\ndef bf(planet1, planet2):\n    solar_system = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in solar_system or planet2 not in solar_system:\n        return ()\n    else:\n        index1 = solar_system.index(planet1)\n        index2 = solar_system.index(planet2)\n        if index1 > index2:\n            (index1, index2) = (index2, index1)\n        return tuple(solar_system[index1 + 1:index2])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/65": [{"task_id": "HumanEval/65", "solution": "\ndef circular_shift(x, shift):\n    x_str = str(x)\n    if shift > len(x_str):\n        return x_str[::-1]\n    elif shift == len(x_str):\n        return x_str\n    else:\n        first_part = x_str[:-shift]\n        second_part = x_str[-shift:]\n        result = second_part[::-1] + first_part[::-1]\n        return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[341209, 4]]}], "HumanEval/116": [{"task_id": "HumanEval/116", "solution": "\ndef sort_array(arr):\n    if all((isinstance(i, int) and i >= 0 for i in arr)):\n        arr.sort(key=lambda x: (bin(x).count('1'), x))\n    else:\n        print('Invalid input. The list should only contain non-negative integers.')", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 5, 2, 3, 4]]], "plus_fail_tests": [[[3, 7, 6, 5, 4]]]}], "HumanEval/118": [{"task_id": "HumanEval/118", "solution": "\ndef get_closest_vowel(word):\n    vowels = 'aeiouAEIOU'\n    for i in range(len(word) - 1, 0, -1):\n        if word[i] in vowels and word[i - 1] not in vowels and (word[i + 1] not in vowels):\n            return word[i]\n    return ''", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["ali"]], "plus_fail_tests": [["hello"]]}], "HumanEval/79": [{"task_id": "HumanEval/79", "solution": "\ndef decimal_to_binary(decimal):\n    binary = bin(decimal)[2:]\n    return 'db' + binary + 'db'", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/162": [{"task_id": "HumanEval/162", "solution": "\ndef string_to_md5(text):\n    if text == '':\n        return None\n    else:\n        result = hashlib.md5(text.encode())\n        return result.hexdigest()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Hello world"]], "plus_fail_tests": [["5873hajsdklh"]]}], "HumanEval/34": [{"task_id": "HumanEval/34", "solution": "\n\ndef unique(l: list):\n    return sorted(set(l))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/50": [{"task_id": "HumanEval/50", "solution": "\ndef encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    This function, 'decode_shift', accepts a single argument 's', which is a string data type. \n    The input string 's' is assumed to have been previously encoded using a specific function named 'encode_shift'. \n\n    The purpose of this function is to revert the encoding that was performed by 'encode_shift' function. \n    This is done by applying the same logic as 'encode_shift', but in reverse, to decode the string. As a result, it returns \n    the original, unaltered string, effectively undoing the encoding process. \n    \"\"\"\n    return ''.join([chr((ord(ch) - ord('a') - 5) % 26 + ord('a')) for ch in s])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/63": [{"task_id": "HumanEval/63", "solution": "\ndef fibfib(n: int):\n    if n < 0:\n        raise ValueError('n must be a non-negative integer')\n    elif n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 0\n    else:\n        (a, b, c) = (0, 0, 1)\n        for _ in range(3, n + 1):\n            (a, b, c) = (b, c, a + b + c)\n        return c", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[2]]}], "HumanEval/64": [{"task_id": "HumanEval/64", "solution": "def vowels_count(s):\n    vowels = 'aeiou'\n    count = 0\n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n    if s[-1].lower() == 'y':\n        count += 1\n    return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "HumanEval/158": [{"task_id": "HumanEval/158", "solution": "\ndef find_max(words):\n    max_unique = 0\n    max_word = ''\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/83": [{"task_id": "HumanEval/83", "solution": "\ndef starts_one_ends(n):\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError('Input must be a positive integer')\n    if n == 1:\n        return 2\n    else:\n        return 10 * 10 ** (n - 2) + 10", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1]], "plus_fail_tests": [[6]]}], "HumanEval/19": [{"task_id": "HumanEval/19", "solution": "from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    number_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    number_names = numbers.split()\n    digits = [number_dict[name] for name in number_names]\n    digits.sort()\n    sorted_number_names = [name for (name, digit) in number_dict.items() if digit in digits]\n    return ' '.join(sorted_number_names)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["two two three three four five six"]]}], "HumanEval/17": [{"task_id": "HumanEval/17", "solution": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" \n    This function takes as input a string that represents musical notes. These musical notes are represented \n    in a unique ASCII format. Each character or set of characters corresponds to a distinct musical note \n    with a specific duration, measured in beats. \n\n    The function's job is to parse the input string and translate it into a list of integers. Each integer \n    in the returned list corresponds to the number of beats for the respective musical note in the input string.\n\n    The mapping from characters to beats is defined as follows:\n    - 'o' is a whole note, which lasts for four beats\n    - 'o|' is a half note, and it lasts for two beats\n    - '.|' is a quarter note, and it only lasts for one beat\n\n    So, the function should read each musical note from the input string, convert it to the corresponding \n    number of beats using the mapping, and return a list of these beat counts in the same order as the notes \n    appeared in the input string.\n\n    For instance, if the function is called with the input string 'o o| .| o| o| .| .| .| .| o o', the function \n    should return the list [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]. This list indicates that the first note in the \n    string is a whole note lasting four beats, the second note is a half note lasting two beats, and so on.\n\n    Args:\n    music_string (str): A string representing musical notes in a special ASCII format.\n\n    Returns:\n    List[int]: A list of integers where each integer represents the number of beats a note lasts for.\n    \"\"\"\n    beat_mapping = {'o': 4, 'o|': 2, '.|': 1}\n    notes = music_string.split()\n    beats = [beat_mapping[note] for note in notes]\n    return beats", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/155": [{"task_id": "HumanEval/155", "solution": "\ndef even_odd_count(num):\n    num = abs(num)\n    even_count = 0\n    odd_count = 0\n    for digit in str(num):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/8": [{"task_id": "HumanEval/8", "solution": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers:\n        return (0, 1)\n    else:\n        return (sum(numbers), eval('*'.join((str(n) for n in numbers))))", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[true]]]}], "HumanEval/74": [{"task_id": "HumanEval/74", "solution": "\ndef total_match(lst1, lst2):\n    total1 = sum((len(s) for s in lst1))\n    total2 = sum((len(s) for s in lst2))\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/163": [{"task_id": "HumanEval/163", "solution": "\ndef generate_integers(a, b):\n    if a > b:\n        (a, b) = (b, a)\n    return [i for i in range(a, b + 1) if i % 2 == 0]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2, 10]], "plus_fail_tests": [[6, 12]]}], "HumanEval/133": [{"task_id": "HumanEval/133", "solution": "\n\ndef sum_squares(lst):\n    return sum((x ** 2 for x in map(math.ceil, lst)))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3]]], "plus_fail_tests": [[[-3, 4, 5, 6, 7]]]}], "HumanEval/154": [{"task_id": "HumanEval/154", "solution": "\ndef cycpattern_check(a, b):\n    cyclic_permutations = [b[i:] + b[:i] for i in range(len(b))]\n    for permutation in cyclic_permutations:\n        if permutation in a:\n            return True\n    return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["", ""]]}], "HumanEval/149": [{"task_id": "HumanEval/149", "solution": "\ndef sorted_list_sum(lst):\n    lst = [s for s in lst if len(s) % 2 == 0]\n    lst.sort(key=lambda s: (len(s), s))\n    return lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/152": [{"task_id": "HumanEval/152", "solution": "\ndef compare(game, guess):\n    return [abs(g - gs) for (g, gs) in zip(game, guess)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/48": [{"task_id": "HumanEval/48", "solution": "\n\ndef is_palindrome(text: str) -> bool:\n    \"\"\"\n    Function to determine whether a given string ('text') is a palindrome or not.\n\n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward\n\n    This function takes a string as an argument and returns a boolean value. If the 'text' string is a palindrome, the function returns True. If the 'text' string is not a palindrome, the function returns False.\n\n    Parameters:\n    text (str): The string to check for palindrome properties. This should be a sequence of characters. It could be a single word, a phrase, or a number as a string.\n\n    Returns:\n    bool: True if the 'text' is a palindrome. False otherwise.\n\n    Examples:\n    >>> is_palindrome('')\n    True\n    This is because an empty string is considered a palindrome as there are no characters to compare.\n\n    >>> is_palindrome('aba')\n    True\n    This is because 'aba' is a palindrome as it reads the same forward and backward.\n\n    >>> is_palindrome('aaaaa')\n    True\n    This is because 'aaaaa' is a palindrome as all the characters are the same.\n\n    >>> is_palindrome('zbcd')\n    False\n    This is because 'zbcd' is not a palindrome as it does not read the same forward and backward.\n    \"\"\"\n    text = ''.join((c for c in text if c.isalnum())).lower()\n    return text == text[::-1]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["never odd or even"]]}], "HumanEval/130": [{"task_id": "HumanEval/130", "solution": "\ndef tri(n):\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    else:\n        tribonacci = [1, 3]\n        for i in range(2, n + 1):\n            if i % 2 == 0:\n                tribonacci.append(1 + i // 2)\n            else:\n                tribonacci.append(tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 3])\n        return tribonacci", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[2]]}], "HumanEval/135": [{"task_id": "HumanEval/135", "solution": "def can_arrange(arr):\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            return i\n    return -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[4, 8, 5, 7, 3]]], "plus_fail_tests": [[[5, 4, 3, 2, 1]]]}], "HumanEval/37": [{"task_id": "HumanEval/37", "solution": "\n\ndef sort_even(l: list):\n    even_indices = [l[i] for i in range(0, len(l), 2)]\n    even_indices.sort()\n    for i in range(0, len(l), 2):\n        l[i] = even_indices.pop(0)\n    return l", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/70": [{"task_id": "HumanEval/70", "solution": "\ndef strange_sort_list(lst):\n    sorted_lst = []\n    while lst:\n        min_val = min(lst)\n        lst.remove(min_val)\n        sorted_lst.append(min_val)\n        if lst:\n            max_val = max(lst)\n            lst.remove(max_val)\n            sorted_lst.append(max_val)\n    return sorted_lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/99": [{"task_id": "HumanEval/99", "solution": "\ndef closest_integer(value):\n    \"\"\"\n    This function is designed to take a single parameter 'value', which is a string representation of a numerical value.\n    The function's purpose is to return the nearest integer to the given 'value'. If the 'value' is exactly halfway \n    between two integers, the function will round it away from zero. \n\n    The function operates by converting the string representation of the number to a float, then using standard rounding \n    rules to identify the nearest integer. If the fractional part of the number is .5, the function will round up if the \n    'value' is positive, or round down if the 'value' is negative, thus rounding away from zero in line with the \n    specification.\n\n    Parameters:\n    value (str): A string that represents a number, which can be either an integer or a float.\n\n    Returns:\n    int: The integer that is closest to the given 'value'. If the 'value' is exactly halfway between \n    two integers, the function will return the integer that is further from zero.\n\n    Examples:\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is exactly halfway between two integers, the function will \n    return the integer that is further from zero. For instance, if the given number is \"14.5\", the function will return \n    15, and if the number is \"-14.5\", the function will return -15.\n    \"\"\"\n    value = float(value)\n    if value > 0:\n        return int(value + 0.5)\n    else:\n        return int(value - 0.5)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/132": [{"task_id": "HumanEval/132", "solution": "\ndef is_nested(string):\n    stack = []\n    for bracket in string:\n        if bracket == '[':\n            stack.append(bracket)\n        elif bracket == ']':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["[][]"]], "plus_fail_tests": [["[[]]]"]]}], "HumanEval/10": [{"task_id": "HumanEval/10", "solution": "\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that can be formed beginning with a supplied string.\n\n    This function uses a simple algorithm to determine how to make the given string into a palindrome, which\n    is a string that reads the same forward and backward. The algorithm proceeds through the following steps:\n    1. It first finds the longest suffix (ending segment) of the supplied string that itself is a palindrome.\n    2. It then appends to the end of the original string the reversed string of the prefix \n       (beginning segment) that comes before this palindromic suffix. \n\n    As a result, the returning string is the shortest possible palindrome that starts with the given string.\n    Should the input string already be a palindrome, the function will simply return the original string.\n\n    This function is case-sensitive and does not alter the case of the lettering in the original string.\n\n    Parameters:\n    string (str): The string to be made into a palindrome.\n\n    Returns:\n    str: The shortest possible palindrome that starts with the input string.\n\n    Doctest:\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    for i in range(len(string)):\n        suffix = string[i:]\n        if is_palindrome(suffix):\n            prefix = string[:i]\n            return string + prefix[::-1]\n    return string + string[::-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/159": [{"task_id": "HumanEval/159", "solution": "\ndef eat(number, need, remaining):\n    if not all((isinstance(i, int) and 0 <= i <= 1000 for i in [number, need, remaining])):\n        raise ValueError('All inputs must be non-negative integers not exceeding 1000.')\n    total_eaten = number + min(need, remaining)\n    remaining_carrots = max(remaining - need, 0)\n    return [total_eaten, remaining_carrots]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/56": [{"task_id": "HumanEval/56", "solution": "\n\ndef correct_bracketing(brackets: str):\n    open_brackets = 0\n    for bracket in brackets:\n        if bracket == '<':\n            open_brackets += 1\n        elif bracket == '>':\n            if open_brackets == 0:\n                return False\n            open_brackets -= 1\n    return open_brackets == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/126": [{"task_id": "HumanEval/126", "solution": "def is_sorted(lst):\n    if lst != sorted(lst):\n        return False\n    if len(lst) != len(set(lst)):\n        return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 2, 3, 3, 4]]], "plus_fail_tests": [[[1, 1, 2, 2, 3, 3, 4]]]}], "HumanEval/117": [{"task_id": "HumanEval/117", "solution": "\ndef select_words(s, n):\n    vowels = 'aeiou'\n    words = s.split()\n    result = []\n    for word in words:\n        count = sum((1 for char in word.lower() if char not in vowels))\n        if count == n:\n            result.append(word)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/76": [{"task_id": "HumanEval/76", "solution": "\ndef is_simple_power(x, n):\n    if n == 1 and x != 1:\n        return False\n    i = 0\n    while n ** i <= x:\n        if n ** i == x:\n            return True\n        i += 1\n    return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-2, -2]]}], "HumanEval/150": [{"task_id": "HumanEval/150", "solution": "\ndef x_or_y(n, x, y):\n    if n <= 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n    return x", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/90": [{"task_id": "HumanEval/90", "solution": "\ndef next_smallest(lst):\n    if len(lst) == 0 or len(set(lst)) == 1:\n        return None\n    else:\n        lst.sort()\n        return lst[1]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 2, 2, 2, 2, 2, 3, 3, 3, 3]]]}], "HumanEval/94": [{"task_id": "HumanEval/94", "solution": "\n\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/25": [{"task_id": "HumanEval/25", "solution": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/15": [{"task_id": "HumanEval/15", "solution": "\n\ndef string_sequence(n: int) -> str:\n    return ' '.join(map(str, range(n + 1)))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/100": [{"task_id": "HumanEval/100", "solution": "\ndef make_a_pile(n):\n    pile = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n + 2\n        else:\n            n = n + 1\n        pile.append(n)\n    return pile", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[2]]}], "HumanEval/39": [{"task_id": "HumanEval/39", "solution": "\n\ndef prime_fib(n: int):\n\n    def fibonacci():\n        (a, b) = (0, 1)\n        while True:\n            yield a\n            (a, b) = (b, a + b)\n\n    def primes(n):\n        sieve = [True] * n\n        for x in range(2, int(n ** 0.5) + 1):\n            if sieve[x]:\n                for i in range(x * x, n, x):\n                    sieve[i] = False\n        return [x for x in range(2, n) if sieve[x]]\n    fib = fibonacci()\n    prime = primes(10000)\n    count = 0\n    while True:\n        f = next(fib)\n        if f in prime:\n            count += 1\n            if count == n:\n                return f", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[8]], "plus_fail_tests": [[11]]}]}}