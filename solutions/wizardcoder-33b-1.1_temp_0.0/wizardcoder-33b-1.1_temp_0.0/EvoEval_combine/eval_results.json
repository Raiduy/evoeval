{"eval": {"EvoEval/57": [{"task_id": "EvoEval/57", "solution": "def palindromic_and_odd_digit_array(arr):\n    n = len(arr)\n    changes = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            changes += 1\n        if arr[i] % 2 == 0 or arr[n - i - 1] % 2 == 0:\n            changes += 1\n    if n % 2 == 1 and arr[n // 2] % 2 == 0:\n        changes += 1\n    return changes", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 2, 5]]], "plus_fail_tests": []}], "EvoEval/40": [{"task_id": "EvoEval/40", "solution": "\ndef largest_prime_odd_ends(nums):\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def is_odd_ends(n):\n        n = abs(n)\n        return int(str(n)[0]) % 2 != 0 and int(str(n)[-1]) % 2 != 0\n    primes = [num for num in nums if num > 10 and is_prime(num) and is_odd_ends(num)]\n    return max(primes) if primes else None", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[51, -73, 14, -15]]], "plus_fail_tests": []}], "EvoEval/81": [{"task_id": "EvoEval/81", "solution": "\nfrom typing import List\n\ndef mean_absolute_deviation_fibfib(n: int) -> float:\n    fibfib = [0, 0, 1]\n    for i in range(3, n):\n        fibfib.append(fibfib[i - 1] + fibfib[i - 2] + fibfib[i - 3])\n    mean = sum(fibfib) / n\n    mad = sum((abs(x - mean) for x in fibfib)) / n\n    return round(mad, 2)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[8]], "plus_fail_tests": []}], "EvoEval/35": [{"task_id": "EvoEval/35", "solution": "def check_dict_happiness(dict):\n    if not dict:\n        return False\n    for key in dict.keys():\n        if not isinstance(key, str):\n            return False\n        if not key.islower() and (not key.isupper()):\n            return False\n        if len(key) < 3:\n            return False\n        for i in range(len(key) - 2):\n            if len(set(key[i:i + 3])) != 3:\n                return False\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"abc": "apple", "ABD": "banana"}]], "plus_fail_tests": []}], "EvoEval/47": [{"task_id": "EvoEval/47", "solution": "def count_odd_upper(s, lst):\n    vowels = 'AEIOU'\n    n = sum((1 for i in range(0, len(s), 2) if s[i] in vowels))\n    result = []\n    for string in lst:\n        m = sum((1 for digit in string if int(digit) % 2 != 0))\n        result.append(f'In the string, the number of uppercase vowels in even indices is {n}, and the number of odd digits is {m}.')\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/38": [{"task_id": "EvoEval/38", "solution": "\ndef even_odd_zero_sum(l, n):\n\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    even_palindromes = sum((is_palindrome(i) and i % 2 == 0 for i in range(1, n + 1)))\n    odd_palindromes = sum((is_palindrome(i) and i % 2 != 0 for i in range(1, n + 1)))\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            if l[i] + l[j] == even_palindromes:\n                return (True, False)\n            if l[i] + l[j] == odd_palindromes:\n                return (False, True)\n    return (False, False)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 3, 2, -3, -1, 5, -2, 14], 101]], "plus_fail_tests": []}], "EvoEval/14": [{"task_id": "EvoEval/14", "solution": "\ndef prime_avg_range(n, m):\n    if n > m:\n        return -1\n    primes = [i for i in range(n, m + 1) if all((i % j != 0 for j in range(2, int(i ** 0.5) + 1))) and i > 1]\n    if not primes:\n        return -1\n    avg = round(sum(primes) / len(primes))\n    return bin(avg)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[-10, 0]], "plus_fail_tests": []}], "EvoEval/10": [{"task_id": "EvoEval/10", "solution": "\ndef class_grades_with_flip(name_grade_list):\n\n    def convert_to_proper_case(name):\n        return name.capitalize()\n\n    def convert_to_letter_grade(gpa):\n        if gpa >= 4.0:\n            return 'A+'\n        elif gpa >= 3.7:\n            return 'A'\n        elif gpa >= 3.3:\n            return 'A-'\n        elif gpa >= 3.0:\n            return 'B+'\n        elif gpa >= 2.7:\n            return 'B'\n        elif gpa >= 2.3:\n            return 'B-'\n        elif gpa >= 2.0:\n            return 'C+'\n        elif gpa >= 1.7:\n            return 'C'\n        elif gpa >= 1.3:\n            return 'C-'\n        elif gpa >= 1.0:\n            return 'D+'\n        elif gpa >= 0.7:\n            return 'D'\n        elif gpa >= 0.0:\n            return 'D-'\n        else:\n            return 'E'\n    return [(convert_to_proper_case(name), convert_to_letter_grade(gpa)) for (name, gpa) in name_grade_list]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[["JOHN", 4.0], ["sarah", 3.0], ["ALICE", 1.7], ["BOB", 2.0], ["linda", 3.5]]]], "plus_fail_tests": []}], "EvoEval/13": [{"task_id": "EvoEval/13", "solution": "def filter_exchange(arr, lst1):\n    arr = [num for num in arr if sum((int(digit) for digit in str(abs(num)))) > 0]\n    for num in arr:\n        if num % 2 != 0 and len(lst1) > 0:\n            lst1.remove(num)\n    return 'YES' if all((num % 2 == 0 for num in lst1)) else 'NO'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 1, -122, 2], [1, 2, 3, 4]]], "plus_fail_tests": []}], "EvoEval/62": [{"task_id": "EvoEval/62", "solution": "\ndef strange_word_sort(text):\n    text = text.replace('   ', '-')\n    text = text.replace(' ', '_')\n    words = text.split('_')\n    words.sort(key=str.lower)\n    sorted_words = []\n    while words:\n        sorted_words.append(words.pop(0))\n        if words:\n            sorted_words.append(words.pop())\n    return '_'.join(sorted_words)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["House   car"]], "plus_fail_tests": []}], "EvoEval/22": [{"task_id": "EvoEval/22", "solution": "def binary_planet_distance(planet1, planet2):\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ''\n    else:\n        planet1_index = planets.index(planet1)\n        planet2_index = planets.index(planet2)\n        if planet1_index > planet2_index:\n            (planet1_index, planet2_index) = (planet2_index, planet1_index)\n        planets_in_between = planets[planet1_index + 1:planet2_index]\n        binary_string = bin(len(planets_in_between))[2:]\n        return 'bd' + binary_string + 'bd'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/78": [{"task_id": "EvoEval/78", "solution": "\ndef solve_and_count(s):\n    vowels = 'AEIOU'\n    s = list(s)\n    has_letter = False\n    for i in range(len(s)):\n        if s[i].isalpha():\n            has_letter = True\n            s[i] = s[i].lower() if s[i].isupper() else s[i].upper()\n    if not has_letter:\n        s = s[::-1]\n    count = sum((1 for i in range(0, len(s), 2) if s[i].isupper() and s[i] in vowels))\n    return (''.join(s), count)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/32": [{"task_id": "EvoEval/32", "solution": "\nfrom typing import List\n\ndef circular_shift_nested_parens(input: List[str], shift: int) -> List[int]:\n    nesting_depths = [max((s.count('(') for s in group.split())) for group in input]\n    num = int(''.join(map(str, nesting_depths)))\n    num_str = str(num)\n    if shift > len(num_str):\n        num_str = num_str[::-1]\n    else:\n        num_str = num_str[-shift:] + num_str[:-shift]\n    return [int(digit) for digit in num_str]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["(()())", "((()))", "()", "", "((())()())"], 5]], "plus_fail_tests": []}], "EvoEval/76": [{"task_id": "EvoEval/76", "solution": "def sort_prime_digit_sum(lst):\n    new_lst = lst[:]\n    for i in range(len(new_lst)):\n        if is_prime(new_lst[i]):\n            new_lst[i] = digit_sum(new_lst[i])\n    if (new_lst[0] + new_lst[-1]) % 2 == 0:\n        return sorted(new_lst, reverse=True)\n    else:\n        return sorted(new_lst)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]]], "plus_fail_tests": []}], "EvoEval/26": [{"task_id": "EvoEval/26", "solution": "\nfrom typing import List, Tuple\n\ndef sort_and_pluck(values: List[str]) -> Tuple[str, int]:\n    numeral_to_int = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    int_to_numeral = {v: k for (k, v) in numeral_to_int.items()}\n    sorted_values = [sorted(value.split(), key=lambda x: numeral_to_int[x]) for value in values]\n    even_numerals = [(numeral, i) for (i, value) in enumerate(sorted_values) for numeral in value if numeral_to_int[numeral] % 2 == 0]\n    if not even_numerals:\n        return ()\n    return min(even_numerals, key=lambda x: (numeral_to_int[x[0]], x[1]))", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["three two one", "five four zero", "six nine eight"]]], "plus_fail_tests": []}], "EvoEval/83": [{"task_id": "EvoEval/83", "solution": "\nimport re\n\n\ndef prime_underscored_length(text):\n    new_text = re.sub(' +', '_', text)\n    return is_prime(len(new_text))", "base_status": "fail", "plus_status": null, "base_fail_tests": [[" Example    4"]], "plus_fail_tests": []}], "EvoEval/85": [{"task_id": "EvoEval/85", "solution": "def next_smallest_sorted_binary(lst):\n    lst.sort(key=lambda x: (bin(x).count('1'), x))\n    return lst[1] if len(lst) > 1 else None", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 1]]], "plus_fail_tests": []}], "EvoEval/44": [{"task_id": "EvoEval/44", "solution": "\nfrom typing import List\n\ndef roman_prefixes(number: int) -> List[str]:\n    roman_num = int_to_roman(number)\n    return [roman_num[:i] for i in range(1, len(roman_num) + 1)]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[711]], "plus_fail_tests": []}], "EvoEval/71": [{"task_id": "EvoEval/71", "solution": "\nimport math\n\ndef special_brazilian_balloon(n, w):\n    brazilian_factorial = math.factorial(n)\n    for i in range(1, n):\n        brazilian_factorial *= math.factorial(n - i)\n    if sum(w) > brazilian_factorial:\n        return False\n    if w != w[::-1]:\n        return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/31": [{"task_id": "EvoEval/31", "solution": "\nfrom typing import List\n\ndef special_prime_factorial(n: int) -> int:\n\n    def get_prime_factors(n: int) -> List[int]:\n        i = 2\n        factors = []\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                factors.append(i)\n        if n > 1:\n            factors.append(n)\n        return factors\n    prime_factors = get_prime_factors(n)\n    special_factorial = 1\n    for factor in set(prime_factors):\n        special_factorial *= factorial(prime_factors.count(factor)) * factorial(factor)\n    return special_factorial", "base_status": "fail", "plus_status": null, "base_fail_tests": [[70]], "plus_fail_tests": []}], "EvoEval/19": [{"task_id": "EvoEval/19", "solution": "from typing import List, Tuple, Optional\n\ndef account_operations(operations: List[int]) -> Tuple[Optional[int], Optional[int], bool]:\n    balance = 0\n    min_deposit = None\n    max_withdrawal = None\n    falls_below_zero = False\n    for operation in operations:\n        if operation > 0:\n            if min_deposit is None or operation < min_deposit:\n                min_deposit = operation\n        elif max_withdrawal is None or operation > max_withdrawal:\n            max_withdrawal = operation\n        balance += operation\n        if balance < 0:\n            falls_below_zero = True\n    return (max_withdrawal, min_deposit, falls_below_zero)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, -3, 2, -2, 5]]], "plus_fail_tests": []}], "EvoEval/89": [{"task_id": "EvoEval/89", "solution": "\nfrom typing import List\n\ndef md5_substring_filter(strings: List[str], hash_substring: str) -> List[str]:\n    if not strings:\n        return None\n    result = []\n    for string in strings:\n        if string:\n            md5_hash = hashlib.md5(string.encode()).hexdigest()\n            if hash_substring in md5_hash:\n                result.append(string)\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["Python", "Hello", "123", ""], "96"]], "plus_fail_tests": []}], "EvoEval/74": [{"task_id": "EvoEval/74", "solution": "def sum_exchange(lst1, lst2, x, y, z):\n    if all((num % 2 == 0 for num in lst1)):\n        answer = 'YES'\n    else:\n        answer = 'NO'\n    if x == y + z or y == x + z or z == x + y:\n        answer = 'SUM ' + answer\n    else:\n        answer = 'NO_SUM ' + answer\n    return answer", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 4], [1, 2, 3, 4], 5, 2, 2]], "plus_fail_tests": []}], "EvoEval/82": [{"task_id": "EvoEval/82", "solution": "\ndef odd_fibfib(n: int):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        fibfib = [0, 0, 1]\n        for i in range(3, n + 1):\n            fibfib.append(fibfib[i - 1] + fibfib[i - 2] + fibfib[i - 3])\n            if fibfib[i] % 2 == 0:\n                fibfib[i] = product_of_odd_digits(fibfib[i])\n        return fibfib[n]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[9]], "plus_fail_tests": []}], "EvoEval/16": [{"task_id": "EvoEval/16", "solution": "def get_music_notes(word: str, music_string: str):\n    vowels = 'aeiouAEIOU'\n    notes = {'o': 4, 'o|': 2, '.|': 1}\n    result = []\n    for i in range(len(word) - 1, 0, -1):\n        if word[i] in vowels and word[i - 1] not in vowels and (word[i + 1] not in vowels):\n            music_notes = music_string.split()\n            for j in range(i + 1):\n                result.append(notes[music_notes[j]])\n            break\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["yogurt", ""]], "plus_fail_tests": []}], "EvoEval/75": [{"task_id": "EvoEval/75", "solution": "def transform_dict(input_dict):\n    if not input_dict or not all((isinstance(k, str) for k in input_dict.keys())):\n        return {}\n    if not all((k.isupper() for k in input_dict.keys())) and (not all((k.islower() for k in input_dict.keys()))):\n        return {}\n    return {k: round(float(v)) for (k, v) in input_dict.items()}", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"A": "10.5", "B": "-15.5"}]], "plus_fail_tests": []}], "EvoEval/88": [{"task_id": "EvoEval/88", "solution": "\ndef process_and_sort_string(s):\n    words = s.replace(',', '').split()\n    words = [word for word in words if len(word) % 2 == 0]\n    words.sort(key=lambda x: (len(x), x))\n    return words", "base_status": "fail", "plus_status": null, "base_fail_tests": [[",a,b,c,d,e,f,g,h,i,j,"]], "plus_fail_tests": []}], "EvoEval/92": [{"task_id": "EvoEval/92", "solution": "\ndef get_common_max_triples(n, l1):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    common = sorted(list(set(a) & set(l1)))\n    count = 0\n    for i in range(len(common)):\n        for j in range(i + 1, len(common)):\n            for k in range(j + 1, len(common)):\n                if (common[i] + common[j] + common[k]) % 3 == 0:\n                    count += 1\n    return (common, count)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[20, [1, 3, 7, 13, 21, 25, 31, 37, 43, 49, 55, 61, 67, 73, 79, 85, 91, 97, 103, 109]]], "plus_fail_tests": []}], "EvoEval/55": [{"task_id": "EvoEval/55", "solution": "import hashlib\n\ndef mini_roman_to_md5(number):\n    if number <= 0 or number > 1000:\n        return None\n    val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    syb = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n    roman_num = ''\n    i = 0\n    while number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syb[i]\n            number -= val[i]\n        i += 1\n    return hashlib.md5(roman_num.encode()).hexdigest()", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1001]], "plus_fail_tests": []}], "EvoEval/91": [{"task_id": "EvoEval/91", "solution": "\ndef sort_prime_even(l, x, y):\n    even_indices = [l[i] for i in range(len(l)) if i % 2 == 0]\n    even_indices.sort()\n    for i in range(len(even_indices)):\n        if is_prime(even_indices[i]):\n            even_indices[i] = x\n        else:\n            even_indices[i] = y\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l[i] = even_indices.pop(0)\n    return l", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[7, 1, 9, 2, 8], 15, 30]], "plus_fail_tests": []}], "EvoEval/70": [{"task_id": "EvoEval/70", "solution": "\nfrom typing import List, Tuple\nimport math\n\n\ndef closest_special_factorial(numbers: List[int]) -> Tuple[int, int]:\n\n    def special_factorial(n: int) -> int:\n        if n == 0:\n            return 1\n        else:\n            return n * special_factorial(n - 1)\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (0, 0)\n    for i in range(1, len(numbers)):\n        diff = abs(special_factorial(numbers[i]) - special_factorial(numbers[i - 1]))\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i - 1], numbers[i])\n    return closest_pair", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[5, -6, -7]]], "plus_fail_tests": []}], "EvoEval/61": [{"task_id": "EvoEval/61", "solution": "\nfrom typing import List, Optional, Tuple\n\ndef longest_planet_chain(planet1: str, planet2: str, chains: List[Tuple[str, ...]]) -> Optional[Tuple[str, ...]]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return None\n    longest_chain = None\n    for chain in chains:\n        if chain[0] == planet1 and chain[-1] == planet2:\n            if longest_chain is None or len(chain) > len(longest_chain):\n                longest_chain = chain\n    return longest_chain", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/94": [{"task_id": "EvoEval/94", "solution": "\ndef sort_count_nums(arr):\n    count = sum((sum((int(digit) for digit in str(abs(num)))) > 0 for num in arr))\n    return sorted(arr, reverse=count % 2 == 0)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[15, -23, 56, 78, -90, 0, 34, 23, -45, 67]]], "plus_fail_tests": []}], "EvoEval/59": [{"task_id": "EvoEval/59", "solution": "def odd_count_base_change(lst, base):\n    result = []\n    for (i, s) in enumerate(lst):\n        odd_count = sum((1 for c in s if int(c, base) % 2 == 1))\n        result.append(f'the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.')\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["3", "11111111"], 3]], "plus_fail_tests": []}], "EvoEval/24": [{"task_id": "EvoEval/24", "solution": "from typing import List\n\ndef sort_happy_numbers(numbers: str) -> str:\n    num_map = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    num_list = numbers.split()\n    for i in range(len(num_list) - 2):\n        if num_list[i] == num_list[i + 1] or num_list[i] == num_list[i + 2] or num_list[i + 1] == num_list[i + 2]:\n            return 'Not a happy string'\n    num_list.sort(key=lambda x: num_map[x])\n    sorted_numbers = ' '.join(num_list)\n    return sorted_numbers", "base_status": "fail", "plus_status": null, "base_fail_tests": [["three one five"]], "plus_fail_tests": []}], "EvoEval/50": [{"task_id": "EvoEval/50", "solution": "\ndef get_closest_upper_vowel(word):\n    vowels = 'AEIOU'\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels and i % 2 == 0:\n            return word[i]\n    return ''", "base_status": "fail", "plus_status": null, "base_fail_tests": [["sOUnD"]], "plus_fail_tests": []}], "EvoEval/52": [{"task_id": "EvoEval/52", "solution": "def pluck_and_prod(arr):\n    if not arr:\n        return ([], None)\n    min_even = float('inf')\n    min_index = -1\n    for (i, num) in enumerate(arr):\n        if num % 2 == 0 and num < min_even:\n            min_even = num\n            min_index = i\n    if min_index == -1:\n        return ([], None)\n    arr.pop(min_index)\n    if not arr:\n        return ([min_even, min_index], None)\n    sum_remaining = sum((abs(num) for num in arr))\n    prod_signs = -1 if any((num < 0 for num in arr)) else 1\n    return ([min_even, min_index], sum_remaining * prod_signs)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[-5, -2, 3, 0, -4]]], "plus_fail_tests": []}], "EvoEval/34": [{"task_id": "EvoEval/34", "solution": "from typing import List\n\ndef md5_nested_parens(paren_string: str) -> List[str]:\n    if not paren_string:\n        return []\n    groups = paren_string.split()\n    result = []\n    for group in groups:\n        if not is_balanced(group):\n            result.append(hashlib.md5('None'.encode()).hexdigest())\n        else:\n            result.append(hashlib.md5(str(max_depth(group)).encode()).hexdigest())\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["(()()) (((((()))()((())()()))))"]], "plus_fail_tests": []}], "EvoEval/2": [{"task_id": "EvoEval/2", "solution": "\nfrom typing import List\n\ndef modp_intersperse(numbers: List[int], n: int, p: int) -> List[int]:\n    result = []\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i < len(numbers) - 1:\n            result.append(2 ** n % p)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/98": [{"task_id": "EvoEval/98", "solution": "\ndef check_dict_bracketing(dict):\n    if not dict:\n        return False\n    keys_case = None\n    for key in dict.keys():\n        if not isinstance(key, str):\n            return False\n        if keys_case is None:\n            keys_case = key.islower()\n        elif keys_case != key.islower():\n            return False\n    for value in dict.values():\n        if not isinstance(value, str):\n            return False\n        if value.count('(') != value.count(')'):\n            return False\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"Name": "()", "Age": "(())"}]], "plus_fail_tests": []}], "EvoEval/63": [{"task_id": "EvoEval/63", "solution": "\ndef sort_planets(planet1: str, planet2: str, order: str) -> str:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return 'Invalid'\n    order_list = order.split()\n    if len(order_list) != len(set(order_list)) or not all((0 <= int(i) <= 7 for i in order_list)):\n        return 'Invalid'\n    (index1, index2) = (planets.index(planet1), planets.index(planet2))\n    if index1 > index2:\n        (index1, index2) = (index2, index1)\n    result = [int(i) for i in order_list if index1 < planets.index(planets[int(i)]) < index2]\n    return ' '.join((str(i) for i in sorted(result, key=order_list.index)))", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Mercury", "Uranus", "zero one two three four five six seven"]], "plus_fail_tests": []}], "EvoEval/20": [{"task_id": "EvoEval/20", "solution": "\ndef grade_and_case(s, grades):\n\n    def get_grade(gpa):\n        if gpa >= 4.0:\n            return 'A+'\n        elif gpa >= 3.7:\n            return 'A'\n        elif gpa >= 3.3:\n            return 'A-'\n        elif gpa >= 3.0:\n            return 'B+'\n        elif gpa >= 2.7:\n            return 'B'\n        elif gpa >= 2.3:\n            return 'B-'\n        elif gpa >= 2.0:\n            return 'C+'\n        elif gpa >= 1.7:\n            return 'C'\n        elif gpa >= 1.3:\n            return 'C-'\n        elif gpa >= 1.0:\n            return 'D+'\n        elif gpa >= 0.7:\n            return 'D'\n        elif gpa >= 0.0:\n            return 'D-'\n        else:\n            return 'E'\n    return [(student.swapcase(), get_grade(grade)) for (student, grade) in zip(s, grades)]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["Amy", "BOB", "miLEs"], [4.0, 3, 1.7]]], "plus_fail_tests": []}], "EvoEval/33": [{"task_id": "EvoEval/33", "solution": "\ndef roman_happiness(s):\n    roman_dict = {'i': 1, 'v': 5, 'x': 10, 'l': 50, 'c': 100, 'd': 500, 'm': 1000}\n    if len(s) < 3 or len(set(s)) != len(s):\n        return False\n    num = 0\n    for i in range(len(s)):\n        if i > 0 and roman_dict[s[i]] > roman_dict[s[i - 1]]:\n            num += roman_dict[s[i]] - 2 * roman_dict[s[i - 1]]\n        else:\n            num += roman_dict[s[i]]\n    if num > 1000:\n        return False\n    return num", "base_status": "fail", "plus_status": null, "base_fail_tests": [["cmxcix"]], "plus_fail_tests": []}], "EvoEval/96": [{"task_id": "EvoEval/96", "solution": "\ndef common_pairs_with_zero_sum(l1: list, l2: list) -> bool:\n    common_elements = set(l1) & set(l2)\n    for element in common_elements:\n        if -element in common_elements:\n            return True\n    return False", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 3, 5, -3, 0], [0, -3, 1, 5, 2]]], "plus_fail_tests": []}], "EvoEval/67": [{"task_id": "EvoEval/67", "solution": "\nfrom typing import List\n\ndef max_close_element_difference(numbers: List[float], threshold: float) -> float:\n    numbers.sort()\n    max_diff = 0\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < threshold and diff > max_diff:\n            max_diff = diff\n    return max_diff", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1000000000.0, 1000000001.0, 1000000002.0, 1000000003.0, 1000000004.0], 5]], "plus_fail_tests": []}], "EvoEval/90": [{"task_id": "EvoEval/90", "solution": "\ndef vowels_in_dict_keys(dict):\n    vowels = 'aeiou'\n    result = {}\n    for key in dict.keys():\n        if not isinstance(key, str):\n            return {}\n        if not key.islower() and (not key.isupper()):\n            return {}\n        count = 0\n        for char in key:\n            if char.lower() in vowels:\n                count += 1\n        result[key] = count\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"a": "apple", "A": "banana", "B": "banana"}]], "plus_fail_tests": []}], "EvoEval/42": [{"task_id": "EvoEval/42", "solution": "\ndef check_expression(expression: str):\n    if not expression.startswith('<') or not expression.endswith('>'):\n        return False\n    expression = expression[1:-1]\n    fractions = expression.split(',')\n    product = 1\n    for fraction in fractions:\n        (numerator, denominator) = map(int, fraction.split('/'))\n        product *= numerator / denominator\n    return product.is_integer()", "base_status": "fail", "plus_status": null, "base_fail_tests": [["<1/2,2/1><2/3,3/2>"]], "plus_fail_tests": []}], "EvoEval/15": [{"task_id": "EvoEval/15", "solution": "from typing import List\n\ndef balance_triples(operations: List[int]) -> bool:\n    balance = 0\n    sums = set()\n    for operation in operations:\n        balance += operation\n        if balance in sums:\n            return True\n        sums.add(balance)\n    return False", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[4, -4, 5, 2, -3, 1, -2, 3, -5]]], "plus_fail_tests": []}], "EvoEval/37": [{"task_id": "EvoEval/37", "solution": "\nimport math\n\ndef minSubArraySumEvenOdd(nums):\n    min_sum = float('inf')\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            min_sum = min(min_sum, sum(nums[i:j + 1]))\n    even_count = sum((1 for digit in str(min_sum) if int(digit) % 2 == 0))\n    odd_count = sum((1 for digit in str(min_sum) if int(digit) % 2 != 0))\n    return (even_count, odd_count)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[-1, 4, -3, 2, -5, 7, -9, -13]]], "plus_fail_tests": []}], "EvoEval/30": [{"task_id": "EvoEval/30", "solution": "\nfrom typing import List\n\ndef parse_music_simplify(x: str, music_string: str) -> List[bool]:\n    notes = music_string.split()\n    (numerator, denominator) = map(int, x.split('/'))\n    note_to_beats = {'o': 4, 'o|': 2, '.|': 1}\n    return [(numerator * note_to_beats[note] / denominator).is_integer() for note in notes]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/97": [{"task_id": "EvoEval/97", "solution": "\ndef fib_max_triples(n):\n    fib = [0, 0, 1]\n    for i in range(3, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2] + fib[i - 3] + i * i - i + 1)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (fib[i] + fib[j] + fib[k]) % 3 == 0:\n                    count += 1\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [[5]], "plus_fail_tests": []}], "EvoEval/21": [{"task_id": "EvoEval/21", "solution": "\nfrom typing import List\n\ndef base_change_prefixes(x: int, base: int) -> List[str]:\n    x_in_base = convert_base(x, base)\n    prefixes = [x_in_base[:i] for i in range(1, len(x_in_base) + 1)]\n    return prefixes", "base_status": "fail", "plus_status": null, "base_fail_tests": [[7, 2]], "plus_fail_tests": []}], "EvoEval/3": [{"task_id": "EvoEval/3", "solution": "\nfrom typing import List\n\ndef sort_parentheses(lst: List[str]) -> str:\n    num_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    lst.sort(key=lambda x: num_dict[x.strip('()')])\n    stack = []\n    for s in lst:\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack:\n                    return 'No'\n                stack.pop()\n        if stack:\n            return 'No'\n    return 'Yes'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["(five)", "(one", "(two", "four))"]]], "plus_fail_tests": []}], "EvoEval/68": [{"task_id": "EvoEval/68", "solution": "\ndef minOddDigitsProductSubArray(nums):\n    min_product = float('inf')\n    for i in range(len(nums)):\n        product = 1\n        for digit in str(nums[i]):\n            if int(digit) % 2 != 0:\n                product *= int(digit)\n        if product != 1:\n            min_product = min(min_product, product)\n    return min_product if min_product != float('inf') else 0", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[2, 3, 4, 1, 2, 4]]], "plus_fail_tests": []}], "EvoEval/27": [{"task_id": "EvoEval/27", "solution": "\ndef list_prime_exchange(lst1, lst2, x, y):\n    \"\"\"The function takes two lists of numbers lst1 and lst2, and two integers x and y. The task is to \n    determine whether it is possible to perform an exchange of elements between lst1 and lst2 to \n    make lst1 a list of only prime numbers. \n\n    If it is possible, return the value of x. If it is not possible, return the value of y. \n\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n\n    For example:\n    list_prime_exchange([1, 2, 3, 4], [5, 7, 11, 13], 10, 20) => 10\n    list_prime_exchange([1, 2, 3, 4], [6, 8, 10, 12], 30, 40) => 40\n\n    It is assumed that the input lists will be non-empty and the integers x and y will be non-zero.\n    \"\"\"\n    for num in lst1:\n        if not is_prime(num):\n            return y\n    for num in lst2:\n        if is_prime(num):\n            return y\n    return x", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 4], [6, 7, 8, 12], 30, 40]], "plus_fail_tests": []}], "EvoEval/8": [{"task_id": "EvoEval/8", "solution": "\ndef correct_bracket_sequence_and_count(string: str, bracket: str) -> tuple:\n    count = 0\n    stack = []\n    for char in string:\n        if char == bracket:\n            count += 1\n            stack.append(char)\n        elif stack:\n            stack.pop()\n        else:\n            return (False, count)\n    return (not stack, count)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["><<>", ">"]], "plus_fail_tests": []}], "EvoEval/23": [{"task_id": "EvoEval/23", "solution": "\ndef special_stone_factorial(n):\n    result = []\n    for i in range(n, 0, -1):\n        factorial = 1\n        for j in range(i, 0, -1):\n            factorial *= j\n        result.append(factorial)\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[4]], "plus_fail_tests": []}], "EvoEval/99": [{"task_id": "EvoEval/99", "solution": "\ndef len_base_conversion(x: int, base: int) -> int:\n    \"\"\" \n    Convert the numerical base of input number x to base and \n    return the length of string representation after the conversion. \n    base numbers are less than 10.\n    \n    >>> len_base_conversion(8, 3)\n    2\n    >>> len_base_conversion(8, 2)\n    4\n    >>> len_base_conversion(7, 2)\n    3\n    \"\"\"\n    if base == 10:\n        return len(str(x))\n    else:\n        result = ''\n        while x > 0:\n            result = str(x % base) + result\n            x //= base\n        return len(result)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[0, 10]], "plus_fail_tests": []}], "EvoEval/1": [{"task_id": "EvoEval/1", "solution": "def round_and_flip(value: str) -> str:\n    (num_str, str_part) = value.split('.')\n    num_str += '.' + str_part\n    num = round(float(num_str))\n    str_part = str_part.swapcase()\n    return str(int(num)) + ' ' + str_part", "base_status": "fail", "plus_status": null, "base_fail_tests": [["15.3ABC"]], "plus_fail_tests": []}], "EvoEval/11": [{"task_id": "EvoEval/11", "solution": "\ndef planet_vowel_count(planet1, planet2):\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    if planet1 not in planets or planet2 not in planets:\n        return 0\n    start = min(planets.index(planet1), planets.index(planet2))\n    end = max(planets.index(planet1), planets.index(planet2))\n    count = 0\n    for planet in planets[start + 1:end]:\n        for char in planet:\n            if char.lower() in vowels:\n                count += 1\n    return count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/95": [{"task_id": "EvoEval/95", "solution": "\nfrom typing import List\n\ndef filter_sort_strings(strings: List[str], substring: str) -> List[str]:\n    filtered_strings = [s for s in strings if substring in s and len(s) % 2 == 0]\n    sorted_strings = sorted(filtered_strings, key=lambda s: (len(s), s))\n    return sorted_strings", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/6": [{"task_id": "EvoEval/6", "solution": "\ndef pile_median(n):\n    total_stones = sum(range(n, 2 * n))\n    median = total_stones / 2.0\n    return int(median) if n % 2 == 1 else median", "base_status": "fail", "plus_status": null, "base_fail_tests": [[2]], "plus_fail_tests": []}], "EvoEval/43": [{"task_id": "EvoEval/43", "solution": "\ndef sorted_fib4_sequence(n: int):\n    if n == 0:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 2]\n    elif n == 3:\n        return [0, 0, 2]\n    else:\n        fib4 = [0, 0, 2, 0]\n        for i in range(4, n):\n            fib4.append(fib4[i - 1] + fib4[i - 2] + fib4[i - 3] + fib4[i - 4])\n        if (fib4[0] + fib4[-1]) % 2 == 0:\n            fib4.sort(reverse=True)\n        else:\n            fib4.sort()\n        return fib4", "base_status": "fail", "plus_status": null, "base_fail_tests": [[2]], "plus_fail_tests": []}], "EvoEval/39": [{"task_id": "EvoEval/39", "solution": "def smallest_change_and_sum(arr, x, y):\n    n = len(arr)\n    changes = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            changes += 1\n    return changes + x + y", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/56": [{"task_id": "EvoEval/56", "solution": "def product_of_odd_prime_factors(n):\n    i = 2\n    product = 1\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            if i % 2 != 0:\n                product *= i\n    if n > 1 and n % 2 != 0:\n        product *= n\n    return product if product != 1 else 0", "base_status": "fail", "plus_status": null, "base_fail_tests": [[9]], "plus_fail_tests": []}], "EvoEval/93": [{"task_id": "EvoEval/93", "solution": "\ndef prime_vowel(string):\n    vowels = 'aeiouAEIOU'\n    for i in range(len(string) - 2, 0, -1):\n        if string[i] in vowels and string[i - 1] not in vowels and (string[i + 1] not in vowels):\n            return string[i]\n    return '' if is_prime(len(string)) else ''", "base_status": "fail", "plus_status": null, "base_fail_tests": [["ab"]], "plus_fail_tests": []}], "EvoEval/41": [{"task_id": "EvoEval/41", "solution": "\ndef shifted_upper_count(s, shift):\n    if shift > len(s):\n        s = s[::-1]\n    else:\n        s = s[-shift:] + s[:-shift]\n    count = 0\n    for i in range(0, len(s), 2):\n        if s[i].isupper() and s[i] in 'AEIOU':\n            count += 1\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", 25]], "plus_fail_tests": []}], "EvoEval/49": [{"task_id": "EvoEval/49", "solution": "\ndef modp_count(arr, n: int, p: int):\n    power_mod = pow(2, n, p)\n\n    def sum_of_digits(num):\n        return sum((int(digit) for digit in str(abs(num))))\n    count = sum((sum_of_digits(num) > power_mod for num in arr))\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[-1, 11, -11], 4, 5]], "plus_fail_tests": []}], "EvoEval/46": [{"task_id": "EvoEval/46", "solution": "\ndef get_max_even_positive(l: list):\n    even_positives = [num for num in l if num > 0 and num % 2 == 0]\n    if not even_positives:\n        return -1\n    return max(even_positives)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/9": [{"task_id": "EvoEval/9", "solution": "def planet_to_roman_distance(planet1, planet2):\n    planets = {'mercury': 1, 'venus': 2, 'earth': 3, 'mars': 4, 'jupiter': 5, 'saturn': 6, 'uranus': 7, 'neptune': 8}\n    roman_numerals = {1: 'i', 2: 'ii', 3: 'iii', 4: 'iv', 5: 'v', 6: 'vi', 7: 'vii', 8: 'viii'}\n    planet1 = planet1.lower()\n    planet2 = planet2.lower()\n    if planet1 not in planets or planet2 not in planets:\n        return {}\n    planet1_distance = planets[planet1]\n    planet2_distance = planets[planet2]\n    if planet1_distance > planet2_distance:\n        (planet1_distance, planet2_distance) = (planet2_distance, planet1_distance)\n    result = {}\n    for (planet, distance) in planets.items():\n        if planet1_distance < distance < planet2_distance:\n            result[planet] = roman_numerals[distance]\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Uranus", 1]], "plus_fail_tests": []}], "EvoEval/77": [{"task_id": "EvoEval/77", "solution": "\ndef mixed_solution(arr):\n    sum = 0\n    for i in range(0, len(arr), 2):\n        if arr[i] % 2 != 0:\n            digits_sum = sum((int(digit) for digit in str(abs(arr[i]))))\n            if digits_sum > 0:\n                sum += arr[i]\n    return sum", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[-35, 13, 24, 321]]], "plus_fail_tests": []}], "EvoEval/54": [{"task_id": "EvoEval/54", "solution": "\nimport math\n\ndef max_sum_of_prime_subarray(nums):\n    max_sum = 0\n    current_sum = 0\n    for num in nums:\n        if is_prime(num):\n            current_sum += num\n            max_sum = max(max_sum, current_sum)\n        else:\n            current_sum = 0\n    return max_sum", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[2, 3, 5, 7, 11, 13]]], "plus_fail_tests": []}], "EvoEval/7": [{"task_id": "EvoEval/7", "solution": "\ndef sum_square_cube_to_n(n: int):\n    result = 0\n    for i in range(1, n + 1):\n        if i % 3 == 0 and i % 4 != 0:\n            result += i ** 2\n        elif i % 4 == 0:\n            result += i ** 3\n        else:\n            result += i\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[100]], "plus_fail_tests": []}], "EvoEval/73": [{"task_id": "EvoEval/73", "solution": "\nfrom typing import List\nfrom fractions import Fraction\n\ndef filter_and_simplify(fractions: List[str], n: str) -> List[bool]:\n    n = Fraction(n)\n    result = []\n    for fraction in fractions:\n        fraction = Fraction(fraction)\n        product = fraction * n\n        result.append(product.denominator == 1)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/60": [{"task_id": "EvoEval/60", "solution": "\ndef smallest_even_triple(arr, n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    smallest_triple = None\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    if smallest_triple is None or a[i] < smallest_triple[0]:\n                        smallest_triple = [a[i], a[j], a[k]]\n    if smallest_triple is not None:\n        arr.append(smallest_triple[0])\n    even_numbers = [num for num in arr if num % 2 == 0]\n    if even_numbers:\n        return [min(even_numbers), arr.index(min(even_numbers))]\n    else:\n        return []", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[4, 2, 3], 1]], "plus_fail_tests": []}], "EvoEval/87": [{"task_id": "EvoEval/87", "solution": "\ndef match_and_remove_unbalanced(text):\n    stack = []\n    vowels = 'aeiou'\n    result = ''\n    for char in text:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                result += char\n        elif not stack:\n            result += char\n    if stack:\n        result = ''.join([char for char in result if char.lower() not in vowels])\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["ab(cd"]], "plus_fail_tests": []}], "EvoEval/84": [{"task_id": "EvoEval/84", "solution": "\nfrom typing import List, Dict\n\ndef prefixes_histogram(string: str) -> Dict[str, Dict[str, int]]:\n    result = {}\n    for i in range(1, len(string) + 1):\n        prefix = string[:i]\n        histogram = {}\n        max_count = 0\n        for char in prefix:\n            histogram[char] = histogram.get(char, 0) + 1\n            max_count = max(max_count, histogram[char])\n        result[prefix] = {char: count for (char, count) in histogram.items() if count == max_count}\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/5": [{"task_id": "EvoEval/5", "solution": "\nfrom typing import List\n\ndef sort_and_check(numbers: List[float], threshold: float) -> List[float]:\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                first_and_last_sum = round(numbers[0] + numbers[-1])\n                if first_and_last_sum % 2 == 0:\n                    numbers.sort(reverse=True)\n                else:\n                    numbers.sort()\n                return numbers\n    return numbers", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/28": [{"task_id": "EvoEval/28", "solution": "\ndef grade_with_same_chars(grades: list, s0: str, s1: str):\n    grading_system = {4.0: 'A+', 3.7: 'A', 3.3: 'A-', 3.0: 'B+', 2.7: 'B', 2.3: 'B-', 2.0: 'C+', 1.7: 'C', 1.3: 'C-', 1.0: 'D+', 0.7: 'D', 0.0: 'D-', 0.0: 'E'}\n    if set(s0) != set(s1):\n        return []\n    assigned_grades = []\n    for gpa in grades:\n        for (grade_gpa, grade) in grading_system.items():\n            if gpa >= grade_gpa:\n                assigned_grades.append(grade)\n                break\n    return assigned_grades", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[4.0, 3, 1.7, 2, 3.5], "aaabcd", "dddcba"]], "plus_fail_tests": []}], "EvoEval/51": [{"task_id": "EvoEval/51", "solution": "\ndef modify_and_compare(a, b):\n    if isinstance(a, str):\n        if any((c.isalpha() for c in a)):\n            a = a.swapcase()\n        else:\n            a = a[::-1]\n    if isinstance(b, str):\n        if any((c.isalpha() for c in b)):\n            b = b.swapcase()\n        else:\n            b = b[::-1]\n    try:\n        a = float(a.replace(',', '.'))\n        b = float(b.replace(',', '.'))\n    except ValueError:\n        pass\n    if a > b:\n        return a\n    elif a < b:\n        return b\n    else:\n        return None", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1, "1"]], "plus_fail_tests": []}], "EvoEval/69": [{"task_id": "EvoEval/69", "solution": "def sorted_happy_strings(lst):\n\n    def is_happy(s):\n        return len(s) >= 3 and all((len(set(s[i:i + 3])) == 3 for i in range(len(s) - 2)))\n    happy_strings = [s for s in lst if is_happy(s)]\n    happy_strings.sort(key=lambda s: (len(s), s))\n    return happy_strings", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["abcd", "aaa", "abc", "abccba", "cd"]]], "plus_fail_tests": []}], "EvoEval/66": [{"task_id": "EvoEval/66", "solution": "\ndef find_max_triple_sum(x, y, n):\n    max_even = -1\n    for i in range(y, x - 1, -1):\n        if i % 2 == 0:\n            max_even = i\n            break\n    if max_even == -1:\n        return -1\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    a.sort(reverse=True)\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    return a[i] + a[j] + a[k] + max_even\n    return -1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[10, 15, 20]], "plus_fail_tests": []}], "EvoEval/36": [{"task_id": "EvoEval/36", "solution": "\ndef mod_shift_sort(arr, n, p):\n    if not arr:\n        return True\n    max_val = max(arr)\n    min_val = min(arr)\n    shift_limit = pow(2, n, p)\n    shift_count = 0\n    for i in range(len(arr)):\n        if arr[i] == max_val:\n            shift_count = i\n            break\n    for i in range(len(arr) - 1):\n        if arr[(i + shift_count) % len(arr)] > arr[(i + shift_count + 1) % len(arr)]:\n            return False\n    return shift_count <= shift_limit", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 4, 5], 0, 101]], "plus_fail_tests": []}], "EvoEval/79": [{"task_id": "EvoEval/79", "solution": "\ndef happy_case_string(s):\n    if len(s) < 3:\n        return s[::-1]\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            return s[::-1]\n    for i in range(len(s)):\n        if s[i].isalpha():\n            if s[i].isupper():\n                s = s[:i] + s[i].lower() + s[i + 1:]\n            else:\n                s = s[:i] + s[i].upper() + s[i + 1:]\n    return s", "base_status": "fail", "plus_status": null, "base_fail_tests": [["*#@"]], "plus_fail_tests": []}], "EvoEval/17": [{"task_id": "EvoEval/17", "solution": "\ndef fibfib_search(n: int, lst: list) -> int:\n    fibfib = [0, 0, 1]\n    for i in range(3, n + 1):\n        fibfib.append(fibfib[i - 1] + fibfib[i - 2] + fibfib[i - 3])\n    freq = {}\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    for num in sorted(freq.keys(), reverse=True):\n        if freq[num] >= fibfib[n]:\n            return num\n    return -1", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/86": [{"task_id": "EvoEval/86", "solution": "\ndef evaluate_common_expressions(operators, operand_lists):\n    common_operands = set(operand_lists[0])\n    for operand_list in operand_lists[1:]:\n        common_operands &= set(operand_list)\n    if not common_operands:\n        return None\n    common_operands = sorted(list(common_operands))\n    result = common_operands[0]\n    for (i, operator) in enumerate(operators):\n        if operator == '+':\n            result += common_operands[i + 1]\n        elif operator == '-':\n            result -= common_operands[i + 1]\n        elif operator == '*':\n            result *= common_operands[i + 1]\n        elif operator == '//':\n            result //= common_operands[i + 1]\n        elif operator == '**':\n            result **= common_operands[i + 1]\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["+", "*", "-"], [[2, 3, 4, 5], [3, 5, 7, 8], [3, 4, 5, 9]]]], "plus_fail_tests": []}], "EvoEval/72": [{"task_id": "EvoEval/72", "solution": "\nfrom typing import List\nfrom math import factorial\n\ndef special_close_factorials(numbers: List[int], threshold: int) -> bool:\n    \"\"\" \n    Check if in given list of numbers, are any two special factorials closer to each other than \n    given threshold. The special factorial (Brazilian factorial) is defined as n! * (n!-1! * (n!-2! * ... * 1! \n    where n > 0.\n\n    For example:\n    >>> special_close_factorials([2, 3], 10)\n    False\n    >>> special_close_factorials([1, 2, 3, 4], 100)\n    True\n    \"\"\"\n    special_factorials = [factorial(n) * factorial(n - 1) * factorial(n - 2) for n in numbers]\n    for i in range(len(special_factorials)):\n        for j in range(i + 1, len(special_factorials)):\n            if abs(special_factorials[i] - special_factorials[j]) < threshold:\n                return True\n    return False", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 4], 100]], "plus_fail_tests": []}], "EvoEval/4": [{"task_id": "EvoEval/4", "solution": "\ndef largest_prime_divisor_digit_sum(lst: list) -> int:\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def largest_prime_divisor(n):\n        for i in range(n - 1, 0, -1):\n            if n % i == 0 and is_prime(i):\n                return i\n        return n\n\n    def digit_sum(n):\n        return sum((int(digit) for digit in str(n)))\n    return max((digit_sum(largest_prime_divisor(n)) for n in lst))", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[84, 91, 97, 101, 105]]], "plus_fail_tests": []}], "EvoEval/48": [{"task_id": "EvoEval/48", "solution": "\nfrom typing import List\n\ndef prime_prefixed_strings(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Function that takes a list of strings and a prefix, it should return a list of \n    strings from the input list which start with the given prefix and their lengths are prime numbers.\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix) and is_prime(len(s))]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["apple", "avocado", "banana", "apricot"], "a"]], "plus_fail_tests": []}], "EvoEval/45": [{"task_id": "EvoEval/45", "solution": "\nfrom typing import List, Tuple\n\ndef primes_sum_product(numbers: List[int]) -> Tuple[int, int]:\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [n for n in numbers if is_prime(n)]\n    return (sum(primes), eval('*'.join((str(p) for p in primes))) if primes else 1)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/18": [{"task_id": "EvoEval/18", "solution": "\ndef min_triplets_sum(nums: list):\n    if len(nums) < 3:\n        return 0\n    min_sum = float('inf')\n    for i in range(len(nums) - 2):\n        curr_sum = sum(nums[i:i + 3])\n        min_sum = min(min_sum, curr_sum)\n    return min_sum", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/53": [{"task_id": "EvoEval/53", "solution": "\ndef hex_grade_calculator(grades):\n    prime_grades = ['D', 'B', '7', '5', '3']\n    grade_ranges = [(4.0, 'F'), (3.7, 'E'), (3.3, 'D'), (3.0, 'C'), (2.7, 'B'), (2.3, 'A'), (2.0, '9'), (1.7, '8'), (1.3, '7'), (1.0, '6'), (0.7, '5'), (0.0, '4'), (0.0, '3')]\n    prime_grade_count = 0\n    for grade in grades:\n        for i in range(len(grade_ranges)):\n            if grade >= grade_ranges[i][0]:\n                if grade_ranges[i][1] in prime_grades:\n                    prime_grade_count += 1\n                break\n    return prime_grade_count", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[4.0, 3, 2.75, 1.9, 3.5]]], "plus_fail_tests": []}], "EvoEval/12": [{"task_id": "EvoEval/12", "solution": "\ndef grade_students(student_info, n):\n\n    def count_consonants(name):\n        return sum((1 for c in name if c.lower() in 'bcdfghjklmnpqrstvwxyz'))\n\n    def get_grade(gpa):\n        if gpa == 4.0:\n            return 'A+'\n        elif gpa > 3.7:\n            return 'A'\n        elif gpa > 3.3:\n            return 'A-'\n        elif gpa > 3.0:\n            return 'B+'\n        elif gpa > 2.7:\n            return 'B'\n        elif gpa > 2.3:\n            return 'B-'\n        elif gpa > 2.0:\n            return 'C+'\n        elif gpa > 1.7:\n            return 'C'\n        elif gpa > 1.3:\n            return 'C-'\n        elif gpa > 1.0:\n            return 'D+'\n        elif gpa > 0.7:\n            return 'D'\n        elif gpa > 0.0:\n            return 'D-'\n        else:\n            return 'E'\n    result = []\n    for student in student_info:\n        if count_consonants(student['name']) == n:\n            student['GPA'] += 0.3\n            if student['GPA'] > 4.0:\n                student['GPA'] = 4.0\n            student['grade'] = get_grade(student['GPA'])\n        else:\n            student['grade'] = get_grade(student['GPA'])\n        result.append({'name': student['name'], 'grade': student['grade']})\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[{"name": "Zoe", "GPA": 4.0}, {"name": "Yves", "GPA": 3.7}, {"name": "Xander", "GPA": 3.3}, {"name": "William", "GPA": 3.0}, {"name": "Violet", "GPA": 2.7}, {"name": "Ursula", "GPA": 2.3}, {"name": "Trevor", "GPA": 2.0}, {"name": "Samantha", "GPA": 1.7}, {"name": "Roger", "GPA": 1.3}, {"name": "Quincy", "GPA": 1.0}, {"name": "Pippa", "GPA": 0.7}, {"name": "Oliver", "GPA": 0.0}], 3]], "plus_fail_tests": []}], "EvoEval/80": [{"task_id": "EvoEval/80", "solution": "def cyclic_encode_delete(s: str, c: str) -> tuple:\n\n    def encode(s: str) -> str:\n        return s[2:] + s[:2]\n\n    def decode(s: str) -> str:\n        return s[-2:] + s[:-2]\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    encoded = ''.join((encode(s[i:i + 3]) for i in range(0, len(s), 3)))\n    result = ''.join((ch for ch in encoded if ch not in c))\n    if is_palindrome(result):\n        return (result, True)\n    else:\n        return (''.join((decode(result[i:i + 3]) for i in range(0, len(result), 3))), False)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["abceedcba", "ab"]], "plus_fail_tests": []}], "EvoEval/0": [{"task_id": "EvoEval/0", "solution": "def compare_happiness(a, b):\n\n    def is_happy(s):\n        if len(s) < 3:\n            return False\n        s = s.replace(',', '.')\n        for i in range(len(s) - 2):\n            if s[i] != s[i + 1] and s[i] != s[i + 2] and (s[i + 1] != s[i + 2]):\n                return True\n        return False\n    a_happy = is_happy(a)\n    b_happy = is_happy(b)\n    if not a_happy and (not b_happy):\n        return None\n    elif a_happy and (not b_happy):\n        return a\n    elif not a_happy and b_happy:\n        return b\n    else:\n        a = float(a.replace(',', '.'))\n        b = float(b.replace(',', '.'))\n        if a > b:\n            return a\n        elif a < b:\n            return b\n        else:\n            return None", "base_status": "fail", "plus_status": null, "base_fail_tests": [["1,112", "3,344"]], "plus_fail_tests": []}], "EvoEval/58": [{"task_id": "EvoEval/58", "solution": "def max_freq_and_sum_check(lst, a, b):\n    from collections import Counter\n    freq_dict = Counter(lst)\n    max_freq = -1\n    for (num, freq) in freq_dict.items():\n        if freq >= num and num > max_freq:\n            max_freq = num\n    if max_freq == -1:\n        return (-1, False)\n    else:\n        return (max_freq, max_freq + a == b or max_freq + b == a)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/64": [{"task_id": "EvoEval/64", "solution": "\ndef modp_prime_numbers(n: int, p: int):\n    modulo_result = pow(2, n, p)\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    prime_numbers = [i for i in range(modulo_result) if is_prime(i)]\n    return prime_numbers", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/65": [{"task_id": "EvoEval/65", "solution": "\ndef modp_largest_divisor(n: int, p: int) -> int:\n    \"\"\"Return the largest number smaller than 'p' which divides (2^n modulo p) evenly. \n    If no such number exists, return 1.\n    \n    >>> modp_largest_divisor(3, 5)\n    3\n    >>> modp_largest_divisor(1101, 101)\n    2\n    >>> modp_largest_divisor(0, 101)\n    1\n    >>> modp_largest_divisor(3, 11)\n    8\n    \"\"\"\n    mod = pow(2, n, p)\n    if mod == 0:\n        return p\n    for i in range(p - 1, 0, -1):\n        if mod % i == 0:\n            return i\n    return 1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[10, 2]], "plus_fail_tests": []}], "EvoEval/25": [{"task_id": "EvoEval/25", "solution": "\nfrom typing import List, Tuple\n\ndef sum_product_triples(n: int) -> Tuple[int, int]:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    sum_of_first_elements = 0\n    product_of_first_elements = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    sum_of_first_elements += a[i]\n                    product_of_first_elements *= a[i]\n    return (sum_of_first_elements, product_of_first_elements)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/29": [{"task_id": "EvoEval/29", "solution": "def largest_prime_factor_or_value(n, x, y):\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    if n == 1:\n        return y\n    elif is_prime(n):\n        return x\n    else:\n        for i in range(2, n):\n            if n % i == 0 and is_prime(n // i):\n                return n // i\n        return x", "base_status": "fail", "plus_status": null, "base_fail_tests": [[7420738134810, 1600, 500]], "plus_fail_tests": []}]}}