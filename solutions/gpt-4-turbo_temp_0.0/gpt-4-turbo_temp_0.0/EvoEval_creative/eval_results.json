{"eval": {"EvoEval/31": [{"task_id": "EvoEval/31", "solution": "def unique_paths(m: int, n: int) -> int:\n    \"\"\"\n    A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n    The robot can only move either down or right at any point in time. \n    The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n    How many possible unique paths are there from start to finish?\n    >>> unique_paths(3, 2)\n    3\n    >>> unique_paths(7, 3)\n    28\n    >>> unique_paths(3, 3)\n    6\n\n    :param m: the number of rows in the grid\n    :param n: the number of columns in the grid\n    :return: the number of possible unique paths from start to finish\n    \"\"\"\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[-1][-1]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/76": [{"task_id": "EvoEval/76", "solution": "def create_pyramid(lst):\n    pyramid = []\n    for num in reversed(lst):\n        level = '#' * num\n        pyramid.append(level)\n    return pyramid[::-1]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 2, 1]]], "plus_fail_tests": []}], "EvoEval/65": [{"task_id": "EvoEval/65", "solution": "def food_order(menu, order):\n    if not order:\n        return menu\n    final_order = {}\n    for (food_item, customization) in order.items():\n        ingredients = list(menu[food_item])\n        if 'remove' in customization:\n            for ingredient in customization['remove']:\n                ingredients.remove(ingredient)\n        if 'add' in customization:\n            for ingredient in customization['add']:\n                ingredients.append(ingredient)\n        final_order[food_item] = ingredients\n    return final_order", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"Burger": ["Bun", "Meat", "Cheese"], "Pizza": ["Dough", "Tomato Sauce", "Cheese"], "Pasta": ["Pasta", "Tomato Sauce", "Cheese"]}, {"Burger": {"remove": ["Cheese"], "add": ["Mushrooms"]}}]], "plus_fail_tests": []}], "EvoEval/91": [{"task_id": "EvoEval/91", "solution": "def spaceship_trajectory(spaceship_data):\n    \"\"\"Create a function which takes a list of tuples representing a spaceship's flight data,\n    and returns a string indicating the spaceship's final status.\n    Each tuple in the list represents a single action, where:\n    - The first element is a string indicating the action ('Launch', 'Move', 'Land')\n    - The second element is an integer indicating the distance moved in that action \n    (negative for backwards, positive for forwards)\n    The spaceship's status is determined by the following rules:\n    - Initially, the spaceship is 'On Ground'\n    - 'Launch' action can only be performed when the spaceship is 'On Ground' and will change the status to 'In Space'\n    - 'Move' action can only be performed when the spaceship is 'In Space' and will not change the status\n    - 'Land' action can only be performed when the spaceship is 'In Space', it will change the status back to 'On Ground'\n    - If any action is invalid according to these rules, return 'Invalid Action Sequence'. Otherwise, return the final status.\n    Examples:\n    spaceship_trajectory([('Launch', 1), ('Move', 2), ('Land', -1)]) # => 'On Ground'\n    spaceship_trajectory([('Launch', 1), ('Move', 2), ('Land', -1), ('Move', 3)]) # => 'Invalid Action Sequence'\n    \"\"\"\n    status = 'On Ground'\n    for (action, distance) in spaceship_data:\n        if action == 'Launch':\n            if status != 'On Ground':\n                return 'Invalid Action Sequence'\n            status = 'In Space'\n        elif action == 'Move':\n            if status != 'In Space':\n                return 'Invalid Action Sequence'\n        elif action == 'Land':\n            if status != 'In Space':\n                return 'Invalid Action Sequence'\n            status = 'On Ground'\n        else:\n            return 'Invalid Action Sequence'\n    return status", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/57": [{"task_id": "EvoEval/57", "solution": "def magical_cafe(menu, magic_spell):\n    \"\"\"\n    Transforms each dish name in the menu using the provided magic spell.\n    \"\"\"\n    transformed_menu = {}\n    for (dish, price) in menu.items():\n        transformed_dish = ''\n        for i in range(len(dish)):\n            transformed_dish += magic_spell[i % len(magic_spell)]\n        transformed_menu[transformed_dish] = price\n    return transformed_menu", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/32": [{"task_id": "EvoEval/32", "solution": "def playlist_shuffle(playlist: list, seed: int):\n    \"\"\"Return a new playlist order based on a numerical seed.\n\n    Given a list of song titles (strings) as 'playlist' and an odd integer 'seed',\n    implement an algorithm to shuffle the playlist to create a new order.\n    The same seed should always produce the same shuffled playlist.\n\n    The shuffling algorithm should use the seed to produce a series of swaps in the sorted list.\n    To produce the series, start at index 0 and swap with the element\n    at the index `seed % playlist_length`. It's important to note that if a song title contains the word \"Rock\", it should remain unmoved during the swapping process (the swap operation will be skipped). For the next index, update the\n    seed using the formula: seed = (seed * 16807) % 2147483647. Continue this process\n    from the next index until the end of the list. Note that the seed will be updated for every index (swapped or not).\n    \"\"\"\n    playlist_length = len(playlist)\n    for i in range(playlist_length):\n        swap_index = seed % playlist_length\n        seed = seed * 16807 % 2147483647\n        if 'Rock' in playlist[i] or 'Rock' in playlist[swap_index]:\n            continue\n        (playlist[i], playlist[swap_index]) = (playlist[swap_index], playlist[i])\n    return playlist", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/16": [{"task_id": "EvoEval/16", "solution": "def fibonacci_sum(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    fib_n_minus_2 = 0\n    fib_n_minus_1 = 1\n    sum_fib = 1\n    for _ in range(2, n):\n        fib_n = fib_n_minus_1 + fib_n_minus_2\n        sum_fib += fib_n\n        fib_n_minus_2 = fib_n_minus_1\n        fib_n_minus_1 = fib_n\n    return sum_fib", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/94": [{"task_id": "EvoEval/94", "solution": "def spell_casting(spells):\n    \"\"\"\n    Sorts the words in each spell based on their length, maintaining the original order for words of the same length.\n    \"\"\"\n    sorted_spells = []\n    for spell in spells:\n        words = spell.split()\n        sorted_words = sorted(words, key=len)\n        sorted_spell = ' '.join(sorted_words)\n        sorted_spells.append(sorted_spell)\n    return sorted_spells", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/89": [{"task_id": "EvoEval/89", "solution": "def space_invaders(aliens, ray):\n    remaining_aliens = []\n    for position in aliens:\n        if position == ray or position == ray - 1 or position == ray + 1:\n            continue\n        else:\n            remaining_aliens.append(position)\n    return remaining_aliens", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 4, 5, 6], 4]], "plus_fail_tests": []}], "EvoEval/47": [{"task_id": "EvoEval/47", "solution": "def recipe_ingredients(recipe, available):\n    \"\"\"Checks if a particular recipe can be cooked with the available ingredients.\n\n    Args:\n        recipe (dict): A dictionary where the keys are the ingredient names and the values are the quantities.\n        available (dict): A dictionary where the keys are the ingredient names and the values are the quantities.\n\n    Returns:\n        bool: True if all ingredients needed for the recipe are available, False otherwise.\n\n    Examples:\n        assert recipe_ingredients({'flour': 200, 'sugar': 100, 'eggs': 2}, {'flour': 500, 'sugar': 100, 'eggs': 2}) == True\n        assert recipe_ingredients({'flour': 200, 'sugar': 100, 'eggs': 2}, {'flour': 100, 'sugar': 50, 'eggs': 1}) == False\n        assert recipe_ingredients({'flour': 200, 'sugar': 100, 'milk': 100}, {'flour': 500, 'sugar': 100, 'eggs': 2}) == False\n        assert recipe_ingredients({}, {'flour': 500, 'sugar': 100, 'eggs': 2}) == True\n    \"\"\"\n    for (ingredient, quantity) in recipe.items():\n        if ingredient not in available or available[ingredient] < quantity:\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/44": [{"task_id": "EvoEval/44", "solution": "def fairy_tale_transport(q, w, e):\n    total_weight = sum(q)\n    combined_capacity = w + e\n    if combined_capacity >= total_weight:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/78": [{"task_id": "EvoEval/78", "solution": "def find_pattern(mat):\n    n = len(mat)\n    pattern = []\n    for i in range(n):\n        pattern.append(mat[i][i])\n    for i in range(n):\n        if i != n // 2:\n            pattern.append(mat[i][n - 1 - i])\n    return pattern", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9]]]], "plus_fail_tests": []}], "EvoEval/62": [{"task_id": "EvoEval/62", "solution": "def recipe_converter(recipe, conversion_factor):\n    converted_recipe = {}\n    for (ingredient, quantity) in recipe.items():\n        converted_recipe[ingredient] = quantity * conversion_factor\n    return converted_recipe", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/74": [{"task_id": "EvoEval/74", "solution": "def cipher_mapping(s, cipher):\n    \"\"\"Given a string 's' and a mapping dictionary 'cipher', your task is to implement \n    a function that returns a new string where each character in 's' has been replaced \n    by its corresponding value in 'cipher'. \n    If a character in 's' does not exist in 'cipher', leave it as it is in the new string.\n    If 's' is an empty string, the function should return an empty string.\n    \n    Examples:\n    cipher_mapping(\"hello world\", {'h':'y', 'e':'u', 'l':'q', 'o':'p', 'w':'j', 'r':'f', 'd':'m'}) \n    ==> 'yuqqp jpfqm'\n    \n    cipher_mapping(\"apple pie\", {'a':'z', 'p':'r', 'l':'m', 'e':'s', 'i':'u'}) \n    ==> 'zrrms rus'\n    \n    cipher_mapping(\"simple test\", {}) \n    ==> 'simple test'\n    \n    cipher_mapping(\"good day\", {'g':'b', 'o':'a', 'd':'t', 'a':'g', 'y':'h'}) \n    ==> 'baat tgh'\n    \"\"\"\n    result = ''\n    for char in s:\n        if char in cipher:\n            result += cipher[char]\n        else:\n            result += char\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/2": [{"task_id": "EvoEval/2", "solution": "from typing import List, Union\n\ndef encrypt_message(words: List[str], key: Union[str, int]) -> List[Union[str, int]]:\n    \"\"\"\n    Given a list of words, first turn words into lowercase and then encrypt each word using a simple Caesar cipher. \n    The key for the cipher is either a string or an integer.\n    If the key is a string, convert it to an integer by summing the ASCII values \n    of its characters. If the key is an integer, use it as-is.\n\n    The Caesar cipher works by shifting each letter in the word by the \n    value of the key. If the letter after shifting exceeds 'z', it wraps \n    around to the start of the alphabet.\n\n    If the word contains any non-alphabetical characters, leave them as-is.\n    \"\"\"\n    if isinstance(key, str):\n        key = sum((ord(char) for char in key))\n    encrypted_words = []\n    for word in words:\n        encrypted_word = ''\n        for char in word.lower():\n            if char.isalpha():\n                shifted_char = chr((ord(char) - 97 + key) % 26 + 97)\n                encrypted_word += shifted_char\n            else:\n                encrypted_word += char\n        encrypted_words.append(encrypted_word)\n    return encrypted_words", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["ant", "bat", "cat", "dog", "elephant"], -1]], "plus_fail_tests": []}], "EvoEval/71": [{"task_id": "EvoEval/71", "solution": "def letter_shift_cipher(s, n):\n    result = ''\n    vowels = 'aeiouAEIOU'\n    vowel_count = 0\n    for char in s:\n        if char.isalpha():\n            shift = ord(char) + n\n            if char.islower():\n                if shift > ord('z'):\n                    shift -= 26\n                elif shift < ord('a'):\n                    shift += 26\n            elif char.isupper():\n                if shift > ord('Z'):\n                    shift -= 26\n                elif shift < ord('A'):\n                    shift += 26\n            result_char = chr(shift)\n            result += result_char\n            if result_char.lower() in vowels:\n                vowel_count += 1\n        else:\n            result += char\n    return (result, vowel_count)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Special Chars: \u00e4\u00eb\u00ef\u00f6\u00fc", 4]], "plus_fail_tests": []}], "EvoEval/14": [{"task_id": "EvoEval/14", "solution": "def create_alias(name: str) -> str:\n    \"\"\" For a given name, create an alias following these rules:\n        If the name includes a vowel, replace it with the next vowel in the cycle a->e->i->o->u->a. \n        If the name includes a consonant, replace it with the next consonant in alphabetical order, once 'z' is reached, loop back to 'b'.\n        The alias should maintain the original names case (upper or lower)\n        Ignore any non-alphabetical characters.\n\n    >>> create_alias('John Doe')\n    'Kujp Fui'\n    \"\"\"\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    alias = ''\n    for char in name:\n        if char.lower() in vowels:\n            next_vowel = vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n            alias += next_vowel.upper() if char.isupper() else next_vowel\n        elif char.lower() in consonants:\n            next_consonant = consonants[(consonants.index(char.lower()) + 1) % len(consonants)]\n            alias += next_consonant.upper() if char.isupper() else next_consonant\n        else:\n            alias += char\n    return alias", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/40": [{"task_id": "EvoEval/40", "solution": "def potion_mixing(potions, target):\n    potions_with_power = [(potion, int(potion.split()[-1])) for potion in potions]\n    potions_with_power.sort(key=lambda x: x[0])\n\n    def find_combinations(index, current_sum, current_combination):\n        if current_sum == target:\n            return [current_combination]\n        if current_sum > target or index == len(potions_with_power):\n            return None\n        combinations = []\n        include_current = find_combinations(index + 1, current_sum + potions_with_power[index][1], current_combination + [potions_with_power[index][0]])\n        if include_current:\n            combinations.extend(include_current)\n        exclude_current = find_combinations(index + 1, current_sum, current_combination)\n        if exclude_current:\n            combinations.extend(exclude_current)\n        return combinations\n    all_combinations = find_combinations(0, 0, [])\n    if not all_combinations:\n        return []\n    best_combination = min(all_combinations, key=lambda x: (len(x), x))\n    return best_combination", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/75": [{"task_id": "EvoEval/75", "solution": "def magical_string_transformer(input_str):\n    vowels = 'aeiou'\n    consonants = ''.join([chr(i) for i in range(97, 123) if chr(i) not in vowels])\n    transformed_str = ''\n    for (i, char) in enumerate(input_str):\n        if char.lower() in vowels:\n            new_char = vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n            transformed_str += new_char.upper() if char.isupper() else new_char\n        elif char.lower() in consonants:\n            new_char = consonants[(consonants.index(char.lower()) + 1) % len(consonants)]\n            transformed_str += new_char.upper() if char.isupper() else new_char\n        elif char.isdigit():\n            transformed_str += str((int(char) + 1) % 10)\n        elif char in '?!':\n            if i % 2 == 0:\n                transformed_str += '!' if char == '?' else '?'\n            else:\n                transformed_str += '?' if char == '?' else '!'\n        else:\n            transformed_str += char\n    return transformed_str", "base_status": "fail", "plus_status": null, "base_fail_tests": [["?!AEIOUaeiou"]], "plus_fail_tests": []}], "EvoEval/59": [{"task_id": "EvoEval/59", "solution": "def cooking_challenge(ingredient_dict):\n    if not ingredient_dict:\n        return []\n    ingredient_list = list(ingredient_dict.items())\n    sorted_ingredients = sorted(ingredient_list, key=lambda x: (-x[1], x[0]))\n    return sorted_ingredients", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/88": [{"task_id": "EvoEval/88", "solution": "def planet_population(dict_of_planets):\n    density_dict = {}\n    for (planet, features) in dict_of_planets.items():\n        if features[0] is not None and features[1] is not None:\n            population_density = features[0] / features[1]\n            density_dict[planet] = round(population_density, 2)\n    return density_dict", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/85": [{"task_id": "EvoEval/85", "solution": "def princess_rescue(coord, grid):\n    (rows, cols) = (len(grid), len(grid[0]))\n    (target_row, target_col) = coord\n    if grid[0][0] == 1 or grid[target_row][target_col] == 1:\n        return -1\n    directions = [(0, 1), (1, 0)]\n    queue = deque([(0, 0, 0)])\n    visited = set((0, 0))\n    while queue:\n        (row, col, moves) = queue.popleft()\n        if (row, col) == (target_row, target_col):\n            return moves\n        for (dr, dc) in directions:\n            (next_row, next_col) = (row + dr, col + dc)\n            if 0 <= next_row < rows and 0 <= next_col < cols and (grid[next_row][next_col] == 0) and ((next_row, next_col) not in visited):\n                visited.add((next_row, next_col))\n                queue.append((next_row, next_col, moves + 1))\n    return -1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[2, 2], [[0, 0, 0], [0, 1, 0], [0, 0, 0]]]], "plus_fail_tests": []}], "EvoEval/25": [{"task_id": "EvoEval/25", "solution": "def word_frequency_analysis(text: str, word: str):\n    \"\"\"Return the frequency of the given word in a text. Also, return the sentence in which the word appears the most times.\n\n    The function will return a tuple where the first element is the frequency of the word, and the second element is the sentence with the max frequency of the word. If the word is not found in the text, return (0, \"\"). \n\n    Assume that sentences end with a period.\n\n    >>> word_frequency_analysis(\"Hello world. I love this world.\", \"world\")\n    (2, \"Hello world\")\n\n    >>> word_frequency_analysis(\"This is the best day. I love this day because it's sunny.\", \"day\")\n    (2, \"This is the best day\")\n\n    >>> word_frequency_analysis(\"This is a test. Testing is fun.\", \"test\")\n    (1, \"This is a test\")\n\n    >>> word_frequency_analysis(\"Welcome to the world of coding.\", \"python\")\n    (0, \"\")\n    \"\"\"\n    sentences = text.split('. ')\n    max_freq = 0\n    max_freq_sentence = ''\n    total_freq = 0\n    for sentence in sentences:\n        freq = sentence.lower().split().count(word.lower())\n        total_freq += freq\n        if freq > max_freq:\n            max_freq = freq\n            max_freq_sentence = sentence\n    if total_freq == 0:\n        return (0, '')\n    else:\n        return (total_freq, max_freq_sentence.rstrip('.'))", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Hello world. I love this world.", "world"]], "plus_fail_tests": []}], "EvoEval/96": [{"task_id": "EvoEval/96", "solution": "def get_magic_indices(lst):\n\n    def product_of_digits(n):\n        \"\"\"Returns the product of the digits of a number.\"\"\"\n        n = abs(n)\n        product = 1\n        while n:\n            product *= n % 10\n            n //= 10\n        return product\n    magic_indices = []\n    for (i, value) in enumerate(lst):\n        if i == 0 and value == 0:\n            magic_indices.append(i)\n        elif i != 0 and value % i == 0:\n            if product_of_digits(value) == i:\n                magic_indices.append(i)\n    return magic_indices", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]], "plus_fail_tests": []}], "EvoEval/35": [{"task_id": "EvoEval/35", "solution": "def validate_email_structure(email: str) -> bool:\n    \"\"\"Validate the structure of an email address.\n\n    Args:\n    email (str): The email address to validate.\n\n    Returns:\n    bool: True if the email address has a valid format, False otherwise.\n    \"\"\"\n    if email.count('@') != 1:\n        return False\n    (local_part, domain_part) = email.split('@')\n    if not local_part or not domain_part:\n        return False\n    if '.' not in domain_part:\n        return False\n    if domain_part.startswith('.') or domain_part.endswith('.'):\n        return False\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [["myemail@.com"]], "plus_fail_tests": []}], "EvoEval/50": [{"task_id": "EvoEval/50", "solution": "def text_to_morse(text):\n    \"\"\"Converts text to Morse code.\"\"\"\n    morse_dict = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', ' ': '  '}\n    text = text.upper()\n    morse_code = [morse_dict[char] for char in text if char in morse_dict]\n    morse_code_str = ' '.join(morse_code).replace('   ', '  ')\n    return morse_code_str", "base_status": "fail", "plus_status": null, "base_fail_tests": [[" "]], "plus_fail_tests": []}], "EvoEval/63": [{"task_id": "EvoEval/63", "solution": "def create_pyramid(p):\n    \"\"\"\n    Given a positive integer p, your objective is to construct a pyramid. The base of the pyramid has p blocks. \n    The number of blocks in the next layer depends upon whether the number of blocks in the previous layer is even or odd.\n    The rules are as follows:\n        - If the number of blocks in the previous layer is even, the next layer contains 2 blocks less.\n        - If the number of blocks in the previous layer is odd, the next layer contains 3 blocks less.\n    Before the number of blocks in the next layer is less than or equal to zero, the pyramid is complete. Your function should return \n    a list containing the number of blocks in each layer from bottom to top. The element at index i in the list represents \n    the number of blocks in the (i+1)th layer from the bottom. \n\n    Examples:\n    >>> create_pyramid(10)\n    [10, 8, 6, 4, 2]\n    \n    >>> create_pyramid(9)\n    [9, 6, 4, 2]\n    \"\"\"\n    layers = []\n    while p > 0:\n        layers.append(p)\n        if p % 2 == 0:\n            p -= 2\n        else:\n            p -= 3\n    return layers", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/22": [{"task_id": "EvoEval/22", "solution": "def galactic_travel(t, v):\n    \"\"\"Given the time (t) in years and average velocity (v) in km/s, calculate the distance traveled in light years in a galaxy far, far away.\n    Assume that 1 light year is approximately 9.461 x 10^12 km.\n\n    >>> galactic_travel(1, 300000)\n    0.9999788605855617\n    \"\"\"\n    time_in_seconds = t * 365.25 * 24 * 3600\n    distance_in_km = time_in_seconds * v\n    distance_in_light_years = distance_in_km / (9.461 * 10 ** 12)\n    return distance_in_light_years", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1, 300000]], "plus_fail_tests": []}], "EvoEval/38": [{"task_id": "EvoEval/38", "solution": "def translate_emoticons(sentence):\n    \"\"\"Convert text-based emoticons in a string to their corresponding Unicode emojis and return the result as a string.\n\n    If the sentence doesn't contain any text-based emoticons, return the original sentence.\n    Some examples of text-based emoticons and their corresponding emojis are \":)\" corresponds to \"\ud83d\ude0a\", \n    \":(\" corresponds to \"\u2639\ufe0f\", \":D\" corresponds to \"\ud83d\ude00\", \";)\" corresponds to \"\ud83d\ude09\". \n    \n    Examples:\n    >>> translate_emoticons(\"Hello :) Have a nice day! :D\")\n    \"Hello \ud83d\ude0a Have a nice day! \ud83d\ude00\"\n    >>> translate_emoticons(\"Oh no, it's raining! :(\")\n    \"Oh no, it's raining! \u2639\ufe0f\"\n    >>> translate_emoticons(\"No emoticons here\")\n    \"No emoticons here\"\n    \"\"\"\n    emoticons_to_emojis = {':)': '\ud83d\ude0a', ':(': '\u2639\ufe0f', ':D': '\ud83d\ude00', ';)': '\ud83d\ude09'}\n    for (emoticon, emoji) in emoticons_to_emojis.items():\n        sentence = sentence.replace(emoticon, emoji)\n    return sentence", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/10": [{"task_id": "EvoEval/10", "solution": "from typing import List\n\ndef count_animals(animal_string: str) -> List[int]:\n    \"\"\" \n    Parses the input string and returns a list of integers corresponding to how many times each \n    animal made a sound.\n    \"\"\"\n    animal_sound_pairs = animal_string.split()\n    animal_counts = {'C': 0, 'D': 0, 'B': 0}\n    sound_counts = []\n    total_animals_processed = 0\n    for pair in animal_sound_pairs:\n        if total_animals_processed >= 5:\n            break\n        total_animals_processed += 1\n        if pair[0] in animal_counts and animal_counts[pair[0]] < 2:\n            num_sounds = pair.count('|')\n            sound_counts.append(num_sounds)\n            animal_counts[pair[0]] += 1\n    return sound_counts", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/81": [{"task_id": "EvoEval/81", "solution": "def alien_language(word_list, alien_dictionary):\n    alien_dict_index = {char: index for (index, char) in enumerate(alien_dictionary)}\n\n    def alien_value(word):\n        return [alien_dict_index[char] for char in word]\n    for i in range(len(word_list) - 1):\n        current_word_value = alien_value(word_list[i])\n        next_word_value = alien_value(word_list[i + 1])\n        if next_word_value < current_word_value:\n            return 'INCORRECT'\n    return 'CORRECT'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["cat", "elephant", "dog"], "kjihgfedcba"]], "plus_fail_tests": []}], "EvoEval/24": [{"task_id": "EvoEval/24", "solution": "def alien_language_translator(english_word: str) -> str:\n    \"\"\"\n    Translates an English word into an alien language based on predefined symbol mappings.\n    \"\"\"\n    alien_language_dict = {'a': '+', 'b': '-', 'c': '*', 'd': '/', 'e': '%', 'f': '@', 'g': '!', 'h': '#', 'i': '$', 'j': '^', 'k': '&', 'l': '(', 'm': ')', 'n': '=', 'o': '?', 'p': ':', 'q': ';', 'r': '`', 's': '~', 't': '>', 'u': '<', 'v': '{', 'w': '}', 'x': '[', 'y': ']', 'z': '|'}\n    alien_word = ''.join((alien_language_dict[char] for char in english_word.lower()))\n    return alien_word", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/92": [{"task_id": "EvoEval/92", "solution": "def paint_fountain(n):\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    fountain_layers = []\n    for layer in range(n):\n        letter = alphabet[layer % 26]\n        layer_str = (letter * (layer * 2 + 1)).center(2 * n - 1)\n        layer_str = layer_str[:n - 1] + 'A' + layer_str[n:]\n        fountain_layers.append(layer_str)\n    return '\\n'.join(fountain_layers)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/83": [{"task_id": "EvoEval/83", "solution": "def reverse_vowels(s):\n    vowels = 'aeiouAEIOU'\n    reversed_vowels = [char for char in s if char in vowels][::-1]\n    s_list = list(s)\n    reversed_vowels_index = 0\n    for i in range(len(s_list)):\n        if s_list[i] in vowels:\n            s_list[i] = reversed_vowels[reversed_vowels_index]\n            reversed_vowels_index += 1\n    return ''.join(s_list)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/98": [{"task_id": "EvoEval/98", "solution": "def nature_sequence_generator(n, a, b):\n    sequence = [a, b]\n    next_add = 1\n    while len(sequence) < n:\n        next_element = sequence[-1] + sequence[-2] + next_add\n        sequence.append(next_element)\n        next_add += 1\n    for i in range(len(sequence)):\n        if is_prime(sequence[i]):\n            sequence[i] = 'prime'\n    return sequence", "base_status": "fail", "plus_status": null, "base_fail_tests": [[5, 1, 2]], "plus_fail_tests": []}], "EvoEval/82": [{"task_id": "EvoEval/82", "solution": "def zodiac_element(birthdays):\n    if not birthdays:\n        return None\n    zodiacs = [(('03-21', '04-19'), 'Fire'), (('04-20', '05-20'), 'Earth'), (('05-21', '06-20'), 'Air'), (('06-21', '07-22'), 'Water'), (('07-23', '08-22'), 'Fire'), (('08-23', '09-22'), 'Earth'), (('09-23', '10-22'), 'Air'), (('10-23', '11-21'), 'Water'), (('11-22', '12-21'), 'Fire'), (('12-22', '01-19'), 'Earth'), (('01-20', '02-18'), 'Air'), (('02-19', '03-20'), 'Water')]\n    elements_count = {}\n    for birthday in birthdays:\n        (_, month, day) = birthday.split('-')\n        birthday_md = f'{month}-{day}'\n        for (zodiac_range, element) in zodiacs:\n            (start, end) = zodiac_range\n            if start > end:\n                if birthday_md >= start or birthday_md <= end:\n                    elements_count[element] = elements_count.get(element, 0) + 1\n                    break\n            elif start <= birthday_md <= end:\n                elements_count[element] = elements_count.get(element, 0) + 1\n                break\n    return elements_count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/19": [{"task_id": "EvoEval/19", "solution": "def vampires_in_matrix(m: list):\n    \"\"\"\n    vampires_in_matrix takes a 2D list of integers as an input,\n    where 0 represents an empty cell, 1 represents a human, and 2 represents a vampire.\n    The function will return the number of humans that are in danger of being bitten.\n    A human is considered in danger if they share a row or a column with a vampire.\n    \"\"\"\n    rows = len(m)\n    cols = len(m[0]) if rows > 0 else 0\n    danger_rows = set()\n    danger_cols = set()\n    for i in range(rows):\n        for j in range(cols):\n            if m[i][j] == 2:\n                danger_rows.add(i)\n                danger_cols.add(j)\n    humans_in_danger = 0\n    for i in range(rows):\n        for j in range(cols):\n            if m[i][j] == 1 and (i in danger_rows or j in danger_cols):\n                humans_in_danger += 1\n    return humans_in_danger", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[1], [2, 1], [1, 1]]]], "plus_fail_tests": []}], "EvoEval/13": [{"task_id": "EvoEval/13", "solution": "\nfrom typing import List\n\ndef find_rarest_element(elems: List[str]) -> str:\n    \"\"\" Find the rarest element in a list of strings. If there are multiple rarest elements, return the one that appears first. \n    If the list is empty, return None.\n\n    >>> find_rarest_element(['apple', 'banana', 'apple', 'orange', 'banana', 'orange', 'apple'])\n    'banana'\n    >>> find_rarest_element(['cat', 'dog', 'bird', 'cat', 'dog', 'cat'])\n    'bird'\n    >>> find_rarest_element([])\n    None\n    \"\"\"\n    if not elems:\n        return None\n    element_counts = {}\n    for elem in elems:\n        if elem in element_counts:\n            element_counts[elem] += 1\n        else:\n            element_counts[elem] = 1\n    min_count = min(element_counts.values())\n    for elem in elems:\n        if element_counts[elem] == min_count:\n            return elem", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/26": [{"task_id": "EvoEval/26", "solution": "def pathfinder(maze, start, end):\n    directions = [(-1, 0, 'up'), (1, 0, 'down'), (0, -1, 'left'), (0, 1, 'right')]\n    visited = set()\n    path = []\n    successful_path = []\n\n    def dfs(position):\n        if position == end:\n            successful_path.extend(path)\n            return True\n        visited.add(position)\n        for (d_row, d_col, direction) in directions:\n            new_position = (position[0] + d_row, position[1] + d_col)\n            if 0 <= new_position[0] < len(maze) and 0 <= new_position[1] < len(maze[0]) and (maze[new_position[0]][new_position[1]] == 0):\n                if new_position not in visited:\n                    path.append(direction)\n                    if dfs(new_position):\n                        return True\n                    path.pop()\n        visited.remove(position)\n        return False\n    dfs(start)\n    return successful_path", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/70": [{"task_id": "EvoEval/70", "solution": "def planet_path(planets, path):\n    if not path or path[0] not in planets:\n        return False\n    for i in range(len(path) - 1):\n        if path[i + 1] not in planets[path[i]]:\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/55": [{"task_id": "EvoEval/55", "solution": "def treasure_map(message, shift):\n    encrypted_message = ''\n    for (i, char) in enumerate(message):\n        current_shift = shift + i\n        if char.isupper():\n            encrypted_char = chr((ord(char) - ord('A') + current_shift) % 26 + ord('A'))\n        elif char.islower():\n            encrypted_char = chr((ord(char) - ord('a') + current_shift) % 26 + ord('a'))\n        else:\n            encrypted_char = char\n        encrypted_message += encrypted_char\n    return encrypted_message", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/61": [{"task_id": "EvoEval/61", "solution": "def transform_string(s):\n\n    def swap_case(c):\n        return c.lower() if c.isupper() else c.upper()\n\n    def next_vowel(v):\n        vowels = 'aeiou'\n        return vowels[(vowels.index(v.lower()) + 1) % len(vowels)]\n\n    def preceding_consonant(c):\n        consonants = 'bcdfghjklmnpqrstvwxyz'\n        index = consonants.index(c.lower()) - 1\n        return consonants[index]\n    result = []\n    for (i, char) in enumerate(s):\n        if char.isalpha():\n            if i % 2 == 1:\n                char = swap_case(char)\n            if char.lower() in 'aeiou':\n                char = next_vowel(char)\n                if s[i].isupper():\n                    char = char.upper()\n            else:\n                char = preceding_consonant(char)\n                if s[i].isupper():\n                    char = char.upper()\n        result.append(char)\n    return ''.join(result)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Hello World"]], "plus_fail_tests": []}], "EvoEval/52": [{"task_id": "EvoEval/52", "solution": "def magic_cookie_baker(n, m, orders):\n    fulfillable_orders = 0\n    for order in orders:\n        if order == n:\n            fulfillable_orders += 1\n            if fulfillable_orders == m:\n                break\n    return min(fulfillable_orders, m)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[4, 2, [3, 5, 7, 9, 11]]], "plus_fail_tests": []}], "EvoEval/90": [{"task_id": "EvoEval/90", "solution": "def magical_multiply(s1, s2):\n    \"\"\"\n    In the mystical land of Pyth, numbers behave quite differently. Here, when two numbers are multiplied, the result is given by the sum of all possible unique combinations of their digits. \n\n    For example, if two numbers 24 and 13 are multiplied, the result would be the sum of all unique combinations of digits (2, 4) and (1, 3). The combinations would be (2, 1), (2, 3), (4, 1) and (4, 3) and their sums would be 3, 5, 5 and 7, and hence the result of the multiplication would be 3 + 5 + 5 + 7 = 20.\n\n    The function magical_multiply(s) would take in two positive integers as input (in string format) and should return their product according to the laws of the land of Pyth.\n\n    For example:\n    >>> magical_multiply('24', '13')\n    20\n    >>> magical_multiply('56', '79')\n    54\n    \"\"\"\n    digits1 = [int(digit) for digit in s1]\n    digits2 = [int(digit) for digit in s2]\n    result_sum = 0\n    for digit1 in digits1:\n        for digit2 in digits2:\n            result_sum += digit1 + digit2\n    return result_sum", "base_status": "fail", "plus_status": null, "base_fail_tests": [["999", "999"]], "plus_fail_tests": []}], "EvoEval/67": [{"task_id": "EvoEval/67", "solution": "def meal_calculator(customers, meals):\n    \"\"\"\n    Write a function meal_calculator which takes two arguments; a list of customer's names and a dictionary representing meals consumed by customers where the key is the customer's name and the value is a list of meals. Each meal is a dictionary with a 'dish' and 'calories' key. The function should return a dictionary where each key is a customer's name and the value is the total calories consumed by that customer.\n\n    If a customer's name does not exist in the meals dictionary, assume that the customer consumed 0 calories. The calories value for each meal will always be a positive integer.\n\n    Example:\n    >>> meal_calculator(['Alice', 'Bob', 'Charlie'], \n                        {'Alice': [{'dish':'Pizza', 'calories': 300}, {'dish':'Burger', 'calories': 500}], \n                         'Bob': [{'dish':'Salad', 'calories': 100}], \n                         'Charlie': [{'dish':'Fries', 'calories': 200}, {'dish':'Burger', 'calories': 500}, {'dish':'Ice Cream', 'calories': 250}]})\n    {'Alice': 800, 'Bob': 100, 'Charlie': 950}\n\n    >>> meal_calculator(['Tom', 'Jerry'], \n                        {'Tom': [{'dish':'Pizza', 'calories': 300}, {'dish':'Burger', 'calories': 500}], \n                         'Jerry': [{'dish':'Fries', 'calories': 200}]})\n    {'Tom': 800, 'Jerry': 200}\n    \"\"\"\n    total_calories = {}\n    for customer in customers:\n        if customer in meals:\n            total_calories[customer] = sum((meal['calories'] for meal in meals[customer]))\n        else:\n            total_calories[customer] = 0\n    return total_calories", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/42": [{"task_id": "EvoEval/42", "solution": "def find_legendary_item(player_input):\n    if 5 in player_input:\n        player_input.remove(5)\n        if not player_input:\n            return (True, -1)\n        return (True, max(player_input))\n    return (False, None)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/33": [{"task_id": "EvoEval/33", "solution": "def magical_staircase(n: int, magic_stones: list) -> int:\n    ways = [0] * (n + 1)\n    ways[0] = 1\n    for step in range(1, n + 1):\n        for stone in magic_stones:\n            if step - stone >= 0:\n                ways[step] += ways[step - stone]\n    return ways[n]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/15": [{"task_id": "EvoEval/15", "solution": "def evaluate_poker_hand(hand: list):\n    value_map = {'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13}\n    value_counts = {}\n    for card in hand:\n        value = card[:-1]\n        numerical_value = value_map[value]\n        if numerical_value in value_counts:\n            value_counts[numerical_value] += 1\n        else:\n            value_counts[numerical_value] = 1\n    score = 0\n    for (value, count) in value_counts.items():\n        if count == 2:\n            score += value\n        elif count == 3:\n            score += value * 2\n        elif count == 4:\n            score += value * 3\n        elif count == 5:\n            score += value * 4\n    return score", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/30": [{"task_id": "EvoEval/30", "solution": "from typing import List, Tuple\n\ndef find_path(maze: List[List[int]], start: Tuple[int], end: Tuple[int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    queue = deque([(start, [start])])\n    while queue:\n        ((current, path), queue) = (queue[0], queue[1:])\n        (r, c) = current\n        if current == end:\n            return path\n        visited[r][c] = True\n        for (dr, dc) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (rr, cc) = (r + dr, c + dc)\n            if 0 <= rr < rows and 0 <= cc < cols and (not visited[rr][cc]) and (maze[rr][cc] == 1):\n                queue.append(((rr, cc), path + [(rr, cc)]))\n    return []", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[1, 0, 1, 1, 1], [1, 0, 1, 0, 1], [1, 1, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]], [0, 0], [4, 4]]], "plus_fail_tests": []}], "EvoEval/37": [{"task_id": "EvoEval/37", "solution": "def string_transform(s):\n    \"\"\"Transforms the input string according to specified rules.\"\"\"\n    vowel_map = {'a': 'e', 'e': 'i', 'i': 'o', 'o': 'u', 'u': 'a'}\n    consonant_map = {chr(i): chr((i - 98) % 26 + 97) for i in range(98, 123)}\n    consonant_map['z'] = 'b'\n\n    def transform_char(c):\n        if c.lower() in vowel_map:\n            return vowel_map[c.lower()].upper() if c.isupper() else vowel_map[c.lower()]\n        elif c.lower() in consonant_map:\n            return consonant_map[c.lower()].upper() if c.isupper() else consonant_map[c.lower()]\n        else:\n            return c\n    transformed_string = ''.join((transform_char(c) for c in s))\n    return transformed_string", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Hello, World!"]], "plus_fail_tests": []}], "EvoEval/84": [{"task_id": "EvoEval/84", "solution": "def tree_traversal(tree):\n\n    def traverse(node, path, paths):\n        if not node:\n            return\n        if not node.values():\n            paths.append(path)\n            return\n        for (key, value) in node.items():\n            traverse(value, path + [key], paths)\n    paths = []\n    for (root, children) in tree.items():\n        traverse(children, [root], paths)\n    return paths", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"1": {"2": {"4": {}, "5": {}}, "3": {"6": {}, "7": {}}}}]], "plus_fail_tests": []}], "EvoEval/21": [{"task_id": "EvoEval/21", "solution": "def crossword_validator(grid: list, words: list) -> bool:\n    n = len(grid)\n\n    def word_in_line(word, line):\n        return word in line or word[::-1] in line\n    for word in words:\n        word_found = False\n        for i in range(n):\n            if word_in_line(word, ''.join(grid[i])):\n                word_found = True\n                break\n            column = ''.join([grid[j][i] for j in range(n)])\n            if word_in_line(word, column):\n                word_found = True\n                break\n        if not word_found:\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/97": [{"task_id": "EvoEval/97", "solution": "def alien_invasion(alien, humans):\n    if not isinstance(alien, str) or not isinstance(humans, dict):\n        return []\n    invasion_order = ['Asia', 'Africa', 'Europe', 'North America', 'South America']\n    continent_group = {continent: [] for continent in invasion_order}\n    for (human, continent) in humans.items():\n        if continent in continent_group:\n            continent_group[continent].append(human)\n    sorted_humans = []\n    for continent in invasion_order:\n        sorted_humans.extend(continent_group[continent])\n    return sorted_humans", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/68": [{"task_id": "EvoEval/68", "solution": "def magical_sorting(arr):\n\n    def is_sorted(arr):\n        return all((arr[i] <= arr[i + 1] for i in range(len(arr) - 1)))\n    if is_sorted(arr) or not arr:\n        return True\n    min_index = arr.index(min(arr))\n    arr = arr[min_index:] + arr[:min_index]\n    inversions = sum((1 for i in range(len(arr) - 1) for j in range(i + 1, len(arr)) if arr[i] > arr[j]))\n    if inversions > 1:\n        return False\n    else:\n        return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 10, 2, 3, 4, 5, 6, 7, 8, 9]]], "plus_fail_tests": []}], "EvoEval/3": [{"task_id": "EvoEval/3", "solution": "from typing import List\n\ndef magical_alphabet(input_string: str) -> List[int]:\n\n    def dfs(s: str, path: str, res: List[str]):\n        if not s:\n            res.append(path)\n            return\n        if 0 < int(s[:1]) <= 9:\n            dfs(s[1:], path + chr(int(s[:1]) + 96), res)\n        if 10 <= int(s[:2]) <= 26:\n            dfs(s[2:], path + chr(int(s[:2]) + 96), res)\n    result = []\n    dfs(input_string, '', result)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/46": [{"task_id": "EvoEval/46", "solution": "def hidden_message(test_cases):\n    secret_messages = []\n    for test_case in test_cases:\n        secret_message = ''\n        for word in test_case:\n            first_letter = re.search('[a-zA-Z]', word)\n            if first_letter:\n                secret_message += first_letter.group().lower()\n        original_strings = ' '.join(test_case).lower()\n        if secret_message in original_strings:\n            secret_messages.append('Take the cannoli.')\n        else:\n            secret_messages.append(secret_message)\n    return secret_messages", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[["Hello, world!", "okay?"], ["Every", "good", "boy", "does", "fine"]]]], "plus_fail_tests": []}], "EvoEval/27": [{"task_id": "EvoEval/27", "solution": "def split_strings(s: str, n: int):\n    \"\"\"Return a list of n-character long strings created from the input string s.\n    If the length of s isn't a multiple of n, the remaining characters are added as the \n    last element of the returned list.\n\n    >>> split_strings('HelloWorld', 3)\n    ['Hel', 'loW', 'orl', 'd']\n    >>> split_strings('CodingIsFun', 5)\n    ['Codin', 'gIsFu', 'n']\n    \"\"\"\n    result = []\n    for i in range(0, len(s), n):\n        result.append(s[i:i + n])\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/8": [{"task_id": "EvoEval/8", "solution": "def transform_canvas(canvas: str) -> str:\n    if canvas.count('P') != 1:\n        return 'Invalid canvas'\n    painted_canvas = list(canvas)\n    painter_index = canvas.find('P')\n    empty_spaces = canvas.count('-')\n    for i in range(painter_index - 1, -1, -1):\n        if painted_canvas[i] == '-':\n            painted_canvas[i] = '*'\n        else:\n            break\n    for i in range(painter_index + 1, len(painted_canvas)):\n        if painted_canvas[i] == '-':\n            painted_canvas[i] = '*'\n        else:\n            break\n    painted_spaces = painted_canvas.count('*')\n    if empty_spaces > 0 and painted_spaces > 0 and (empty_spaces % painted_spaces == 0):\n        return 'Invalid canvas'\n    return ''.join(painted_canvas)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/1": [{"task_id": "EvoEval/1", "solution": "from typing import List, Union\n\ndef calculate_shipping_cost(items: List[Union[str, float]], location: str) -> float:\n    \"\"\"\n    Given a list of items (represented by their weights in kg) and a location,\n    calculate the cost of shipping. Each item has a base shipping cost of $5.0.\n    The location multiplies the total cost by a certain factor:\n    - \"Local\": no additional factor\n    - \"National\": factor of 1.5\n    - \"International\": factor of 2.5\n    - other location: no additional factor\n    If the item's weight is more than 5kg, an additional charge of $10.0 is added.\n    \n    If an item is passed as a string instead of a float, consider its weight as 1kg.\n    \n    Return the total shipping cost rounded to two decimal places.\n    \"\"\"\n    total_cost = 0.0\n    for item in items:\n        weight = 1.0 if isinstance(item, str) else item\n        item_cost = 5.0\n        if weight > 5:\n            item_cost += 10.0\n        total_cost += item_cost\n    if location == 'National':\n        total_cost *= 1.5\n    elif location == 'International':\n        total_cost *= 2.5\n    return round(total_cost, 2)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/23": [{"task_id": "EvoEval/23", "solution": "def prime_cipher(s: str) -> str:\n\n    def generate_primes(n):\n        primes = []\n        num = 2\n        while len(primes) < n:\n            for i in range(2, num):\n                if num % i == 0:\n                    break\n            else:\n                primes.append(num)\n            num += 1\n        return primes\n    letters_to_primes = {chr(97 + i): prime for (i, prime) in enumerate(generate_primes(26))}\n    result = ''\n    for char in s:\n        if char.islower():\n            result += str(letters_to_primes[char])\n        else:\n            result += char\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/11": [{"task_id": "EvoEval/11", "solution": "from typing import List\n\ndef fruity_messages(fruits: List[str], location: str) -> str:\n    \"\"\"\n    Given a list of fruits and a location, return a string message in the following format:\n\n    \"Oh, are those <fruit> from <location>? Marvelous!\"\n\n    If you have two fruits, the message should say:\n\n    \"Oh, are those <fruit1> and <fruit2> from <location>? Marvelous!\"\n\n    If you have more than two fruit, the message should say:\n\n    \"Oh, are those <fruit1>, <fruit2> and <fruit3> from <location>? Marvelous!\"\n\n    The list of fruits will always contain at least one fruit.\n\n    >>> fruity_messages(['apples','bananas'],'Florida')\n    'Oh, are those apples and bananas from Florida? Marvelous!'\n\n    >>> fruity_messages(['cherries'],'Michigan')\n    'Oh, are those cherries from Michigan? Marvelous!'\n    \"\"\"\n    if len(fruits) == 1:\n        return f'Oh, are those {fruits[0]} from {location}? Marvelous!'\n    elif len(fruits) == 2:\n        return f'Oh, are those {fruits[0]} and {fruits[1]} from {location}? Marvelous!'\n    else:\n        fruits_list = ', '.join(fruits[:-1]) + f' and {fruits[-1]}'\n        return f'Oh, are those {fruits_list} from {location}? Marvelous!'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/95": [{"task_id": "EvoEval/95", "solution": "def matrixMystery(m):\n    if len(m) == 0 or len(m) != len(m[0]):\n        return 'Invalid Matrix'\n    sum_diag1 = 0\n    sum_diag2 = 0\n    for i in range(len(m)):\n        sum_diag1 += m[i][i]\n    for i in range(len(m)):\n        sum_diag2 += m[i][len(m) - i - 1]\n    return abs(sum_diag1 - sum_diag2)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/6": [{"task_id": "EvoEval/6", "solution": "from typing import List, Tuple\n\ndef minesweeper_clicked(grid: List[List[int]], position: Tuple[int, int]) -> List[List[int]]:\n    (rows, cols) = (len(grid), len(grid[0]))\n    (x, y) = position\n    if x < 0 or x >= rows or y < 0 or (y >= cols):\n        return grid\n    if grid[x][y] == 1 or grid[x][y] == 0:\n        return grid\n\n    def reveal(x, y):\n        if 0 <= x < rows and 0 <= y < cols and (grid[x][y] == -1):\n            grid[x][y] = 0\n            if not any((grid[i][j] == 1 for i in range(max(0, x - 1), min(x + 2, rows)) for j in range(max(0, y - 1), min(y + 2, cols)))):\n                for i in range(max(0, x - 1), min(x + 2, rows)):\n                    for j in range(max(0, y - 1), min(y + 2, cols)):\n                        reveal(i, j)\n    reveal(x, y)\n    return grid", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[0, 1, -1], [1, -1, 0], [0, 1, 1]], [1, 1]]], "plus_fail_tests": []}], "EvoEval/43": [{"task_id": "EvoEval/43", "solution": "def space_travel(distance, speed, fuel, planet_gravity, spaceship_weight):\n    trip_duration = distance / speed\n    fuel_consumption_per_year = spaceship_weight * planet_gravity * 0.1\n    total_fuel_consumption = fuel_consumption_per_year * trip_duration\n    if fuel < total_fuel_consumption:\n        return 'Insufficient fuel'\n    remaining_fuel = fuel - total_fuel_consumption\n    return round(remaining_fuel, 2)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/29": [{"task_id": "EvoEval/29", "solution": "def find_palindrome_substrings(s: str):\n    \"\"\"\n    Given a string, find all unique substrings that are palindromes.\n    \n    A palindrome is a word, number, phrase, or other sequence of characters that reads the same forward and backward, ignoring spaces, punctuation, and capitalization.\n    \n    Return a list of all unique palindrome substrings, sorted in ascending order.\n    \"\"\"\n\n    def expand_around_center(left: int, right: int):\n        \"\"\"\n        Expand around the center of the palindrome.\n        \"\"\"\n        while left >= 0 and right < len(s) and (s[left] == s[right]):\n            palindrome_substrings.add(s[left:right + 1])\n            left -= 1\n            right += 1\n    palindrome_substrings = set()\n    for i in range(len(s)):\n        expand_around_center(i, i)\n        expand_around_center(i, i + 1)\n    return sorted(list(palindrome_substrings))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/56": [{"task_id": "EvoEval/56", "solution": "def str_to_morse_code(s):\n    morse_code_dict = {'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', 'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', 's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', 'y': '-.--', 'z': '--..'}\n    words = s.split()\n    morse_words = []\n    for word in words:\n        morse_letters = [morse_code_dict[letter] for letter in word]\n        morse_words.append(' '.join(morse_letters))\n    morse_code = ' / '.join(morse_words)\n    return morse_code", "base_status": "fail", "plus_status": null, "base_fail_tests": [["this has multiple   spaces"]], "plus_fail_tests": []}], "EvoEval/39": [{"task_id": "EvoEval/39", "solution": "def asciiArt(n, s):\n    repeated_pattern = ''.join([char * n for char in s])\n    top_and_middle = '\\n'.join(['*' + repeated_pattern + '*' for _ in range(n)])\n    bottom = '*' * (len(repeated_pattern) + 2)\n    ascii_art = top_and_middle + '\\n' + bottom\n    return ascii_art", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/93": [{"task_id": "EvoEval/93", "solution": "def secret_code(message, n_values):\n\n    def shift_char(c, n):\n        if c.isalpha():\n            start = ord('a') if c.islower() else ord('A')\n            return chr((ord(c) - start + n) % 26 + start)\n        else:\n            return c\n    encoded_message = ''\n    n_values_len = len(n_values)\n    for (i, char) in enumerate(message):\n        n = n_values[i % n_values_len]\n        encoded_message += shift_char(char, n)\n    return encoded_message", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/49": [{"task_id": "EvoEval/49", "solution": "def morse_decoder(msg):\n    morse_code_dict = {'01': 'A', '1000': 'B', '1010': 'C', '100': 'D', '0': 'E', '0010': 'F', '110': 'G', '0000': 'H', '00': 'I', '0111': 'J', '101': 'K', '0100': 'L', '11': 'M', '10': 'N', '111': 'O', '0110': 'P', '1101': 'Q', '010': 'R', '000': 'S', '1': 'T', '001': 'U', '0001': 'V', '011': 'W', '1001': 'X', '1011': 'Y', '1100': 'Z', '01111': '1', '00111': '2', '00011': '3', '00001': '4', '00000': '5', '10000': '6', '11000': '7', '11100': '8', '11110': '9', '11111': '0'}\n    words = msg.split('/')\n    decoded_message = []\n    for word in words:\n        decoded_word = []\n        characters = word.strip().split(' ')\n        for char in characters:\n            if char in morse_code_dict:\n                decoded_word.append(morse_code_dict[char])\n        decoded_message.append(''.join(decoded_word))\n    return ' '.join(decoded_message)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["010101/01 1010 0 110 0"]], "plus_fail_tests": []}], "EvoEval/41": [{"task_id": "EvoEval/41", "solution": "def spider_web_jump(arr):\n    (rows, cols) = (len(arr), len(arr[0]))\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    queue = deque([(0, 0, 0)])\n    visited = set((0, 0))\n    while queue:\n        (row, col, energy) = queue.popleft()\n        if arr[row][col] == 0:\n            return energy\n        for (dr, dc) in directions:\n            (new_row, new_col) = (row + dr, col + dc)\n            if 0 <= new_row < rows and 0 <= new_col < cols and ((new_row, new_col) not in visited):\n                visited.add((new_row, new_col))\n                queue.append((new_row, new_col, energy + arr[row][col]))\n    return -1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[2, 3], [1, 0]]]], "plus_fail_tests": []}], "EvoEval/9": [{"task_id": "EvoEval/9", "solution": "\ndef calculate_word_frequency(string: str) -> dict:\n    \"\"\" Given a string, calculate the frequency of each word present in that string (regardless of case) and return a dictionary with words as keys and their frequencies as values. \n    Words are separated by spaces. Ignore punctuation.\n    \"\"\"\n    string = string.lower()\n    punctuation = '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~'\n    string = string.translate(str.maketrans('', '', punctuation))\n    words = string.split()\n    word_frequency = {}\n    for word in words:\n        if word in word_frequency:\n            word_frequency[word] += 1\n        else:\n            word_frequency[word] = 1\n    return word_frequency", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Emojis can also be included in text. \ud83d\ude0a \ud83d\ude0a \ud83d\ude0a"]], "plus_fail_tests": []}], "EvoEval/77": [{"task_id": "EvoEval/77", "solution": "def magical_sequence(sequence, k):\n\n    def calculate_points(number):\n        points = 0\n        while number % k == 0 and number > 1:\n            number //= k\n            points += 1\n        return points\n    points_list = [calculate_points(num) for num in sequence]\n    points_list.sort(reverse=True)\n    return points_list", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/7": [{"task_id": "EvoEval/7", "solution": "def find_shangri_la(code_sequence: list[int]) -> str:\n    \"\"\"\n    You are an explorer trying to find the mythical city of Shangri-La. According to an ancient text,\n    Shangri-La can be found by following a code sequence of numbers, each referring to the direction to move.\n    The directions correspond to 0: North, 1: East, 2: South, 3: West.\n    \n    Implement a function that takes a sequence of numbers as input and returns whether the sequence leads to Shangri-La.\n    Assume starting point is always (0,0). If the sequence leads back to the starting point, it has found Shangri-La and \n    function should return 'Shangri-La found'. Otherwise, return 'Shangri-La not found'.\n    Not moving is considered as not found.\n    \n    Note: Every move is considered as unit = 1.\n    \"\"\"\n    (x, y) = (0, 0)\n    for direction in code_sequence:\n        if direction == 0:\n            y += 1\n        elif direction == 1:\n            x += 1\n        elif direction == 2:\n            y -= 1\n        elif direction == 3:\n            x -= 1\n    if x == 0 and y == 0:\n        return 'Shangri-La found'\n    else:\n        return 'Shangri-La not found'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[]]], "plus_fail_tests": []}], "EvoEval/73": [{"task_id": "EvoEval/73", "solution": "def treasure_hunt(grid, bag_capacity):\n    import math\n    total_treasures = sum((row.count(1) for row in grid))\n    if total_treasures == 0:\n        return 0\n    trips = math.ceil(total_treasures / bag_capacity) * 2\n    return trips", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/60": [{"task_id": "EvoEval/60", "solution": "def happy_ants(path_length, sugar_locations, ant_positions):\n    sugar_set = set(sugar_locations)\n    happy_count = 0\n    for (position, direction) in ant_positions:\n        if direction == 'right':\n            for i in range(position, path_length):\n                if i in sugar_set:\n                    happy_count += 1\n                    break\n        else:\n            for i in range(position, -1, -1):\n                if i in sugar_set:\n                    happy_count += 1\n                    break\n    return happy_count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/64": [{"task_id": "EvoEval/64", "solution": "def magical_sequence(start, end, divisor):\n    \"\"\"This function takes three positive integers: 'start', 'end', and 'divisor'. It returns a list of all \n    the numbers in the range ['start', 'end'] inclusive, that are divisible by 'divisor' and are prime numbers. \n    If no such number exists, the function should return an empty list.\n    \"\"\"\n    result = []\n    for number in range(start, end + 1):\n        if number % divisor == 0 and is_prime(number):\n            result.append(number)\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[10, 20, 2]], "plus_fail_tests": []}], "EvoEval/87": [{"task_id": "EvoEval/87", "solution": "def word_spiral(arr):\n    if not arr or not arr[0]:\n        return ''\n    result = []\n    (top, bottom) = (0, len(arr))\n    (left, right) = (0, len(arr[0]))\n    while top < bottom and left < right:\n        for i in range(left, right):\n            result.append(arr[top][i])\n        top += 1\n        for i in range(top, bottom):\n            result.append(arr[i][right - 1])\n        right -= 1\n        if not (top < bottom and left < right):\n            break\n        for i in range(right - 1, left - 1, -1):\n            result.append(arr[bottom - 1][i])\n        bottom -= 1\n        for i in range(bottom - 1, top - 1, -1):\n            result.append(arr[i][left])\n        left += 1\n    return ''.join(result)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[["t", "h", "i", "s", "f", "u", "n", "c", "t", "i", "o", "n", "t", "e", "s", "t"], ["a", "n", "i", "s", "r", "e", "a", "l", "l", "y", "g", "o", "o", "d", "o", "n"], ["t", "i", "m", "e", "t", "o", "s", "e", "e", "i", "f", "i", "t", "p", "a", "s", "s"], ["e", "s", "t", "r", "t", "h", "i", "s", "p", "r", "o", "g", "r", "a", "m", "m", "e"]]]], "plus_fail_tests": []}], "EvoEval/5": [{"task_id": "EvoEval/5", "solution": "from typing import List, Tuple\n\n\ndef zigzag_traversal(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a 2D list of integers, return a list that represents its elements traversed in a zigzag order starting from the top-left corner and moving rightwards.\n    When the right end is reached, the direction should be downwards to the next row, then to the left end, and so on until all elements are covered. \n    >>> zigzag_traversal([[1, 2], [3, 4], [5, 6, 7], [8, 9, 10]])\n    [1, 2, 4, 3, 5, 6, 7, 10, 9, 8]\n    \"\"\"\n    zigzag = []\n    for (i, row) in enumerate(matrix):\n        if i % 2 == 0:\n            zigzag.extend(row)\n        else:\n            zigzag.extend(row[::-1])\n    return zigzag", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/17": [{"task_id": "EvoEval/17", "solution": "def wizard_battle(dragon_hp: int, wizards: list) -> str:\n    \"\"\" Return the name of the wizard who defeated the dragon, given the dragon's hit points (HP) and\n    an ordered list with the name of the wizard and their magic power:\n        - The wizard's magic reduces the dragon's HP by their magic power. \n        - Wizards take turns in the order they are listed, and they only get to attack once.\n        - The dragon is defeated when its HP is reduced to 0 or less.\n\n    If none of the wizards can defeat the dragon return 'The dragon won!'\n\n    Note that the wizards are a list of tuples, where each tuple has the wizard's name as a string and\n    their magic power as an integer. The dragon's HP is a positive integer.\n    \"\"\"\n    for wizard in wizards:\n        (name, power) = wizard\n        dragon_hp -= power\n        if dragon_hp <= 0:\n            return name\n    return 'The dragon won!'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/28": [{"task_id": "EvoEval/28", "solution": "def calculate_progressive_tax(income: float, deductions=0) -> float:\n    \"\"\"\n    Calculate the tax for a given income and deductions according to a set of progressive tax rates:\n\n    - Up to $10,000 of income is tax-free\n    - The next $25,000 is taxed at 15%\n    - The next $45,000 is taxed at 25%\n    - Any income over $80,000 is taxed at 30%\n\n    The function also considers tax reductions due to deductions:\n        - The first $1000 of deductions are subtracted at a 1:1 ratio from the taxable income\n        - The next $2000 of deductions are subtracted at a 2:1 ratio from the taxable income\n        - Any deduction over $3000 is subtracted at a 3:1 ratio from the taxable income\n\n    It should return a float representing the amount of tax.\n\n    Examples:\n    >>> calculate_progressive_tax(12000, 500)\n    225.0\n    >>> calculate_progressive_tax(55000, 2500)\n    7750.0\n    >>> calculate_progressive_tax(120000, 5000)\n    23700.0\n    \"\"\"\n    if deductions <= 1000:\n        income -= deductions\n    elif deductions <= 3000:\n        income -= 1000 + (deductions - 1000) / 2\n    else:\n        income -= 1000 + 1000 + (deductions - 3000) / 3\n    tax = 0\n    if income > 80000:\n        tax += (income - 80000) * 0.3\n        income = 80000\n    if income > 35000:\n        tax += (income - 35000) * 0.25\n        income = 35000\n    if income > 10000:\n        tax += (income - 10000) * 0.15\n        income = 10000\n    return tax", "base_status": "fail", "plus_status": null, "base_fail_tests": [[55000, 2500]], "plus_fail_tests": []}], "EvoEval/51": [{"task_id": "EvoEval/51", "solution": "def alien_encoding(string, list_of_alphabets):\n    if not list_of_alphabets:\n        return string\n    if not string:\n        return ''\n    encoded_string = ''\n    for (i, char) in enumerate(string):\n        encoded_char = list_of_alphabets[i % len(list_of_alphabets)]\n        encoded_string += encoded_char\n    return encoded_string", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/69": [{"task_id": "EvoEval/69", "solution": "def magicTrick(cards, magicNumber):\n    for i in range(len(cards)):\n        for j in range(i + 1, len(cards)):\n            if cards[i] * cards[j] == magicNumber:\n                return (i, j)\n    return 'No magic today'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/99": [{"task_id": "EvoEval/99", "solution": "def musical_chairs(n, rounds, music):\n    players = list(range(1, n + 1))\n    current_position = 0\n    for round_duration in rounds:\n        steps = round_duration * music % len(players)\n        current_position = (current_position + steps) % len(players)\n        players.pop(current_position)\n        if current_position == len(players):\n            current_position = 0\n    return players", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/79": [{"task_id": "EvoEval/79", "solution": "def find_fruitful_days(prices, days):\n    \"\"\"\n    Given a list of prices of a certain fruit and the number of days a vendor has stayed in the market, \n    find the maximum profit that could be made by the vendor if he could buy and sell the fruit only once during his stay.\n\n    The vendor has the ability to know the prices of the fruit in the future. \n    He wants to buy the fruit on one day and sell it on another day that comes after the day he bought the fruit.\n    If he cannot make any profit, return 0.\n\n    Args:\n        prices (list): A list of integers representing the prices of the fruit for each day.\n        days (int): The latest of day the vendor can buy fruits.\n\n    Returns:\n        int: The maximum profit that could be made by the vendor.\n\n    Example:\n\n        Input: prices = [1, 5, 2, 8, 7, 3], days = 5\n        Output: 7 # The vendor buys the fruit on the first day at price 1 and sells it on the fourth day at price 8.\n\n    Constraints:\n        1. 1 <= len(prices) <= 100\n        2. 1 <= days <= len(prices)\n    \"\"\"\n    min_price = prices[0]\n    max_profit = 0\n    for i in range(1, days):\n        if prices[i] < min_price:\n            min_price = prices[i]\n        profit = prices[i] - min_price\n        if profit > max_profit:\n            max_profit = profit\n    return max_profit", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/36": [{"task_id": "EvoEval/36", "solution": "def calculate_integral_coefficients(xs: list):\n    \"\"\"\n    Calculate the coefficients of the indefinite integral of a polynomial.\n    \n    Args:\n    xs (list): Coefficients of the polynomial, where xs[i] is the coefficient for x^i.\n    \n    Returns:\n    list: Coefficients of the indefinite integral of the polynomial, with the constant of integration set to zero.\n    \"\"\"\n    integral_coefficients = [0]\n    for (i, coeff) in enumerate(xs):\n        integral_coefficients.append(coeff / (i + 1))\n    return integral_coefficients", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/86": [{"task_id": "EvoEval/86", "solution": "def sort_movies_by_ratings_and_release_date(movies_dict):\n    sorted_movies = sorted(movies_dict.items(), key=lambda x: (x[1][0], -x[1][1]), reverse=True)\n    sorted_movie_names = [movie[0] for movie in sorted_movies]\n    return sorted_movie_names", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"Toy Story": [8.3, 1995], "Toy Story 2": [7.9, 1999], "Toy Story 3": [8.3, 2010], "Toy Story 4": [7.8, 2019]}]], "plus_fail_tests": []}], "EvoEval/72": [{"task_id": "EvoEval/72", "solution": "def string_fairy_tale(lst):\n    \"\"\"Given a list of strings, where each string consists of a mix of letters and numbers, return a list.\n    Each element of the output should be a fairy tale inspired story. The story should be \"Once upon a time, \n    in a kingdom far away, lived a magical creature with the name of 'i' who was known for telling 'j' tales a day,\n    where 'i' is the i'th string of the input and 'j' is the count of digits in that string.\n    \"\"\"\n    fairy_tales = []\n    for creature in lst:\n        digit_count = sum((c.isdigit() for c in creature))\n        story = f\"Once upon a time, in a kingdom far away, lived a magical creature with the name of '{creature}' who was known for telling {digit_count} tales a day\"\n        fairy_tales.append(story)\n    return fairy_tales", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/66": [{"task_id": "EvoEval/66", "solution": "def prime_anagram_pairs(n):\n    primes = [i for i in range(2, n) if is_prime(i)]\n    pairs = []\n    for i in range(len(primes)):\n        for j in range(i + 1, len(primes)):\n            if are_anagrams(primes[i], primes[j]):\n                pairs.append((primes[i], primes[j]))\n    return pairs", "base_status": "fail", "plus_status": null, "base_fail_tests": [[13]], "plus_fail_tests": []}], "EvoEval/4": [{"task_id": "EvoEval/4", "solution": "from typing import List\n\n\ndef candles_relight(candles: List[int]) -> int:\n    \"\"\"\n    You've got a list representing a row of birthday candles of various heights.\n    A candle at position \"i\" can be lit (gets the flame) if it is taller than all the candles \n    before it. The first candle is always lit. \n    Your task is to return the number of candles that can be lit.\n    An empty list means there were no candles, so return 0.\n\n    >>> candles_relight([3, 2, 1, 3, 2, 4])\n    2\n    >>> candles_relight([1, 2, 3, 4, 5])\n    5\n    >>> candles_relight([])\n    0\n    \"\"\"\n    if not candles:\n        return 0\n    lit_candles = 1\n    max_height = candles[0]\n    for height in candles[1:]:\n        if height > max_height:\n            lit_candles += 1\n            max_height = height\n    return lit_candles", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/48": [{"task_id": "EvoEval/48", "solution": "def wizard_inventory(inventory_logs):\n    inventory = {}\n    for log in inventory_logs:\n        item = log['item']\n        quantity = log['quantity']\n        if item in inventory:\n            inventory[item] += quantity\n        else:\n            inventory[item] = quantity\n        if inventory[item] <= 0:\n            del inventory[item]\n    return inventory", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/45": [{"task_id": "EvoEval/45", "solution": "def find_castle(arr):\n\n    def view_count_from_hill(index):\n        left_count = 0\n        max_left_height = 0\n        for i in range(index - 1, -1, -1):\n            if arr[i] > max_left_height:\n                left_count += 1\n                max_left_height = arr[i]\n            if arr[i] > arr[index]:\n                break\n        right_count = 0\n        max_right_height = 0\n        for i in range(index + 1, len(arr)):\n            if arr[i] > max_right_height:\n                right_count += 1\n                max_right_height = arr[i]\n            if arr[i] > arr[index]:\n                break\n        return left_count + right_count\n    max_view = 0\n    for i in range(len(arr)):\n        max_view = max(max_view, view_count_from_hill(i))\n    return max_view", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 2, 5, 3, 6, 4, 8, 2, 7]]], "plus_fail_tests": []}], "EvoEval/58": [{"task_id": "EvoEval/58", "solution": "def interstellar_translator(earth_phrase):\n\n    def translate_char(c):\n        vowels = 'aeiou'\n        consonants = 'bcdfghjklmnpqrstvwxyz'\n        if c in vowels:\n            return vowels[(vowels.index(c) + 1) % len(vowels)]\n        elif c in consonants:\n            return consonants[(consonants.index(c) + 1) % len(consonants)]\n        return c\n\n    def translate_word(word):\n        translated_word = ''\n        for (i, c) in enumerate(word):\n            if i == 0:\n                if c in 'aeiou':\n                    translated_word += translate_char(c).upper()\n                    append_text = 'xy'\n                else:\n                    translated_word += translate_char(c).upper()\n                    append_text = 'yz'\n            else:\n                translated_word += translate_char(c)\n        return translated_word + append_text\n    translated_phrase = '@'.join((translate_word(word) for word in earth_phrase.split(' ')))\n    return translated_phrase", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/53": [{"task_id": "EvoEval/53", "solution": "def magical_transformation(s):\n    vowel_map = {'a': 'e', 'e': 'i', 'i': 'o', 'o': 'u', 'u': 'a', 'A': 'E', 'E': 'I', 'I': 'O', 'O': 'U', 'U': 'A'}\n    consonant_map = {chr(i): chr((i - 98) % 26 + 99) for i in range(98, 123)}\n    consonant_map.update({chr(i).upper(): chr((i - 66) % 26 + 67) for i in range(66, 91)})\n    consonant_map['z'] = 'b'\n    consonant_map['Z'] = 'B'\n\n    def transform_char(c, index):\n        if c in vowel_map:\n            return vowel_map[c]\n        elif c.lower() in consonant_map:\n            return consonant_map[c]\n        elif c == '?' and index % 2 == 0:\n            return '!'\n        elif c == '!' and index % 2 != 0:\n            return '?'\n        else:\n            return c\n    transformed_string = ''.join((transform_char(c, i) for (i, c) in enumerate(s)))\n    return transformed_string", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Hello World???"]], "plus_fail_tests": []}], "EvoEval/80": [{"task_id": "EvoEval/80", "solution": "def adventure_game(map, instructions):\n    (start_row, start_col) = next(((i, j) for (i, row) in enumerate(map) for (j, val) in enumerate(row) if val == 'S'))\n    current_position = (start_row, start_col)\n    path = [current_position]\n    moves = {'up': (-1, 0), 'down': (1, 0), 'left': (0, -1), 'right': (0, 1)}\n    for instruction in instructions:\n        if map[current_position[0]][current_position[1]] == 'E':\n            break\n        move = moves[instruction]\n        new_position = (current_position[0] + move[0], current_position[1] + move[1])\n        if 0 <= new_position[0] < len(map) and 0 <= new_position[1] < len(map[0]) and (map[new_position[0]][new_position[1]] != 'X'):\n            current_position = new_position\n        path.append(current_position)\n    return path", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[["S", "X", "E"]], ["right", "right"]]], "plus_fail_tests": []}], "EvoEval/0": [{"task_id": "EvoEval/0", "solution": "from typing import List, Union\n\ndef calculate_shipping_cost(items: List[Union[str, float]], location: str) -> str:\n    base_cost_per_item = 5.0\n    total_cost = 0.0\n    string_item_multiplier = 1.0\n    location_multiplier = 1.0\n    if any((isinstance(item, str) for item in items)):\n        string_item_multiplier = 1.5\n    if location == 'Local':\n        location_multiplier = 1.0\n    elif location == 'National':\n        location_multiplier = 1.5\n    elif location == 'International':\n        location_multiplier = 2.5\n    for item in items:\n        if isinstance(item, str):\n            item_weight = 1.0\n        else:\n            item_weight = item\n        item_cost = base_cost_per_item\n        if item_weight > 5:\n            item_cost += 10.0\n        total_cost += item_cost\n    total_cost *= string_item_multiplier * location_multiplier\n    return f'{total_cost:.2f}'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/12": [{"task_id": "EvoEval/12", "solution": "from typing import List\n\ndef teleporter_energy_signature(flux_values: List[int]) -> int:\n    flux_counter = Counter(flux_values)\n    most_occurred_element = sorted(flux_counter.most_common(), key=lambda x: (-x[1], x[0]))[-1][0]\n    total_sum = sum(flux_values)\n    energy_signature = total_sum * most_occurred_element\n    return energy_signature", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 2, 1, 2, 5, 1, 6]]], "plus_fail_tests": []}], "EvoEval/54": [{"task_id": "EvoEval/54", "solution": "def find_star_map(lst, star):\n    coordinates = []\n    for (row_index, row) in enumerate(lst):\n        for (col_index, element) in enumerate(row):\n            if element == star:\n                coordinates.append((row_index, col_index))\n    return coordinates", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/18": [{"task_id": "EvoEval/18", "solution": "def magical_seven(n: int) -> int:\n    \"\"\"\n    magical_seven returns the n-th number that is a multiple of 7 and its digits sum up to 7.\n    \n    >>> magical_seven(1)\n    7\n    >>> magical_seven(2)\n    70\n    >>> magical_seven(3)\n    133\n    >>> magical_seven(4)\n    322\n    >>> magical_seven(5)\n    511\n    \"\"\"\n\n    def sum_of_digits(num: int) -> int:\n        \"\"\"Helper function to calculate the sum of digits of a number.\"\"\"\n        return sum((int(digit) for digit in str(num)))\n    count = 0\n    current_num = 0\n    while True:\n        if current_num % 7 == 0 and sum_of_digits(current_num) == 7:\n            count += 1\n            if count == n:\n                return current_num\n        current_num += 1", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/20": [{"task_id": "EvoEval/20", "solution": "def generate_pattern(n: int):\n    \"\"\"\n    Given an integer 'n', return a list of strings where each string represents a pattern. \n    The pattern is composed of the numbers from 1 to n in ascending order, then descending back to 1, \n    with each number separated by a comma. If n is 0 or negative, return an empty list.\n\n    >>> generate_pattern(3)\n    ['1', '1,2', '1,2,3', '3,2,1', '2,1', '1']\n\n    >>> generate_pattern(0)\n    []\n    \"\"\"\n    if n <= 0:\n        return []\n    pattern_list = []\n    for i in range(1, n + 1):\n        pattern_list.append(','.join((str(x) for x in range(1, i + 1))))\n    for i in range(n, 0, -1):\n        pattern_list.append(','.join((str(x) for x in range(i, 0, -1))))\n    return pattern_list", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/34": [{"task_id": "EvoEval/34", "solution": "def werewolf_transformation(n: int, m: int):\n    transformation_percentages = [0]\n    for day in range(2, n + 1):\n        if day < m:\n            transformation_percentages.append(min(transformation_percentages[-1] + 10, 100))\n        elif day == m:\n            transformation_percentages.append(min(transformation_percentages[-1] * 2, 100))\n        else:\n            transformation_percentages.append(max(transformation_percentages[-1] - 10, 0))\n    return transformation_percentages", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}]}}