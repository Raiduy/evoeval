{"eval": {"EvoEval/16": [{"task_id": "EvoEval/16", "solution": "def get_music_notes(word: str, music_string: str):\n    vowels = 'aeiouAEIOU'\n    notes = music_string.split()\n    note_values = {'o': 4, 'o|': 2, '.|': 1}\n    result = []\n    vowel_pos = -1\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels and word[i - 1] not in vowels and (word[i + 1] not in vowels):\n            vowel_pos = i\n            break\n    if vowel_pos == -1:\n        return result\n    for note in notes[:vowel_pos + 1]:\n        if note in note_values:\n            result.append(note_values[note])\n        else:\n            pass\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["abcd efgh", "o o| .| o| o| .| .| .| .| o o"]], "plus_fail_tests": []}], "EvoEval/62": [{"task_id": "EvoEval/62", "solution": "\ndef strange_word_sort(text):\n    text = text.replace('   ', '-')\n    text = text.replace(' ', '_')\n    words = []\n    temp_word = ''\n    for char in text:\n        if char in '-_':\n            if temp_word:\n                words.append(temp_word)\n                temp_word = ''\n            words.append(char)\n        else:\n            temp_word += char\n    if temp_word:\n        words.append(temp_word)\n    words = [word for word in words if word not in '-_']\n    words.sort(key=str.lower)\n    strange_sorted_words = []\n    while words:\n        if words:\n            strange_sorted_words.append(words.pop(0))\n        if words:\n            strange_sorted_words.append(words.pop(-1))\n    result = []\n    for word in strange_sorted_words:\n        if result and result[-1] not in '-_':\n            result.append('_')\n        result.append(word)\n    final_result = ''.join(result).replace('_-', '-').replace('-_', '-')\n    return final_result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["House   car"]], "plus_fail_tests": []}], "EvoEval/82": [{"task_id": "EvoEval/82", "solution": "\ndef odd_fibfib(n: int) -> int:\n    if n == 0 or n == 1:\n        return 0\n    if n == 2:\n        return 1\n    (a, b, c) = (0, 0, 1)\n    for _ in range(3, n + 1):\n        next_element = a + b + c\n        if next_element % 2 == 0:\n            next_element = product_of_odd_digits(next_element)\n        (a, b, c) = (b, c, next_element)\n    return c", "base_status": "fail", "plus_status": null, "base_fail_tests": [[9]], "plus_fail_tests": []}], "EvoEval/70": [{"task_id": "EvoEval/70", "solution": "\nfrom typing import List, Tuple\nimport math\n\n\ndef closest_special_factorial(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"Find the two numbers with the closest special factorials.\"\"\"\n    special_factorials = {num: special_factorial(num) for num in numbers}\n    sorted_numbers = sorted(numbers, key=lambda x: special_factorials[x])\n    closest_pair = (0, 0)\n    min_diff = float('inf')\n    for i in range(len(sorted_numbers) - 1):\n        diff = abs(special_factorials[sorted_numbers[i]] - special_factorials[sorted_numbers[i + 1]])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    return closest_pair", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[4, 5, 6]]], "plus_fail_tests": []}], "EvoEval/75": [{"task_id": "EvoEval/75", "solution": "def transform_dict(input_dict):\n    if not input_dict:\n        return {}\n    if not all((isinstance(key, str) for key in input_dict.keys())) or not (all((key.isupper() for key in input_dict)) or all((key.islower() for key in input_dict))):\n        return {}\n    output_dict = {}\n    for (key, value) in input_dict.items():\n        try:\n            num = float(value)\n            if num > 0:\n                rounded_num = int(num + 0.5)\n            else:\n                rounded_num = int(num - 0.5)\n            output_dict[key] = rounded_num\n        except ValueError:\n            return {}\n    return output_dict", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/61": [{"task_id": "EvoEval/61", "solution": "\nfrom typing import List, Optional, Tuple\n\ndef longest_planet_chain(planet1: str, planet2: str, chains: List[Tuple[str, ...]]) -> Optional[Tuple[str, ...]]:\n    valid_planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in valid_planets or planet2 not in valid_planets:\n        return None\n    longest_chain = None\n    for chain in chains:\n        if chain[0] == planet1 and chain[-1] == planet2:\n            if longest_chain is None or len(chain) > len(longest_chain):\n                longest_chain = chain\n    return longest_chain", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/55": [{"task_id": "EvoEval/55", "solution": "import hashlib\n\ndef mini_roman_to_md5(number):\n    \"\"\"\n    Given a positive integer 'number', convert it to its roman numeral equivalent as a string in lowercase.\n    Return the md5 hash of the roman numeral string. If 'number' is zero or negative, return None.\n    Restrictions: 0 <= num <= 1000\n    \"\"\"\n    if number <= 0:\n        return None\n    roman_numeral = int_to_roman(number)\n    md5_hash = hashlib.md5(roman_numeral.encode()).hexdigest()\n    return md5_hash", "base_status": "fail", "plus_status": null, "base_fail_tests": [[426]], "plus_fail_tests": []}], "EvoEval/91": [{"task_id": "EvoEval/91", "solution": "\ndef sort_prime_even(l: list, x, y):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted. If the sorted element at an even index\n    is prime, replace it with x. Otherwise, replace it with y.\n\n    Examples:\n    sort_prime_even([2, 3, 4, 5, 6], 10, 20) == [10, 3, 20, 5, 20]\n    sort_prime_even([7, 1, 9, 2, 8], 15, 30) == [15, 1, 30, 2, 30]\n    \"\"\"\n    even_indices_elements = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    for i in range(len(even_indices_elements)):\n        if is_prime(even_indices_elements[i]):\n            even_indices_elements[i] = x\n        else:\n            even_indices_elements[i] = y\n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices_elements[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[7, 1, 9, 2, 8], 15, 30]], "plus_fail_tests": []}], "EvoEval/22": [{"task_id": "EvoEval/22", "solution": "def binary_planet_distance(planet1, planet2):\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ''\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    if index1 > index2:\n        (index1, index2) = (index2, index1)\n    count = index2 - index1 - 1\n    binary_count = bin(count)[2:]\n    formatted_string = f'bd{binary_count}bd'\n    return formatted_string", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Neptune", "Neptune"]], "plus_fail_tests": []}], "EvoEval/26": [{"task_id": "EvoEval/26", "solution": "\nfrom typing import List, Tuple\n\ndef sort_and_pluck(values: List[str]) -> Tuple[str, int]:\n    numeral_to_number = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    number_to_numeral = {v: k for (k, v) in numeral_to_number.items()}\n    sorted_values = []\n    for value in values:\n        sorted_numerals = sorted(value.split(), key=lambda x: numeral_to_number[x])\n        sorted_values.append(sorted_numerals)\n    smallest_even = None\n    original_index = None\n    for (index, sorted_numerals) in enumerate(sorted_values):\n        for numeral in sorted_numerals:\n            number = numeral_to_number[numeral]\n            if number % 2 == 0:\n                if smallest_even is None or number < numeral_to_number[smallest_even]:\n                    smallest_even = numeral\n                    original_index = index\n                break\n    if smallest_even is not None:\n        return (smallest_even, original_index)\n    else:\n        return ()", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["three two one", "five four zero", "six nine eight"]]], "plus_fail_tests": []}], "EvoEval/19": [{"task_id": "EvoEval/19", "solution": "from typing import List, Tuple, Optional\n\ndef account_operations(operations: List[int]) -> Tuple[Optional[int], Optional[int], bool]:\n    balance = 0\n    largest_withdrawal = None\n    smallest_deposit = None\n    balance_never_negative = True\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            balance_never_negative = False\n            break\n        if operation > 0:\n            if smallest_deposit is None or operation < smallest_deposit:\n                smallest_deposit = operation\n        elif operation < 0:\n            if largest_withdrawal is None or operation > largest_withdrawal:\n                largest_withdrawal = operation\n    return (largest_withdrawal, smallest_deposit, not balance_never_negative)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, -3, 2, -2, 5]]], "plus_fail_tests": []}], "EvoEval/50": [{"task_id": "EvoEval/50", "solution": "\ndef get_closest_upper_vowel(word):\n    vowels = 'AEIOU'\n    reversed_word = word[::-1]\n    for i in range(1, len(reversed_word) - 1):\n        if reversed_word[i] in vowels and (len(word) - 1 - i) % 2 == 0:\n            if reversed_word[i - 1].isalpha() and reversed_word[i + 1].isalpha() and (reversed_word[i - 1].upper() not in vowels) and (reversed_word[i + 1].upper() not in vowels):\n                return reversed_word[i]\n    return ''", "base_status": "fail", "plus_status": null, "base_fail_tests": [["12U34"]], "plus_fail_tests": []}], "EvoEval/88": [{"task_id": "EvoEval/88", "solution": "\ndef process_and_sort_string(s):\n    words = s.replace(',', ' ').split()\n    even_length_words = [word for word in words if len(word) % 2 == 0]\n    sorted_words = sorted(even_length_words, key=lambda word: (len(word), word))\n    return sorted_words", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/38": [{"task_id": "EvoEval/38", "solution": "\ndef even_odd_zero_sum(l, n):\n    even_palindromes = 0\n    odd_palindromes = 0\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_palindromes += 1\n            else:\n                odd_palindromes += 1\n\n    def has_two_elements_with_sum(lst, target):\n        seen = set()\n        for num in lst:\n            if target - num in seen:\n                return True\n            seen.add(num)\n        return False\n    even_sum_exists = has_two_elements_with_sum(l, even_palindromes)\n    odd_sum_exists = has_two_elements_with_sum(l, odd_palindromes)\n    return (even_sum_exists, odd_sum_exists)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, -3, 2, -3, -1, 5, -2, 14], 101]], "plus_fail_tests": []}], "EvoEval/89": [{"task_id": "EvoEval/89", "solution": "\nfrom typing import List\n\ndef md5_substring_filter(strings: List[str], hash_substring: str) -> List[str]:\n    \"\"\"\n    Given a list of strings 'strings' and a hash_substring, return a list of strings \n    for which the md5 hash equivalent string contains the hash_substring.\n    If 'strings' is an empty list, return None.\n    The md5 hash of an empty string should not be considered.\n\n    >>> md5_substring_filter(['Hello world', 'Python', ''], '3e25960a79dbc69b674cd4ec67a72c62')\n    ['Hello world']\n    >>> md5_substring_filter(['Python', 'Hello', '123', ''], '96')\n    ['Hello', '123']\n    \"\"\"\n    if not strings:\n        return None\n    filtered_strings = []\n    for string in strings:\n        if string:\n            md5_hash = hashlib.md5(string.encode()).hexdigest()\n            if hash_substring in md5_hash:\n                filtered_strings.append(string)\n    return filtered_strings", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["Python", "Hello", "123", ""], "96"]], "plus_fail_tests": []}], "EvoEval/10": [{"task_id": "EvoEval/10", "solution": "\ndef class_grades_with_flip(name_grade_list):\n\n    def gpa_to_letter(gpa):\n        if gpa == 4.0:\n            return 'A+'\n        elif gpa > 3.7:\n            return 'A'\n        elif gpa > 3.3:\n            return 'A-'\n        elif gpa > 3.0:\n            return 'B+'\n        elif gpa > 2.7:\n            return 'B'\n        elif gpa > 2.3:\n            return 'B-'\n        elif gpa > 2.0:\n            return 'C+'\n        elif gpa > 1.7:\n            return 'C'\n        elif gpa > 1.3:\n            return 'C-'\n        elif gpa > 1.0:\n            return 'D+'\n        elif gpa > 0.7:\n            return 'D'\n        elif gpa > 0.0:\n            return 'D-'\n        else:\n            return 'E'\n    result = []\n    for (name, gpa) in name_grade_list:\n        proper_name = name.capitalize()\n        letter_grade = gpa_to_letter(gpa)\n        result.append((proper_name, letter_grade))\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/81": [{"task_id": "EvoEval/81", "solution": "\nfrom typing import List\n\ndef mean_absolute_deviation_fibfib(n: int) -> float:\n    \"\"\"\n    Given an integer n, calculate the mean absolute deviation of the first n elements of a modified Fibonacci sequence,\n    called the FibFib sequence. The FibFib sequence is defined as follows:\n    \n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    \n    Then, compute the Mean Absolute Deviation (MAD) of these n elements. The MAD is the average absolute difference\n    between each element and the mean of this set:\n    MAD = average | x - x_mean |\n    \"\"\"\n    if n == 0:\n        return 0.0\n    elif n == 1:\n        return 0.0\n    fibfib_sequence = [0, 0, 1] + [0] * (n - 3)\n    for i in range(3, n):\n        fibfib_sequence[i] = fibfib_sequence[i - 1] + fibfib_sequence[i - 2] + fibfib_sequence[i - 3]\n    mean = sum(fibfib_sequence) / n\n    mad = sum((abs(x - mean) for x in fibfib_sequence)) / n\n    return mad", "base_status": "fail", "plus_status": null, "base_fail_tests": [[2]], "plus_fail_tests": []}], "EvoEval/24": [{"task_id": "EvoEval/24", "solution": "from typing import List\n\ndef sort_happy_numbers(numbers: str) -> str:\n    \"\"\" \n    Input is a space-delimited string of numerals from 'zero' to 'nine'. Valid choices are 'zero', 'one', 'two', \n    'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'. This function has two main operations:\n    \n    1) It checks if the string of numbers is 'happy'. A string is happy if, after removing spaces from the string, every 3 consecutive letters are distinct.\n    For instance, 'one two three' is not happy, but 'one one two' is happy. If the string is not happy, return 'Not a happy string'.\n    \n    2) If the string is happy, it sorts the string with numbers from smallest to largest and returns the sorted string.\n    \"\"\"\n    word_to_num = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    words = numbers.split()\n    concatenated = ''.join(words)\n    for i in range(len(concatenated) - 2):\n        if concatenated[i] == concatenated[i + 1] == concatenated[i + 2]:\n            return 'Not a happy string'\n    sorted_words = sorted(words, key=lambda word: word_to_num[word])\n    return ' '.join(sorted_words)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["three two two"]], "plus_fail_tests": []}], "EvoEval/44": [{"task_id": "EvoEval/44", "solution": "\nfrom typing import List\n\ndef roman_prefixes(number: int) -> List[str]:\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string in lowercase.\n    Afterwards, return a list of all prefixes of the roman numeral from shortest to longest.\n    \"\"\"\n    roman_numeral = int_to_roman(number)\n    prefixes = [roman_numeral[:i] for i in range(1, len(roman_numeral) + 1)]\n    return prefixes", "base_status": "fail", "plus_status": null, "base_fail_tests": [[711]], "plus_fail_tests": []}], "EvoEval/57": [{"task_id": "EvoEval/57", "solution": "def palindromic_and_odd_digit_array(arr):\n\n    def is_all_odd(num):\n        \"\"\"Check if all digits of num are odd.\"\"\"\n        return all((int(digit) % 2 != 0 for digit in str(num)))\n\n    def min_changes_to_odd(num):\n        \"\"\"Determine the minimum changes to make num have all odd digits.\"\"\"\n        if is_all_odd(num):\n            return 0\n        digits = [int(digit) for digit in str(num)]\n        for (i, digit) in enumerate(digits):\n            if digit % 2 == 0:\n                digits[i] = digit - 1 if digit > 0 else 1\n        return 1\n    changes = 0\n    (left, right) = (0, len(arr) - 1)\n    while left <= right:\n        if arr[left] != arr[right]:\n            changes += 1\n            if not is_all_odd(arr[left]) and (not is_all_odd(arr[right])):\n                changes += min(min_changes_to_odd(arr[left]), min_changes_to_odd(arr[right]))\n            elif not is_all_odd(arr[left]):\n                changes += min_changes_to_odd(arr[left])\n            elif not is_all_odd(arr[right]):\n                changes += min_changes_to_odd(arr[right])\n        else:\n            changes += min_changes_to_odd(arr[left])\n        left += 1\n        right -= 1\n    return changes", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 2, 5]]], "plus_fail_tests": []}], "EvoEval/94": [{"task_id": "EvoEval/94", "solution": "\ndef sort_count_nums(arr):\n    \"\"\"\n    Function to sort an array based on the count of numbers with sum of digits > 0.\n    \"\"\"\n    count_positive_sum = sum((1 for num in arr if sum_of_digits(num) > 0))\n    if count_positive_sum % 2 == 1:\n        return sorted(arr)\n    else:\n        return sorted(arr, reverse=True)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[-1, 11, -11, 2, 4, 3, 0, 1, 5, 6]]], "plus_fail_tests": []}], "EvoEval/76": [{"task_id": "EvoEval/76", "solution": "def sort_prime_digit_sum(lst):\n    \"\"\"\n    Modify and sort the list as per the given conditions.\n    \"\"\"\n    modified_list = [digit_sum(item) if is_prime(item) else item for item in lst]\n    if len(modified_list) > 0 and (modified_list[0] + modified_list[-1]) % 2 == 0:\n        modified_list.sort(reverse=True)\n    else:\n        modified_list.sort()\n    return modified_list", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]]], "plus_fail_tests": []}], "EvoEval/83": [{"task_id": "EvoEval/83", "solution": "\nimport re\n\n\ndef prime_underscored_length(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with a single underscore (\"-\").\n    \n    After the replacement, check if the length of the new string is a prime number. \n    Return True if it is a prime number, False otherwise. \n    \"\"\"\n    text = re.sub(' {2,}', '-', text)\n    text = text.replace(' ', '_')\n    return is_prime(len(text))", "base_status": "fail", "plus_status": null, "base_fail_tests": [[" Example    4"]], "plus_fail_tests": []}], "EvoEval/14": [{"task_id": "EvoEval/14", "solution": "\ndef prime_avg_range(n, m):\n    \"\"\"Compute the binary representation of the rounded average of prime numbers in a given range.\"\"\"\n    if n > m:\n        return -1\n    primes = [i for i in range(n, m + 1) if is_prime(i)]\n    if not primes:\n        return -1\n    avg = round(sum(primes) / len(primes))\n    return bin(avg)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[10, 10]], "plus_fail_tests": []}], "EvoEval/32": [{"task_id": "EvoEval/32", "solution": "\nfrom typing import List\n\ndef circular_shift_nested_parens(input: List[str], shift: int) -> List[int]:\n\n    def deepest_nesting(s: str) -> int:\n        \"\"\"Calculate the deepest level of nesting in a string of parentheses.\"\"\"\n        max_depth = 0\n        current_depth = 0\n        for char in s:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        return max_depth\n    concatenated_depths = int(''.join((str(deepest_nesting(group)) for group in input)))\n    digits = [int(d) for d in str(concatenated_depths)]\n    n = len(digits)\n    shift = shift % n\n    if shift > 0:\n        digits = digits[-shift:] + digits[:-shift]\n    elif shift < 0:\n        shift = abs(shift)\n        digits = digits[shift:] + digits[:shift]\n    return digits", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["(()())", "((()))", "()", "((())()())"], 5]], "plus_fail_tests": []}], "EvoEval/31": [{"task_id": "EvoEval/31", "solution": "\nfrom typing import List\n\ndef special_prime_factorial(n: int) -> int:\n    \"\"\"\n    This function first factorizes the input 'n' into its prime factors and then calculates a special factorial.\n    The 'special factorial' is defined as the product of factorials of all the prime factors of 'n'.\n    The factors should be calculated number of times corresponding to how many times they appear in the factorization.\n    The function should return the product of these factorials.\n    \"\"\"\n    factors = prime_factors(n)\n    result = 1\n    for factor in factors:\n        result *= factorial(factor)\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[70]], "plus_fail_tests": []}], "EvoEval/35": [{"task_id": "EvoEval/35", "solution": "def check_dict_happiness(dict):\n    if not dict:\n        return False\n    all_lower = all((key.islower() for key in dict.keys()))\n    all_upper = all((key.isupper() for key in dict.keys()))\n    if not (all_lower or all_upper):\n        return False\n\n    def is_happy_string(s):\n        if len(s) < 3:\n            return False\n        for i in range(len(s) - 2):\n            if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n                return False\n        return True\n    for key in dict.keys():\n        if not isinstance(key, str) or not is_happy_string(key):\n            return False\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"aab": "apple", "8": "banana", "a": "apple"}]], "plus_fail_tests": []}], "EvoEval/40": [{"task_id": "EvoEval/40", "solution": "\ndef largest_prime_odd_ends(nums):\n\n    def has_odd_ends(n):\n        \"\"\"Check if a number has both first and last digits odd.\"\"\"\n        str_n = str(abs(n))\n        return str_n[0] in '13579' and str_n[-1] in '13579'\n\n    def largest_prime_factor(n):\n        \"\"\"Find the largest prime factor of a number.\"\"\"\n        largest_prime = None\n        while n % 2 == 0:\n            largest_prime = 2\n            n //= 2\n        for i in range(3, int(n ** 0.5) + 1, 2):\n            while n % i == 0:\n                largest_prime = i\n                n //= i\n        if n > 2:\n            largest_prime = n\n        return largest_prime\n    prime_factors = [largest_prime_factor(num) for num in nums if num > 10 and has_odd_ends(num)]\n    return max(prime_factors) if prime_factors else None", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/78": [{"task_id": "EvoEval/78", "solution": "\ndef solve_and_count(s):\n    vowels = 'AEIOUaeiou'\n    uppercase_vowels = 'AEIOU'\n    has_letters = any((c.isalpha() for c in s))\n    if has_letters:\n        result_string = ''.join((c.swapcase() if c.isalpha() else c for c in s))\n    else:\n        result_string = s[::-1]\n    count_uppercase_vowels_even = sum((1 for (i, c) in enumerate(result_string) if i % 2 == 0 and c in uppercase_vowels))\n    return (result_string, count_uppercase_vowels_even)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/2": [{"task_id": "EvoEval/2", "solution": "\nfrom typing import List\n\ndef modp_intersperse(numbers: List[int], n: int, p: int) -> List[int]:\n    \"\"\" Insert the result of 2^n modulo p between every two consecutive elements of input list `numbers' \"\"\"\n    if not numbers:\n        return []\n    mod_result = pow(2, n, p)\n    interspersed_list = []\n    for number in numbers[:-1]:\n        interspersed_list.append(number)\n        interspersed_list.append(mod_result)\n    interspersed_list.append(numbers[-1])\n    return interspersed_list", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/71": [{"task_id": "EvoEval/71", "solution": "\nimport math\n\ndef special_brazilian_balloon(n, w):\n\n    def brazilian_factorial(n):\n        result = 1\n        for i in range(1, n + 1):\n            result *= math.factorial(i)\n        return result\n\n    def is_palindrome(lst):\n        return lst == lst[::-1]\n    max_weight = brazilian_factorial(n)\n    sum_weights = sum(w)\n    if sum_weights <= max_weight and is_palindrome(w):\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/85": [{"task_id": "EvoEval/85", "solution": "def next_smallest_sorted_binary(lst):\n    sorted_lst = sorted(lst, key=lambda x: (bin(x).count('1'), x))\n    if len(sorted_lst) < 2:\n        return None\n    return sorted_lst[1]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 1]]], "plus_fail_tests": []}], "EvoEval/47": [{"task_id": "EvoEval/47", "solution": "def count_odd_upper(s, lst):\n    uppercase_vowels = 'AEIOU'\n    n = sum((1 for i in range(0, len(s), 2) if s[i] in uppercase_vowels))\n    output = []\n    for string in lst:\n        m = sum((1 for char in string if int(char) % 2 != 0))\n        output.append(f'In the string, the number of uppercase vowels in even indices is {n}, and the number of odd digits is {m}.')\n    return output", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/74": [{"task_id": "EvoEval/74", "solution": "def sum_exchange(lst1, lst2, x, y, z):\n    \"\"\"\n    In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, the answer is \"YES\".\n    Otherwise, the answer is \"NO\".\n    After that, the function also takes in three more integers, x, y and z.\n    It will check if one of these integers is equal to the sum of the other two.\n    If this is true, append \"SUM\" to the front of the answer string.\n    Otherwise, append \"NO_SUM\" to the front of the answer string.\n    For example:\n    sum_exchange([1, 2, 3, 4], [1, 2, 3, 4], 5, 2, 2) => \"NO_SUM YES\"\n    sum_exchange([1, 2, 3, 4], [1, 5, 3, 4], 4, 2, 2) => \"SUM NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    odd_in_lst1 = [num for num in lst1 if num % 2 != 0]\n    even_in_lst2 = [num for num in lst2 if num % 2 == 0]\n    if len(odd_in_lst1) <= len(even_in_lst2):\n        exchange_possible = 'YES'\n    else:\n        exchange_possible = 'NO'\n    if x == y + z or y == x + z or z == x + y:\n        sum_condition = 'SUM'\n    else:\n        sum_condition = 'NO_SUM'\n    result = f'{sum_condition} {exchange_possible}'\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/52": [{"task_id": "EvoEval/52", "solution": "def pluck_and_prod(arr):\n    if not arr or all((num % 2 != 0 for num in arr)):\n        return ([], None)\n    smallest_even = None\n    index_of_smallest_even = None\n    for (i, num) in enumerate(arr):\n        if num % 2 == 0 and (smallest_even is None or num < smallest_even):\n            smallest_even = num\n            index_of_smallest_even = i\n    plucked_node = [smallest_even, index_of_smallest_even]\n    arr.pop(index_of_smallest_even)\n    if not arr:\n        return (plucked_node, None)\n    sum_of_magnitudes = sum((abs(num) for num in arr))\n    product_of_signs = 1\n    for num in arr:\n        if num < 0:\n            product_of_signs *= -1\n        elif num == 0:\n            product_of_signs = 0\n            break\n    return (plucked_node, sum_of_magnitudes * product_of_signs)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[0]]], "plus_fail_tests": []}], "EvoEval/13": [{"task_id": "EvoEval/13", "solution": "def filter_exchange(arr, lst1):\n    filtered_arr = [num for num in arr if sum_of_digits(num) > 0]\n    even_count_lst1 = sum((num % 2 == 0 for num in lst1))\n    odd_count_lst1 = len(lst1) - even_count_lst1\n    even_count_filtered_arr = sum((num % 2 == 0 for num in filtered_arr))\n    odd_count_filtered_arr = len(filtered_arr) - even_count_filtered_arr\n    if odd_count_lst1 <= even_count_filtered_arr:\n        return 'YES'\n    else:\n        return 'NO'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 1, -122, 2], [1, 2, 3, 4]]], "plus_fail_tests": []}], "EvoEval/34": [{"task_id": "EvoEval/34", "solution": "from typing import List\n\ndef md5_nested_parens(paren_string: str) -> List[str]:\n    if not paren_string:\n        return []\n\n    def md5_hash(s: str) -> str:\n        return hashlib.md5(s.encode()).hexdigest()\n\n    def deepest_paren_level(s: str) -> str:\n        max_depth = 0\n        current_depth = 0\n        balanced = True\n        for char in s:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n                if current_depth < 0:\n                    balanced = False\n                    break\n        if current_depth != 0:\n            balanced = False\n        return str(max_depth) if balanced else 'None'\n    groups = paren_string.split()\n    deepest_levels = [deepest_paren_level(group) for group in groups]\n    md5_hashes = [md5_hash(level) for level in deepest_levels]\n    return md5_hashes", "base_status": "fail", "plus_status": null, "base_fail_tests": [["(()()) (((((()))()((())()()))))"]], "plus_fail_tests": []}], "EvoEval/63": [{"task_id": "EvoEval/63", "solution": "\ndef sort_planets(planet1: str, planet2: str, order: str) -> str:\n    planet_to_num = {'Mercury': 'zero', 'Venus': 'one', 'Earth': 'two', 'Mars': 'three', 'Jupiter': 'four', 'Saturn': 'five', 'Uranus': 'six', 'Neptune': 'seven'}\n    num1 = planet_to_num.get(planet1)\n    num2 = planet_to_num.get(planet2)\n    if num1 is None or num2 is None:\n        return 'Invalid'\n    order_list = order.split()\n    if len(order_list) != len(set(order_list)) or set(order_list) != set(planet_to_num.values()):\n        return 'Invalid'\n    index1 = order_list.index(num1)\n    index2 = order_list.index(num2)\n    if index1 > index2:\n        (index1, index2) = (index2, index1)\n    return ' '.join(order_list[index1 + 1:index2])", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Mercury", "Neptune", "zero one one two three four five six seven"]], "plus_fail_tests": []}], "EvoEval/98": [{"task_id": "EvoEval/98", "solution": "\ndef check_dict_bracketing(dict):\n    if not dict:\n        return False\n    all_lower = all((key.islower() for key in dict.keys()))\n    all_upper = all((key.isupper() for key in dict.keys()))\n    if not (all_lower or all_upper):\n        return False\n\n    def is_correct_bracketing(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    for value in dict.values():\n        if not is_correct_bracketing(value):\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/20": [{"task_id": "EvoEval/20", "solution": "\ndef grade_and_case(s, grades):\n\n    def reverse_case(name):\n        return ''.join([char.upper() if char.islower() else char.lower() for char in name])\n\n    def assign_grade(gpa):\n        if gpa == 4.0:\n            return 'A+'\n        elif gpa > 3.7:\n            return 'A'\n        elif gpa > 3.3:\n            return 'A-'\n        elif gpa > 3.0:\n            return 'B+'\n        elif gpa > 2.7:\n            return 'B'\n        elif gpa > 2.3:\n            return 'B-'\n        elif gpa > 2.0:\n            return 'C+'\n        elif gpa > 1.7:\n            return 'C'\n        elif gpa > 1.3:\n            return 'C-'\n        elif gpa > 1.0:\n            return 'D+'\n        elif gpa > 0.7:\n            return 'D'\n        elif gpa > 0.0:\n            return 'D-'\n        else:\n            return 'E'\n    result = []\n    for (name, grade) in zip(s, grades):\n        reversed_case_name = reverse_case(name)\n        letter_grade = assign_grade(grade)\n        result.append((reversed_case_name, letter_grade))\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/33": [{"task_id": "EvoEval/33", "solution": "\ndef roman_happiness(s):\n    if len(s) < 3:\n        return False\n    integer_value = roman_to_int(s)\n    if integer_value > 1000:\n        return False\n    for i in range(len(s) - 2):\n        if len(set(s[i:i + 3])) < 3:\n            return False\n    return integer_value", "base_status": "fail", "plus_status": null, "base_fail_tests": [["xliv"]], "plus_fail_tests": []}], "EvoEval/96": [{"task_id": "EvoEval/96", "solution": "\ndef common_pairs_with_zero_sum(l1: list, l2: list) -> bool:\n    \"\"\"\n    common_pairs_with_zero_sum takes two lists of integers as an input.\n    It first identifies the common elements between the two lists.\n    Then, it checks if there are two distinct elements in the common elements that sum to zero.\n    \n    Returns True if such pair exists and False otherwise.\n\n    >>> common_pairs_with_zero_sum([1, 3, 5, -3, 0], [0, -3, 1, 5, 2])\n    False\n    >>> common_pairs_with_zero_sum([1, 3, -2, 1], [2, 3, -2, 1])\n    False\n    >>> common_pairs_with_zero_sum([1, 2, 3, 7], [8, 9, 2, 1])\n    False\n    >>> common_pairs_with_zero_sum([2, 4, -5, 3, 5, 7], [-5, 4, 2, 3, 5, 7])\n    True\n    >>> common_pairs_with_zero_sum([1], [2])\n    False\n    \"\"\"\n    common_elements = set(l1) & set(l2)\n    for element in common_elements:\n        if -element in common_elements and element != 0:\n            return True\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/67": [{"task_id": "EvoEval/67", "solution": "\nfrom typing import List\n\ndef max_close_element_difference(numbers: List[float], threshold: float) -> float:\n    \"\"\"\n    Given a list of numbers and a threshold, find two elements that are closer to each other than the threshold and return their difference. If multiple pairs meet the criteria, return the maximum difference. If no such pairs exist, return 0.\n    >>> max_close_element_difference([1.0, 2.0, 3.0], 0.5)\n    0\n    >>> max_close_element_difference([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    0.2\n    >>> max_close_element_difference([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 5)\n    4\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    max_difference = 0\n    for i in range(len(sorted_numbers) - 1):\n        difference = sorted_numbers[i + 1] - sorted_numbers[i]\n        if difference < threshold and difference > max_difference:\n            max_difference = difference\n    return max_difference", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1000000000.0, 1000000001.0, 1000000002.0, 1000000003.0, 1000000004.0], 5]], "plus_fail_tests": []}], "EvoEval/42": [{"task_id": "EvoEval/42", "solution": "\ndef check_expression(expression: str) -> bool:\n    expressions = expression.split('><')\n    if expressions[0][0] != '<' or expressions[-1][-1] != '>':\n        return False\n    for (i, expr) in enumerate(expressions):\n        if i == 0 and expr[-1] != '>':\n            expr += '>'\n        elif i == len(expressions) - 1 and expr[0] != '<':\n            expr = '<' + expr\n        elif i != 0 and i != len(expressions) - 1:\n            expr = '<' + expr + '>'\n        fractions = expr[1:-1].split(',')\n        product = 1\n        for fraction in fractions:\n            (numerator, denominator) = map(int, fraction.split('/'))\n            product *= numerator / denominator\n        if product % 1 != 0:\n            return False\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [["><1/2,2/1><2/3,3/2>"]], "plus_fail_tests": []}], "EvoEval/15": [{"task_id": "EvoEval/15", "solution": "from typing import List\n\ndef balance_triples(operations: List[int]) -> bool:\n    balance = 0\n    zero_count = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return False\n        if balance == 0:\n            zero_count += 1\n    return zero_count >= 3", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/30": [{"task_id": "EvoEval/30", "solution": "\nfrom typing import List\n\ndef parse_music_simplify(x: str, music_string: str) -> List[bool]:\n    (numerator, denominator) = map(int, x.split('/'))\n    result = []\n    notes = music_string.split()\n    note_values = {'o': 4, 'o|': 2, '.|': 1}\n    for note in notes:\n        if note in note_values:\n            beats = note_values[note]\n        else:\n            beats = 0\n        if numerator * beats % denominator == 0:\n            result.append(True)\n        else:\n            result.append(False)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/37": [{"task_id": "EvoEval/37", "solution": "\nimport math\n\ndef minSubArraySumEvenOdd(nums):\n\n    def countEvenOddDigits(number):\n        (even_count, odd_count) = (0, 0)\n        number = abs(number)\n        if number == 0:\n            return (1, 0)\n        while number > 0:\n            digit = number % 10\n            if digit % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n            number //= 10\n        return (even_count, odd_count)\n    min_sum = math.inf\n    current_sum = 0\n    for num in nums:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    return countEvenOddDigits(min_sum)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/84": [{"task_id": "EvoEval/84", "solution": "\nfrom typing import List, Dict\n\ndef prefixes_histogram(string: str) -> Dict[str, Dict[str, int]]:\n    \"\"\" Given a string, return a dictionary where the keys are all the prefixes of the string,\n    and the values are dictionaries representing the histograms of the individual letters in each prefix. \n    The histogram dictionaries should contain the letter with the most repetition and the corresponding count.\n    If several letters have the same occurrence, include all of them.\n    \"\"\"\n    result = {}\n    for i in range(1, len(string) + 1):\n        prefix = string[:i]\n        histogram = Counter(prefix)\n        max_count = max(histogram.values(), default=0)\n        filtered_histogram = {letter: count for (letter, count) in histogram.items() if count == max_count}\n        result[prefix] = filtered_histogram\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["aba"]], "plus_fail_tests": []}], "EvoEval/97": [{"task_id": "EvoEval/97", "solution": "\ndef fib_max_triples(n):\n    fib = [0, 0, 1]\n    for i in range(3, n + 1):\n        next_value = fib[i - 1] + fib[i - 2] + fib[i - 3] + i * i - i + 1\n        fib.append(next_value)\n    count = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if (fib[i] + fib[j] + fib[k]) % 3 == 0:\n                    count += 1\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [[5]], "plus_fail_tests": []}], "EvoEval/21": [{"task_id": "EvoEval/21", "solution": "\nfrom typing import List\n\ndef base_change_prefixes(x: int, base: int) -> List[str]:\n    if x == 0:\n        return ['0']\n    digits = []\n    while x:\n        digits.append(str(x % base))\n        x //= base\n    base_repr = ''.join(reversed(digits))\n    prefixes = [base_repr[:i] for i in range(1, len(base_repr) + 1)]\n    return prefixes", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/3": [{"task_id": "EvoEval/3", "solution": "\nfrom typing import List\n\ndef sort_parentheses(lst: List[str]) -> str:\n    number_map = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n\n    def extract_number_word(s: str) -> str:\n        for word in number_map.keys():\n            if word in s:\n                return word\n        return ''\n    sorted_lst = sorted(lst, key=lambda x: number_map[extract_number_word(x)])\n    concatenated_string = ''.join(sorted_lst)\n\n    def is_balanced(s: str) -> bool:\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    return 'Yes' if is_balanced(concatenated_string) else 'No'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/68": [{"task_id": "EvoEval/68", "solution": "\ndef minOddDigitsProductSubArray(nums):\n\n    def productOfOddDigits(n):\n        product = 1\n        hasOdd = False\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 1:\n                product *= digit\n                hasOdd = True\n            n //= 10\n        return product if hasOdd else 0\n    minProductSum = float('inf')\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            currentProductSum = 0\n            for k in range(i, j + 1):\n                currentProductSum += productOfOddDigits(nums[k])\n            minProductSum = min(minProductSum, currentProductSum)\n    return minProductSum if minProductSum != float('inf') else 0", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/90": [{"task_id": "EvoEval/90", "solution": "\ndef vowels_in_dict_keys(input_dict):\n    if not input_dict:\n        return {}\n    if all((isinstance(key, str) for key in input_dict.keys())):\n        if not (all((key.islower() for key in input_dict.keys())) or all((key.isupper() for key in input_dict.keys()))):\n            return {}\n    else:\n        return {}\n\n    def count_vowels(key):\n        vowels = 'aeiou'\n        count = sum((1 for char in key if char.lower() in vowels))\n        if key.endswith('y') or key.endswith('Y'):\n            count += 1\n        return count\n    result_dict = {key: count_vowels(key) for key in input_dict.keys()}\n    return result_dict", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/27": [{"task_id": "EvoEval/27", "solution": "\ndef list_prime_exchange(lst1, lst2, x, y):\n    \"\"\"The function to determine if it's possible to make lst1 a list of only prime numbers\n    by exchanging elements with lst2.\"\"\"\n    combined_primes = [num for num in lst1 + lst2 if is_prime(num)]\n    prime_count_in_lst1 = sum((is_prime(num) for num in lst1))\n    non_prime_count_in_lst1 = len(lst1) - prime_count_in_lst1\n    if len(combined_primes) >= len(lst1):\n        return x\n    else:\n        return y", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 4], [6, 7, 8, 12], 30, 40]], "plus_fail_tests": []}], "EvoEval/23": [{"task_id": "EvoEval/23", "solution": "\ndef special_stone_factorial(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones. The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n\n    For each level, calculate the Brazilian factorial (defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!), \n    where n is the number of stones in the level.\n\n    Return the list of Brazilian factorials for each level.\n    \"\"\"\n    brazilian_factorials = []\n    current_stone_count = n\n    for _ in range(n):\n        brazilian_factorials.append(brazilian_factorial(current_stone_count))\n        if current_stone_count % 2 == 0:\n            current_stone_count += 1\n        else:\n            current_stone_count += 2\n    return brazilian_factorials", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1]], "plus_fail_tests": []}], "EvoEval/8": [{"task_id": "EvoEval/8", "solution": "\ndef correct_bracket_sequence_and_count(string: str, bracket: str) -> tuple:\n    \"\"\"\n    This function checks if a given string has correctly paired opening and closing brackets and \n    counts how many times a specific bracket appears in the string, including overlapping cases.\n    \n    The function takes a string of \"<\" and \">\" characters and a specific bracket (\"<\" or \">\") \n    as inputs, and returns a tuple with a boolean value and an integer. The boolean value represents \n    whether every opening bracket has a corresponding closing bracket. The integer represents the \n    count of the specific bracket in the string.\n\n    >>> correct_bracket_sequence_and_count('<<><>>', '<')\n    (True, 3)\n    >>> correct_bracket_sequence_and_count('<<><>>', '>')\n    (True, 3)\n    >>> correct_bracket_sequence_and_count('<>', '<')\n    (True, 1)\n    >>> correct_bracket_sequence_and_count('><<>', '>')\n    (False, 2)\n    >>> correct_bracket_sequence_and_count('', '>')\n    (True, 0)\n    \"\"\"\n    open_brackets = 0\n    bracket_count = 0\n    for char in string:\n        if char == bracket:\n            bracket_count += 1\n        if char == '<':\n            open_brackets += 1\n        elif char == '>':\n            open_brackets -= 1\n        if open_brackets < 0:\n            return (False, bracket_count)\n    return (open_brackets == 0, bracket_count)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["><<>", ">"]], "plus_fail_tests": []}], "EvoEval/99": [{"task_id": "EvoEval/99", "solution": "\ndef len_base_conversion(x: int, base: int) -> int:\n    \"\"\" \n    Convert the numerical base of input number x to base and \n    return the length of string representation after the conversion. \n    base numbers are less than 10.\n    \"\"\"\n    converted_str = ''\n    if x == 0:\n        return 1\n    while x > 0:\n        remainder = x % base\n        x = x // base\n        converted_str = str(remainder) + converted_str\n    return len(converted_str)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[0, 2]], "plus_fail_tests": []}], "EvoEval/1": [{"task_id": "EvoEval/1", "solution": "def round_and_flip(value: str) -> str:\n    match = re.match('([-+]?\\\\d*\\\\.?\\\\d+)([a-zA-Z]+)', value)\n    if not match:\n        return 'Invalid input'\n    (number_part, string_part) = match.groups()\n    number = float(number_part)\n    rounded_number = int(math.copysign(math.ceil(abs(number)), number))\n    flipped_string = string_part.swapcase()\n    return f'{rounded_number} {flipped_string}'", "base_status": "fail", "plus_status": null, "base_fail_tests": [["15.3ABC"]], "plus_fail_tests": []}], "EvoEval/11": [{"task_id": "EvoEval/11", "solution": "\ndef planet_vowel_count(planet1, planet2):\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return 0\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    if index1 > index2:\n        (index1, index2) = (index2, index1)\n    vowel_count = 0\n    for planet in planets[index1 + 1:index2]:\n        for char in planet.lower():\n            if char in 'aeiou' or (char == 'y' and planet.endswith('y')):\n                vowel_count += 1\n    return vowel_count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/95": [{"task_id": "EvoEval/95", "solution": "\nfrom typing import List\n\ndef filter_sort_strings(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain a given substring and have an even length. \n    Return the resulted list in ascending order by the length of each word. \n    If two words have the same length, sort the list alphabetically.\n    The list may contain duplicate strings.\n    \n    For example:\n    >>> filter_sort_strings([], 'a')\n    []\n    >>> filter_sort_strings(['abc', 'bacd', 'cd', 'array'], 'a')\n    ['bacd']\n    >>> filter_sort_strings(['abc', 'bacd', 'cd', 'array', 'play'], 'a')\n    ['bacd', 'play']\n    \"\"\"\n    filtered_strings = [s for s in strings if substring in s and len(s) % 2 == 0]\n    sorted_filtered_strings = sorted(filtered_strings, key=lambda x: (len(x), x))\n    return sorted_filtered_strings", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/29": [{"task_id": "EvoEval/29", "solution": "def largest_prime_factor_or_value(n, x, y):\n    \"\"\"A program which should return the largest prime factor of n if n is not a prime number, should return the value of x if n is a prime number and y if n is 1.\"\"\"\n    if n == 1:\n        return y\n    elif is_prime(n):\n        return x\n    else:\n        return largest_prime_factor(n)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[60, 34, 12]], "plus_fail_tests": []}], "EvoEval/46": [{"task_id": "EvoEval/46", "solution": "\ndef get_max_even_positive(l: list):\n    positive_evens = [num for num in l if num > 0 and num % 2 == 0]\n    if not positive_evens:\n        return -1\n    return max(positive_evens)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/43": [{"task_id": "EvoEval/43", "solution": "\ndef sorted_fib4_sequence(n: int):\n    if n == 0:\n        return []\n    sequence = [0, 0, 2, 0][:n]\n    for i in range(4, n):\n        next_element = sequence[i - 1] + sequence[i - 2] + sequence[i - 3] + sequence[i - 4]\n        sequence.append(next_element)\n    if (sequence[0] + sequence[-1]) % 2 == 0:\n        sequence.sort(reverse=True)\n    else:\n        sequence.sort()\n    return sequence", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/39": [{"task_id": "EvoEval/39", "solution": "def smallest_change_and_sum(arr, x, y):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n    After finding the minimum changes, add the value of x and y to it.\n\n    For example:\n    smallest_change_and_sum([1, 2, 3, 5, 4, 7, 9, 6], 2, 3) == 9\n    smallest_change_and_sum([1, 2, 3, 4, 3, 2, 2], 1, 2) == 4\n    smallest_change_and_sum([1, 2, 3, 2, 1], 3, 2) == 5\n    \"\"\"\n    min_changes = 0\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] != arr[right]:\n            min_changes += 1\n        left += 1\n        right -= 1\n    return min_changes + x + y", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/56": [{"task_id": "EvoEval/56", "solution": "def product_of_odd_prime_factors(n):\n    \"\"\"Given a positive integer n, return the product of its unique odd prime factors.\n    If all prime factors are even, return 0.\n    Assume n > 1 and is not a prime.\n    For example:\n    product_of_odd_prime_factors(9) == 3\n    product_of_odd_prime_factors(15) == 15\n    product_of_odd_prime_factors(20) == 5\n    product_of_odd_prime_factors(32) == 0\n    \"\"\"\n\n    def is_prime(num):\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    product = 1\n    found_odd_prime = False\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            if i % 2 != 0:\n                found_odd_prime = True\n                product *= i\n    return product if found_odd_prime else 0", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/93": [{"task_id": "EvoEval/93", "solution": "\ndef prime_vowel(string):\n    vowels = 'aeiouAEIOU'\n    if not is_prime(len(string)):\n        return ''\n    for i in range(len(string) - 2, 0, -1):\n        if string[i] in vowels and (not string[i + 1] in vowels) and (not string[i - 1] in vowels):\n            return string[i]\n    return ''", "base_status": "fail", "plus_status": null, "base_fail_tests": [["ab"]], "plus_fail_tests": []}], "EvoEval/41": [{"task_id": "EvoEval/41", "solution": "\ndef shifted_upper_count(s, shift):\n    uppercase_vowels = 'AEIOU'\n    if shift > len(s):\n        s = s[::-1]\n    shifted_s = ''\n    for char in s:\n        shifted_char = chr((ord(char) + shift) % 128)\n        shifted_s += shifted_char\n    count = 0\n    for i in range(0, len(shifted_s), 2):\n        if shifted_s[i] in uppercase_vowels:\n            count += 1\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", 52]], "plus_fail_tests": []}], "EvoEval/49": [{"task_id": "EvoEval/49", "solution": "\ndef modp_count(arr, n: int, p: int):\n    \"\"\"\n    Write a function modp_count which takes an array of integers and two integers n and p as inputs.\n    The function should first calculate 2^n modulo p. \n    It then counts the number of elements in the array which has a sum of digits > the result of 2^n modulo p.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> modp_count([], 2, 5) == 0\n    >>> modp_count([-1, 11, -11], 4, 5) == 1\n    >>> modp_count([1, 1, 2], 0, 101) == 1\n    >>> modp_count([12, 15, 20], 11, 3) == 2\n    \"\"\"\n    mod_result = 2 ** n % p\n\n    def sum_of_digits(num):\n        if num >= 0:\n            return sum((int(digit) for digit in str(num)))\n        else:\n            return sum((int(digit) for digit in str(num)[1:])) - 2 * int(str(num)[1])\n    count = 0\n    for number in arr:\n        if sum_of_digits(number) > mod_result:\n            count += 1\n    return count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/9": [{"task_id": "EvoEval/9", "solution": "def planet_to_roman_distance(planet1, planet2):\n    planet_positions = {'mercury': 1, 'venus': 2, 'earth': 3, 'mars': 4, 'jupiter': 5, 'saturn': 6, 'uranus': 7, 'neptune': 8}\n    roman_numerals = {1: 'i', 2: 'ii', 3: 'iii', 4: 'iv', 5: 'v', 6: 'vi', 7: 'vii', 8: 'viii'}\n    planet1 = planet1.lower()\n    planet2 = planet2.lower()\n    if planet1 not in planet_positions or planet2 not in planet_positions:\n        return {}\n    pos1 = planet_positions[planet1]\n    pos2 = planet_positions[planet2]\n    start_pos = min(pos1, pos2) + 1\n    end_pos = max(pos1, pos2)\n    planets_between = {planet: roman_numerals[position] for (planet, position) in planet_positions.items() if start_pos <= position < end_pos}\n    return planets_between", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Uranus", 1]], "plus_fail_tests": []}], "EvoEval/54": [{"task_id": "EvoEval/54", "solution": "\nimport math\n\ndef max_sum_of_prime_subarray(nums):\n    \"\"\"\n    Given an array of integers nums, find the maximum sum of any non-empty sub-array\n    of prime nums. If no prime subarray exists, return 0.\n    \"\"\"\n    max_sum = 0\n    current_sum = 0\n    for num in nums:\n        if is_prime(num):\n            current_sum += num\n            max_sum = max(max_sum, current_sum)\n        else:\n            current_sum = 0\n    return max_sum", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[2, 3, 5, 7, 11, 13]]], "plus_fail_tests": []}], "EvoEval/77": [{"task_id": "EvoEval/77", "solution": "\ndef mixed_solution(arr):\n\n    def sum_of_digits(n):\n        \"\"\"\n        Helper function to calculate the sum of digits of a number.\n        Takes into account the sign of the first digit for negative numbers.\n        \"\"\"\n        if n < 0:\n            return -int(str(n)[1]) + sum((int(digit) for digit in str(n)[2:]))\n        else:\n            return sum((int(digit) for digit in str(n)))\n    total = 0\n    for i in range(0, len(arr), 2):\n        if arr[i] % 2 != 0 and sum_of_digits(arr[i]) > 0:\n            total += arr[i]\n    return total", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/7": [{"task_id": "EvoEval/7", "solution": "\ndef sum_square_cube_to_n(n: int) -> int:\n    \"\"\"\n    This function takes an integer n. The function generates a list of integers from 1 to n inclusive. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n\n    Examples:\n    For n = 3 the output should be 12\n    For n = 1 the output should be 1\n    For n = 5 the output should be 81\n    For n = 10 the output should be 727\n    \"\"\"\n    total_sum = 0\n    for i in range(1, n + 1):\n        if i % 3 == 0:\n            total_sum += i ** 2\n        elif i % 4 == 0:\n            total_sum += i ** 3\n        else:\n            total_sum += i\n    return total_sum", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/73": [{"task_id": "EvoEval/73", "solution": "\nfrom typing import List\nfrom fractions import Fraction\n\ndef filter_and_simplify(fractions: List[str], n: str) -> List[bool]:\n    \"\"\" Filter an input list of fractions only for ones that, when multiplied by n, simplify to a whole number. Both, fractions in the list and n, are string representation of a fraction, and have the following format, <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that the fractions, and n are valid fractions, and do not have zero as denominator.\n\n    filter_and_simplify([\"1/5\", \"1/6\", \"7/10\"], \"5/1\") = [True, False, False]\n    filter_and_simplify([\"1/3\", \"2/1\", \"3/2\"], \"2/1\") = [False, True, True]\n    \"\"\"\n    n_fraction = Fraction(n)\n    result = []\n    for frac_str in fractions:\n        frac = Fraction(frac_str)\n        simplified = frac * n_fraction\n        result.append(simplified.denominator == 1)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/60": [{"task_id": "EvoEval/60", "solution": "\ndef smallest_even_triple(arr, n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    smallest_sum = float('inf')\n    smallest_triple = None\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    if a[i] < smallest_sum:\n                        smallest_sum = a[i]\n                        smallest_triple = (a[i], a[j], a[k])\n    if smallest_triple:\n        arr.append(smallest_triple[0])\n    smallest_even = float('inf')\n    index_of_smallest_even = -1\n    for (i, value) in enumerate(arr):\n        if value % 2 == 0 and value < smallest_even:\n            smallest_even = value\n            index_of_smallest_even = i\n    if smallest_even != float('inf'):\n        return [smallest_even, index_of_smallest_even]\n    else:\n        return []", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[4, 2, 3], 1]], "plus_fail_tests": []}], "EvoEval/64": [{"task_id": "EvoEval/64", "solution": "\ndef modp_prime_numbers(n: int, p: int) -> list:\n    \"\"\"Implement a function that takes two non-negative integers n and p, first calculate 2^n modulo p, \n    then return an array of the first calculated modulo result integers that are prime numbers and less than the calculated modulo result.\n    If no prime numbers are found within the range, return an empty array.\"\"\"\n    mod_result = pow(2, n, p)\n    primes = [i for i in range(2, mod_result) if is_prime(i)]\n    return primes", "base_status": "fail", "plus_status": null, "base_fail_tests": [[3, 11]], "plus_fail_tests": []}], "EvoEval/87": [{"task_id": "EvoEval/87", "solution": "\ndef match_and_remove_unbalanced(text):\n    open_parentheses = 0\n    for char in text:\n        if char == '(':\n            open_parentheses += 1\n        elif char == ')':\n            if open_parentheses > 0:\n                open_parentheses -= 1\n            else:\n                open_parentheses = -1\n                break\n    if open_parentheses == 0:\n        return text\n    else:\n        vowels = 'aeiouAEIOU'\n        return ''.join([char for char in text if char not in vowels])", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/17": [{"task_id": "EvoEval/17", "solution": "\ndef fibfib_search(n: int, lst: list) -> int:\n    \"\"\"\n    Implement a function that computes the n-th element of the FibFib sequence as defined by:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n    \n    The function should then evaluate a non-empty list of positive integers, and return the greatest \n    integer in the list that is greater than zero, and has a frequency equal to or greater than the value\n    of the calculated n-th FibFib element. The frequency of an integer is the number of times it appears \n    in the list.\n\n    If no such value exists, return -1.\n\n    Examples:\n        fibfib_search(5, [4, 1, 2, 2, 3, 1, 1, 1, 1]) == 1\n        fibfib_search(3, [1, 2, 2, 3, 3, 3, 4, 4, 4]) == 4\n        fibfib_search(6, [5, 5, 4, 4, 4, 1, 1, 1, 1, 1]) == -1\n    \"\"\"\n    fibfib_n = fibfib(n)\n    frequency_dict = {}\n    for element in lst:\n        if element > 0:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    result = -1\n    for (key, value) in frequency_dict.items():\n        if value >= fibfib_n and key > result:\n            result = key\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[6, [5, 5, 4, 4, 4, 1, 1, 1, 1, 1]]], "plus_fail_tests": []}], "EvoEval/5": [{"task_id": "EvoEval/5", "solution": "\nfrom typing import List\n\ndef sort_and_check(numbers: List[float], threshold: float) -> List[float]:\n    \"\"\"\n    Given an array of numbers, check if any two numbers in the array are closer to each other \n    than the given threshold. If yes, sort the array according to the following rules:\n\n    - If the sum of the first and last numbers in the array is even, sort the array in descending order.\n    - If the sum of the first and last numbers in the array is odd, sort the array in ascending order.\n    \n    If no two numbers are closer than the threshold, return the array as it is.\n    \n    Note: Consider the sum as even or odd after rounding off to the nearest integer.\n\n    Examples:\n    * sort_and_check([1.0, 2.0, 3.0], 0.5) => [1.0, 2.0, 3.0]\n    * sort_and_check([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) => [1.0, 2.0, 2.8, 3.0, 4.0, 5.0]\n    * sort_and_check([4.0, 2.0, 3.0, 0.0], 2.0) => [4.0, 3.0, 2.0, 0.0]\n    \"\"\"\n    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                sum_first_last = round(numbers[0] + numbers[-1])\n                if sum_first_last % 2 == 0:\n                    return sorted(numbers, reverse=True)\n                else:\n                    return sorted(numbers)\n    return numbers", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/28": [{"task_id": "EvoEval/28", "solution": "\ndef grade_with_same_chars(grades: list, s0: str, s1: str):\n    if sorted(s0) != sorted(s1):\n        return []\n\n    def gpa_to_grade(gpa):\n        if gpa == 4.0:\n            return 'A+'\n        elif gpa > 3.7:\n            return 'A'\n        elif gpa > 3.3:\n            return 'A-'\n        elif gpa > 3.0:\n            return 'B+'\n        elif gpa > 2.7:\n            return 'B'\n        elif gpa > 2.3:\n            return 'B-'\n        elif gpa > 2.0:\n            return 'C+'\n        elif gpa > 1.7:\n            return 'C'\n        elif gpa > 1.3:\n            return 'C-'\n        elif gpa > 1.0:\n            return 'D+'\n        elif gpa > 0.7:\n            return 'D'\n        elif gpa > 0.0:\n            return 'D-'\n        else:\n            return 'E'\n    return [gpa_to_grade(gpa) for gpa in grades]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[4.0, 3, 1.7, 2, 3.5], "aaabcd", "dddcba"]], "plus_fail_tests": []}], "EvoEval/51": [{"task_id": "EvoEval/51", "solution": "\ndef modify_and_compare(a, b):\n\n    def modify(x):\n        if isinstance(x, str):\n            if any((c.isalpha() for c in x)):\n                return x.swapcase()\n            else:\n                return x[::-1]\n        return x\n\n    def is_real_number(x):\n        try:\n            if isinstance(x, str):\n                x = x.replace(',', '.')\n            float(x)\n            return True\n        except ValueError:\n            return False\n    a_modified = modify(a)\n    b_modified = modify(b)\n    if is_real_number(a_modified) and is_real_number(b_modified):\n        a_num = float(a_modified.replace(',', '.')) if isinstance(a_modified, str) else a_modified\n        b_num = float(b_modified.replace(',', '.')) if isinstance(b_modified, str) else b_modified\n        if a_num > b_num:\n            return a\n        elif b_num > a_num:\n            return b\n        else:\n            return None\n    else:\n        return b", "base_status": "fail", "plus_status": null, "base_fail_tests": [["AB", "ab"]], "plus_fail_tests": []}], "EvoEval/69": [{"task_id": "EvoEval/69", "solution": "def sorted_happy_strings(lst):\n    \"\"\"Filter, sort, and return happy strings from the list.\"\"\"\n    filtered_lst = [s for s in lst if is_happy(s) and len(s) % 2 == 0]\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    return sorted_lst", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["abcd", "aaa", "abc", "abccba", "cd"]]], "plus_fail_tests": []}], "EvoEval/66": [{"task_id": "EvoEval/66", "solution": "\ndef find_max_triple_sum(x, y, n):\n    largest_even = -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            largest_even = num\n            break\n    if largest_even == -1:\n        return -1\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    a.sort(reverse=True)\n    max_sum = -1\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    max_sum = a[i] + a[j] + a[k]\n                    break\n            if max_sum != -1:\n                break\n        if max_sum != -1:\n            break\n    if max_sum == -1:\n        return -1\n    return max_sum + largest_even", "base_status": "fail", "plus_status": null, "base_fail_tests": [[10, 15, 20]], "plus_fail_tests": []}], "EvoEval/92": [{"task_id": "EvoEval/92", "solution": "\ndef get_common_max_triples(n, l1: list):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    common_elements = sorted(set(a).intersection(l1))\n    multiples_of_3 = [x for x in common_elements if x % 3 == 0]\n    if not multiples_of_3:\n        return (common_elements, 0)\n    triples_count = 0\n    for i in range(len(a) - 2):\n        for j in range(i + 1, len(a) - 1):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    triples_count += 1\n    return (common_elements, triples_count)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/36": [{"task_id": "EvoEval/36", "solution": "\ndef mod_shift_sort(arr, n: int, p: int) -> bool:\n    if not arr:\n        return True\n    limit = pow(2, n) % p\n    sorted_arr = sorted(arr)\n    for i in range(len(arr)):\n        shifted_arr = arr[-i:] + arr[:-i]\n        if shifted_arr == sorted_arr:\n            if i <= limit:\n                return True\n            else:\n                return False\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/79": [{"task_id": "EvoEval/79", "solution": "\ndef happy_case_string(s):\n\n    def is_happy(s):\n        if len(s) < 3:\n            return False\n        for i in range(len(s) - 2):\n            if s[i] == s[i + 1] or s[i + 1] == s[i + 2] or s[i] == s[i + 2]:\n                return False\n        return True\n\n    def reverse_case(s):\n        return ''.join([c.upper() if c.islower() else c.lower() for c in s])\n\n    def contains_letter(s):\n        return any((c.isalpha() for c in s))\n    if is_happy(s) and contains_letter(s):\n        return reverse_case(s)\n    else:\n        return s[::-1]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/86": [{"task_id": "EvoEval/86", "solution": "\ndef evaluate_common_expressions(operators, operand_lists):\n    common_operands = set(operand_lists[0])\n    for operand_list in operand_lists[1:]:\n        common_operands.intersection_update(operand_list)\n    common_operands = sorted(common_operands)\n    if not common_operands:\n        return None\n    expression = str(common_operands[0])\n    for (i, operand) in enumerate(common_operands[1:]):\n        if i < len(operators):\n            expression += f' {operators[i]} {operand}'\n        else:\n            break\n    result = eval(expression)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/4": [{"task_id": "EvoEval/4", "solution": "\ndef largest_prime_divisor_digit_sum(lst: list) -> int:\n    \"\"\"Find the largest prime divisor (or the number itself if prime) with the largest digit sum.\"\"\"\n    largest_prime = 0\n    for number in lst:\n        prime_divisor = largest_prime_divisor(number)\n        if prime_divisor > largest_prime:\n            largest_prime = prime_divisor\n    return digit_sum(largest_prime)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[84, 91, 97, 101, 105]]], "plus_fail_tests": []}], "EvoEval/48": [{"task_id": "EvoEval/48", "solution": "\nfrom typing import List\n\ndef prime_prefixed_strings(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Write a function that takes a list of strings and a prefix, it should return a list of \n    strings from the input list which start with the given prefix and their lengths are prime numbers.\n    \n    Examples\n    prime_prefixed_strings([], 'a') == []\n    prime_prefixed_strings(['abc', 'bcd', 'cde', 'array'], 'a') == ['abc', 'array']\n    prime_prefixed_strings(['abcd', 'bcd', 'cde', 'array'], 'a') == ['array']\n    prime_prefixed_strings(['apple', 'avocado', 'banana', 'apricot'], 'a') == ['apple', 'avocado', 'apricot']\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix) and is_prime(len(s))]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["apple", "avocado", "banana", "apricot"], "a"]], "plus_fail_tests": []}], "EvoEval/45": [{"task_id": "EvoEval/45", "solution": "\nfrom typing import List, Tuple\n\ndef primes_sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the prime numbers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1. Non-prime numbers should be ignored.\n    \"\"\"\n    prime_sum = 0\n    prime_product = 1\n    for number in numbers:\n        if is_prime(number):\n            prime_sum += number\n            prime_product *= number\n    return (prime_sum, prime_product)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[5, 25]]], "plus_fail_tests": []}], "EvoEval/59": [{"task_id": "EvoEval/59", "solution": "def odd_count_base_change(lst, base):\n\n    def digit_to_base(digit, base):\n        \"\"\"Convert a single digit to the given base and return it as a string.\"\"\"\n        if digit < base:\n            return str(digit)\n        else:\n            return digit_to_base(digit // base, base) + str(digit % base)\n\n    def count_odd_digits_in_base(s, base):\n        \"\"\"Convert each digit in the string to the given base and count the odd digits.\"\"\"\n        count = 0\n        for char in s:\n            converted = digit_to_base(int(char), base)\n            count += sum((1 for c in converted if c in '13579'))\n        return count\n    result = []\n    for s in lst:\n        odd_count = count_odd_digits_in_base(s, base)\n        output_str = f'the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.'\n        result.append(output_str)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/18": [{"task_id": "EvoEval/18", "solution": "\ndef min_triplets_sum(nums: list):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array of size three. \n\n    If no such sub-array exists, return 0. A sub-array is a contiguous part of an array.\n\n    Examples:\n    min_triplets_sum([2, 3, 4, 1, -7, 4]) == -2   # The sub-array is [1, -7, 4]\n    min_triplets_sum([1, 2, 3, -6, 5, 1, 2]) == -1  # The sub-array is [2, 3, -6]\n    min_triplets_sum([2, 3]) == 0   # No such sub-array exists\n    min_triplets_sum([-1, -2, -3]) == -6   # The sub-array is [-1, -2, -3]\n    \"\"\"\n    if len(nums) < 3:\n        return 0\n    min_sum = float('inf')\n    for i in range(len(nums) - 2):\n        current_sum = nums[i] + nums[i + 1] + nums[i + 2]\n        if current_sum < min_sum:\n            min_sum = current_sum\n    return min_sum if min_sum != float('inf') else 0", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/53": [{"task_id": "EvoEval/53", "solution": "\ndef hex_grade_calculator(grades):\n    gpa_to_hex = [(4.0, 'F'), (3.7, 'E'), (3.3, 'D'), (3.0, 'C'), (2.7, 'B'), (2.3, 'A'), (2.0, '9'), (1.7, '8'), (1.3, '7'), (1.0, '6'), (0.7, '5'), (0.0, '4'), (0.0, '3')]\n    prime_hex_grades = ['D', 'B', '7', '5', '3']\n\n    def find_hex_grade(gpa):\n        for (threshold, hex_grade) in gpa_to_hex:\n            if gpa > threshold:\n                return hex_grade\n        return '3'\n    hex_grades = [find_hex_grade(gpa) for gpa in grades]\n    prime_grade_count = sum((1 for grade in hex_grades if grade in prime_hex_grades))\n    return prime_grade_count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/12": [{"task_id": "EvoEval/12", "solution": "\ndef grade_students(student_info, n):\n\n    def get_grade(gpa):\n        if gpa >= 4.0:\n            return 'A+'\n        elif gpa > 3.7:\n            return 'A'\n        elif gpa > 3.3:\n            return 'A-'\n        elif gpa > 3.0:\n            return 'B+'\n        elif gpa > 2.7:\n            return 'B'\n        elif gpa > 2.3:\n            return 'B-'\n        elif gpa > 2.0:\n            return 'C+'\n        elif gpa > 1.7:\n            return 'C'\n        elif gpa > 1.3:\n            return 'C-'\n        elif gpa > 1.0:\n            return 'D+'\n        elif gpa > 0.7:\n            return 'D'\n        elif gpa > 0.0:\n            return 'D-'\n        else:\n            return 'E'\n\n    def bump_grade(grade):\n        grades = ['A+', 'A', 'A-', 'B+', 'B', 'B-', 'C+', 'C', 'C-', 'D+', 'D', 'D-', 'E']\n        if grade in grades and grade != 'A+':\n            return grades[grades.index(grade) - 1]\n        return grade\n\n    def count_consonants(name):\n        consonants = 'bcdfghjklmnpqrstvwxyz'\n        return sum((1 for char in name.lower() if char in consonants))\n    result = []\n    for student in student_info:\n        name = student['name']\n        gpa = student['GPA']\n        grade = get_grade(gpa)\n        if count_consonants(name) == n:\n            grade = bump_grade(grade)\n        result.append({'name': name, 'grade': grade})\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/80": [{"task_id": "EvoEval/80", "solution": "def cyclic_encode_delete(s: str, c: str) -> tuple:\n    encoded = ''\n    for i in range(0, len(s), 3):\n        if i + 2 < len(s):\n            encoded += s[i + 1:i + 3] + s[i]\n        else:\n            encoded += s[i:]\n    for char in c:\n        encoded = encoded.replace(char, '')\n\n    def is_palindrome(string):\n        return string == string[::-1]\n    if is_palindrome(encoded):\n        return (encoded, True)\n    else:\n        decoded = ''\n        i = 0\n        while i < len(encoded):\n            if i % 3 == 0 and i + 2 < len(encoded):\n                decoded += encoded[i + 2]\n                decoded += encoded[i:i + 2]\n            else:\n                decoded += encoded[i]\n            i += 1\n        return (decoded, False)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["abcdef", "b"]], "plus_fail_tests": []}], "EvoEval/0": [{"task_id": "EvoEval/0", "solution": "def compare_happiness(a, b):\n    a_happy = is_happy(a)\n    b_happy = is_happy(b)\n    if not a_happy and (not b_happy):\n        return None\n    if a_happy and (not b_happy):\n        return a\n    if b_happy and (not a_happy):\n        return b\n    a_float = float(a.replace(',', '.'))\n    b_float = float(b.replace(',', '.'))\n    if a_float > b_float:\n        return a\n    elif b_float > a_float:\n        return b\n    else:\n        return None", "base_status": "fail", "plus_status": null, "base_fail_tests": [["1,234", "1,112"]], "plus_fail_tests": []}], "EvoEval/6": [{"task_id": "EvoEval/6", "solution": "\ndef pile_median(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the median number of stones in all levels in the pile.\n\n    You should return the answer as a float if the number of levels is even,\n    and as an integer if the number of levels is odd.\n\n    Examples:\n    >>> pile_median(3)\n    5\n    >>> pile_median(4)\n    7.0\n    \"\"\"\n    stones = []\n    current_stones = n\n    for _ in range(n):\n        stones.append(current_stones)\n        if current_stones % 2 == 0:\n            current_stones += 2\n        else:\n            current_stones += 2\n    stones.sort()\n    mid = len(stones) // 2\n    if len(stones) % 2 == 0:\n        return (stones[mid - 1] + stones[mid]) / 2.0\n    else:\n        return stones[mid]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/58": [{"task_id": "EvoEval/58", "solution": "def max_freq_and_sum_check(lst, a, b):\n    freq = {}\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    max_freq = -1\n    for (num, count) in freq.items():\n        if num <= count and num > max_freq:\n            max_freq = num\n    if max_freq != -1:\n        if a == max_freq + b or b == max_freq + a:\n            return (max_freq, True)\n    return (max_freq, False)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/25": [{"task_id": "EvoEval/25", "solution": "\nfrom typing import List, Tuple\n\ndef sum_product_triples(n: int) -> Tuple[int, int]:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    sum_first_elements = 0\n    product_first_elements = 1\n    found_valid_triple = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    if not found_valid_triple:\n                        sum_first_elements = a[i]\n                        product_first_elements = a[i]\n                        found_valid_triple = True\n                    else:\n                        sum_first_elements += a[i]\n                        product_first_elements *= a[i]\n    if not found_valid_triple:\n        sum_first_elements = 0\n        product_first_elements = 1\n    return (sum_first_elements, product_first_elements)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/65": [{"task_id": "EvoEval/65", "solution": "\ndef modp_largest_divisor(n: int, p: int) -> int:\n    \"\"\"Return the largest number smaller than 'p' which divides (2^n modulo p) evenly. \n    If no such number exists, return 1.\n    \n    >>> modp_largest_divisor(3, 5)\n    3\n    >>> modp_largest_divisor(1101, 101)\n    2\n    >>> modp_largest_divisor(0, 101)\n    1\n    >>> modp_largest_divisor(3, 11)\n    8\n    \"\"\"\n    mod_result = pow(2, n, p)\n    if mod_result <= 1:\n        return 1\n    for divisor in range(p - 1, 1, -1):\n        if mod_result % divisor == 0:\n            return divisor\n    return 1", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/72": [{"task_id": "EvoEval/72", "solution": "\nfrom typing import List\nfrom math import factorial\n\ndef special_close_factorials(numbers: List[int], threshold: int) -> bool:\n    \"\"\" \n    Check if in given list of numbers, are any two special factorials closer to each other than \n    given threshold. The special factorial (Brazilian factorial) is defined as n! * (n-1)! * (n-2)! * ... * 1! \n    where n > 0.\n\n    For example:\n    >>> special_close_factorials([2, 3], 10)\n    False\n    >>> special_close_factorials([1, 2, 3, 4], 100)\n    True\n    \"\"\"\n\n    def special_factorial(n: int) -> int:\n        result = 1\n        for i in range(1, n + 1):\n            result *= factorial(i)\n        return result\n    special_factorials = [special_factorial(n) for n in numbers]\n    for i in range(len(special_factorials)):\n        for j in range(i + 1, len(special_factorials)):\n            if abs(special_factorials[i] - special_factorials[j]) < threshold:\n                return True\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}]}}