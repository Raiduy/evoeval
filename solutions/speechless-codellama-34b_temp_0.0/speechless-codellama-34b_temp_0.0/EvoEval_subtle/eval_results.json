{"eval": {"EvoEval/44": [{"task_id": "EvoEval/44", "solution": "\n\ndef change_base(x: int, base: int) -> int:\n    \"\"\"Change numerical base of input number x to base.\n    return integer representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    22\n    >>> change_base(8, 2)\n    1000\n    >>> change_base(7, 2)\n    111\n    \"\"\"\n    return int(str(x), base)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[8, 3]], "plus_fail_tests": []}], "EvoEval/35": [{"task_id": "EvoEval/35", "solution": "\ndef min_element(l: list):\n    \"\"\"Return minimum element in the list.\n    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n    return min(l)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/19": [{"task_id": "EvoEval/19", "solution": "\nfrom typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    word_to_num = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    words = numbers.split()\n    nums = [word_to_num[word] for word in words]\n    nums.sort(reverse=True)\n    sorted_words = [str(num) for num in nums]\n    sorted_numbers = ' '.join(sorted_words)\n    return sorted_numbers", "base_status": "fail", "plus_status": null, "base_fail_tests": [["three"]], "plus_fail_tests": []}], "EvoEval/55": [{"task_id": "EvoEval/55", "solution": "\ndef fib(n: int) -> int:\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        (a, b) = (0, 1)\n        for _ in range(n - 1):\n            (a, b) = (b, a + b)\n        return b", "base_status": "fail", "plus_status": null, "base_fail_tests": [[10]], "plus_fail_tests": []}], "EvoEval/16": [{"task_id": "EvoEval/16", "solution": "\ndef count_distinct_characters(string: str) -> int:\n    distinct_chars = set(string)\n    return len(distinct_chars)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/57": [{"task_id": "EvoEval/57", "solution": "\n\ndef monotonic(l: list):\n    if not l:\n        return False\n    elif len(l) == 1:\n        return True\n    else:\n        diff = l[1] - l[0]\n        for i in range(2, len(l)):\n            if (l[i] - l[i - 1]) * diff < 0:\n                return False\n        return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 1, 1, 2, 1, 1, 1]]], "plus_fail_tests": []}], "EvoEval/40": [{"task_id": "EvoEval/40", "solution": "\ndef triples_sum_to_ten(l: list):\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 10:\n                    return True\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/89": [{"task_id": "EvoEval/89", "solution": "\ndef encrypt(s):\n    encrypted_string = ''\n    for char in s:\n        if char.isalpha():\n            shift = 4\n            if char.islower():\n                encrypted_string += chr((ord(char) - 97 + shift) % 26 + 97)\n            else:\n                encrypted_string += chr((ord(char) - 65 + shift) % 26 + 65)\n        else:\n            encrypted_string += char\n    return encrypted_string", "base_status": "fail", "plus_status": null, "base_fail_tests": [["hi"]], "plus_fail_tests": []}], "EvoEval/24": [{"task_id": "EvoEval/24", "solution": "\ndef smallest_divisor(n: int) -> int:\n    for i in range(2, n + 1):\n        if n % i == 0:\n            return i\n    return n", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/82": [{"task_id": "EvoEval/82", "solution": "\ndef prime_length(string):\n    \"\"\"Return True if the length of the string is a prime number, False otherwise.\"\"\"\n    string = string.replace(' ', '')\n    return is_prime(len(string))", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Hello"]], "plus_fail_tests": []}], "EvoEval/65": [{"task_id": "EvoEval/65", "solution": "\ndef circular_shift(x, shift):\n    digits = str(x)\n    if shift > len(digits):\n        return digits[::-1]\n    else:\n        return digits[shift:] + digits[:shift]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/92": [{"task_id": "EvoEval/92", "solution": "\ndef any_int(x, y, z):\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        if abs(x) + abs(y) == z or abs(x) + abs(z) == y or abs(y) + abs(z) == x:\n            return True\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/31": [{"task_id": "EvoEval/31", "solution": "\n\ndef is_prime(n):\n    if n < 2:\n        return 'Invalid Input'\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/81": [{"task_id": "EvoEval/81", "solution": "\ndef numerical_letter_grade(grades):\n    letter_grades = []\n    for grade in grades:\n        if grade == 4.0:\n            letter_grades.append('A+')\n        elif grade > 3.7:\n            letter_grades.append('A')\n        elif grade > 3.3:\n            letter_grades.append('A-')\n        elif grade > 3.0:\n            letter_grades.append('B+')\n        elif grade > 2.7:\n            letter_grades.append('B')\n        elif grade > 2.3:\n            letter_grades.append('B-')\n        elif grade > 2.0:\n            letter_grades.append('C+')\n        elif grade > 1.7:\n            letter_grades.append('C')\n        elif grade > 1.3:\n            letter_grades.append('C-')\n        elif grade > 1.0:\n            letter_grades.append('D+')\n        elif grade > 0.7:\n            letter_grades.append('D')\n        elif grade > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[4.0, 3, 1.7, 2, 3.5]]], "plus_fail_tests": []}], "EvoEval/75": [{"task_id": "EvoEval/75", "solution": "\ndef is_multiply_prime(a):\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89]\n    for i in range(len(primes)):\n        for j in range(i + 1, len(primes)):\n            for k in range(j + 1, len(primes)):\n                for l in range(k + 1, len(primes)):\n                    if primes[i] * primes[j] * primes[k] * primes[l] == a:\n                        return True\n    return False", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1019179]], "plus_fail_tests": []}], "EvoEval/70": [{"task_id": "EvoEval/70", "solution": "\ndef strange_sort_list(lst):\n    lst.sort()\n    result = []\n    while lst:\n        result.append(lst.pop())\n        if lst:\n            result.append(lst.pop(0))\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/91": [{"task_id": "EvoEval/91", "solution": "\ndef is_bored(S):\n    count = 0\n    sentences = S.split('.')\n    for sentence in sentences:\n        words = sentence.split()\n        if len(words) > 1 and words[0] == 'I' and (words[-1] == 'boredom'):\n            count += 1\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [["The sky is blue. The sun is shining. I am experiencing boredom?Yes"]], "plus_fail_tests": []}], "EvoEval/25": [{"task_id": "EvoEval/25", "solution": "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors[::-1]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/22": [{"task_id": "EvoEval/22", "solution": "\nfrom typing import List, Any\n\n\ndef filter_even_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for even integers\n    >>> filter_even_integers(['a', 3.14, 5, 6])\n    [6]\n    >>> filter_even_integers([1, 2, 3, 'abc', {}, []])\n    [2]\n    \"\"\"\n    even_integers = []\n    for value in values:\n        if isinstance(value, int) and value % 2 == 0:\n            even_integers.append(value)\n    return even_integers", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[true, false, null, 0, -10, "test", [], {}, 3.14]]], "plus_fail_tests": []}], "EvoEval/10": [{"task_id": "EvoEval/10", "solution": "\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that ends with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest prefix of supplied string that is a palindrome.\n    - Append to the start of the string reverse of a string suffix that comes after the palindromic prefix.\n    \"\"\"\n    for i in range(len(string)):\n        if is_palindrome(string[:i + 1]):\n            return string + string[i + 1:][::-1]\n    return string + string[::-1]", "base_status": "fail", "plus_status": null, "base_fail_tests": [["xyz"]], "plus_fail_tests": []}], "EvoEval/38": [{"task_id": "EvoEval/38", "solution": "\ndef encode_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of four characters.\n    \"\"\"\n    n = 4\n    # split string to groups. Each of length 4.\n    groups = [s[(n * i):min((n * i + n), len(s))] for i in range((len(s) + n - 1) // n)]\n    # cycle elements in each group. Unless group has fewer elements than 4.\n    groups = [(group[1:] + group[0]) if len(group) == n else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    n = 4\n    groups = [s[n * i:min(n * i + n, len(s))] for i in range((len(s) + n - 1) // n)]\n    groups = [group[-1] + group[:-1] if len(group) == n else group for group in groups]\n    return ''.join(groups)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/50": [{"task_id": "EvoEval/50", "solution": "\ndef encode_shift(s: str, shift: int = 5):\n    \"\"\"\n    returns encoded string by shifting every character by 'shift' in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + shift - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str, shift: int=5):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string by reversing the shift.\n    \"\"\"\n    return ''.join([chr((ord(ch) - shift - ord('a')) % 26 + ord('a')) for ch in s])", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/26": [{"task_id": "EvoEval/26", "solution": "\nfrom typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    unique_numbers = list(set(numbers))\n    return unique_numbers[::-1]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 2, 4, 3, 5]]], "plus_fail_tests": []}], "EvoEval/61": [{"task_id": "EvoEval/61", "solution": "\n\ndef correct_bracketing(brackets: str) -> bool:\n    stack = []\n    for bracket in brackets:\n        if bracket == '[':\n            stack.append(bracket)\n        elif bracket == ']':\n            if not stack or stack.pop() != '[':\n                return False\n    return not stack", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/62": [{"task_id": "EvoEval/62", "solution": "\n\ndef derivative(xs: list):\n    \"\"\"\n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form, but in descending order of the power of x.\n    \"\"\"\n    derivative_coefficients = []\n    for i in range(len(xs) - 1, 0, -1):\n        derivative_coefficients.append(xs[i] * i)\n    return derivative_coefficients", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/59": [{"task_id": "EvoEval/59", "solution": "\ndef smallest_prime_factor(n: int):\n    \"\"\"Return the smallest prime factor of n. Assume n > 1 and is not a prime.\n    >>> smallest_prime_factor(13195)\n    5\n    >>> smallest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "base_status": "fail", "plus_status": null, "base_fail_tests": [[15]], "plus_fail_tests": []}], "EvoEval/88": [{"task_id": "EvoEval/88", "solution": "\ndef sort_array(array):\n    if not array:\n        return []\n    elif len(array) == 1:\n        return array\n    else:\n        sum_first_last = array[0] + array[-1]\n        if sum_first_last % 2 == 0:\n            sorted_array = sorted(set(array), reverse=True)\n        else:\n            sorted_array = sorted(set(array))\n        return sorted_array", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/78": [{"task_id": "EvoEval/78", "solution": "\ndef hex_key(num):\n    non_prime_digits = ['0', '1', '4', '6', '8', '9', 'A', 'C', 'E']\n    non_prime_count = 0\n    for char in num:\n        if char in non_prime_digits:\n            non_prime_count += 1\n    return non_prime_count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/2": [{"task_id": "EvoEval/2", "solution": "\ndef truncate_number(number: float) -> float:\n    integer_part = int(number)\n    decimal_part = number - integer_part\n    return (integer_part, decimal_part)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/14": [{"task_id": "EvoEval/14", "solution": "\nfrom typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    prefixes = []\n    for i in range(len(string), 0, -1):\n        prefixes.append(string[:i])\n    return prefixes", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/71": [{"task_id": "EvoEval/71", "solution": "\ndef triangle_area(a, b, c):\n    if a + b > c and a + c > b and (b + c > a):\n        s = (a + b + c) / 2\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        return round(area, 3)\n    else:\n        return -1", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/85": [{"task_id": "EvoEval/85", "solution": "\ndef add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the odd elements that are at even indices.\n\n    Examples:\n        add([4, 2, 5, 7]) ==> 5\n    \"\"\"\n    result = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            result += lst[i]\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/52": [{"task_id": "EvoEval/52", "solution": "\n\ndef below_threshold(l: list, t: int) -> bool:\n    for num in l:\n        if num > t:\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/47": [{"task_id": "EvoEval/47", "solution": "\ndef median(l: list):\n    if not l:\n        return 0\n    l.sort()\n    n = len(l)\n    if n % 2 == 0:\n        return (l[n // 2 - 1] + l[n // 2]) / 2\n    else:\n        return l[n // 2]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/13": [{"task_id": "EvoEval/13", "solution": "\n\ndef least_common_multiple(a: int, b: int) -> int:\n    \"\"\" Return the least common multiple of two integers a and b \"\"\"\n    return abs(a * b) // gcd(a, b)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[3, 7]], "plus_fail_tests": []}], "EvoEval/74": [{"task_id": "EvoEval/74", "solution": "\ndef total_match(lst1, lst2):\n    total_chars_lst1 = sum((len(s) for s in lst1))\n    total_chars_lst2 = sum((len(s) for s in lst2))\n    if total_chars_lst1 > total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 > total_chars_lst1:\n        return lst2\n    else:\n        return lst2", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/34": [{"task_id": "EvoEval/34", "solution": "\ndef unique(l: list):\n    \"\"\"Return sorted unique elements in a list in descending order\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [123, 9, 5, 3, 2, 0]\n    \"\"\"\n    return sorted(set(l), reverse=True)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/98": [{"task_id": "EvoEval/98", "solution": "\ndef count_upper(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in odd indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 0\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 1\n    \"\"\"\n    count = 0\n    for i in range(len(s)):\n        if i % 2 == 1 and s[i] in 'AEIOU':\n            count += 1\n    return count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/63": [{"task_id": "EvoEval/63", "solution": "\ndef fibfib(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        (a, b, c) = (0, 0, 1)\n        for _ in range(n - 3):\n            (a, b, c) = (b, c, a + b - c)\n        return c", "base_status": "fail", "plus_status": null, "base_fail_tests": [[5]], "plus_fail_tests": []}], "EvoEval/20": [{"task_id": "EvoEval/20", "solution": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    min_diff = float('inf')\n    result = (0, 0)\n    for i in range(len(numbers) - 1):\n        diff = abs(numbers[i] - numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i + 1], numbers[i])\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3.9, 1.0, 2.2, 2.0, 4.0, 5.0]]], "plus_fail_tests": []}], "EvoEval/33": [{"task_id": "EvoEval/33", "solution": "\ndef sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted in descending order.\n    \"\"\"\n    third_indices = [l[i] for i in range(len(l)) if i % 3 == 0]\n    third_indices.sort(reverse=True)\n    sorted_third_indices = []\n    for i in range(len(l)):\n        if i % 3 == 0:\n            sorted_third_indices.append(third_indices.pop(0))\n        else:\n            sorted_third_indices.append(l[i])\n    return sorted_third_indices", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/90": [{"task_id": "EvoEval/90", "solution": "\ndef next_largest(lst):\n    if len(lst) < 2:\n        return None\n    max_val = max(lst)\n    lst.remove(max_val)\n    max_val_2 = max(lst)\n    return max_val_2", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 1]]], "plus_fail_tests": []}], "EvoEval/67": [{"task_id": "EvoEval/67", "solution": "def fruit_distribution(s, n):\n    s_list = s.split()\n    apples = int(s_list[0])\n    oranges = int(s_list[3])\n    mango_fruits = n + 1 - apples - oranges\n    return mango_fruits", "base_status": "fail", "plus_status": null, "base_fail_tests": [["100 apples, 1 oranges", 120]], "plus_fail_tests": []}], "EvoEval/42": [{"task_id": "EvoEval/42", "solution": "\n\ndef incr_list(l: list):\n    \"\"\"Return list with elements incremented by 2.\n    >>> incr_list([1, 2, 3])\n    [3, 4, 5]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [7, 5, 7, 4, 5, 5, 11, 2, 125]\n    \"\"\"\n    return [x + 2 for x in l]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/96": [{"task_id": "EvoEval/96", "solution": "\ndef count_up_to(n):\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    primes = []\n    for i in range(n, 0, -1):\n        if is_prime(i):\n            primes.append(i)\n    return primes", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/30": [{"task_id": "EvoEval/30", "solution": "\ndef get_positive(l: list):\n    \"\"\"Return only positive numbers in the list in ascending order.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [1, 2, 3, 3, 5, 9, 123]\n    \"\"\"\n    positive_list = [num for num in l if num > 0]\n    positive_list.sort()\n    return positive_list", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/37": [{"task_id": "EvoEval/37", "solution": "\n\ndef sort_even(l: list):\n    even_indices = [i for i in range(len(l)) if i % 2 == 0]\n    even_values = sorted([l[i] for i in even_indices], reverse=True)\n    for (i, val) in zip(even_indices, even_values):\n        l[i] = val\n    return l", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/84": [{"task_id": "EvoEval/84", "solution": "\ndef solve(N):\n    sum_of_digits = sum((int(digit) for digit in str(N)))\n    return hex(sum_of_digits)[2:].upper()", "base_status": "fail", "plus_status": null, "base_fail_tests": [[147]], "plus_fail_tests": []}], "EvoEval/97": [{"task_id": "EvoEval/97", "solution": "\ndef multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the sum of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 10.\n    multiply(19, 28) should return 17.\n    multiply(2020, 1851) should return 1.\n    multiply(14,-15) should return 9.\n    \"\"\"\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b", "base_status": "fail", "plus_status": null, "base_fail_tests": [[148, 412]], "plus_fail_tests": []}], "EvoEval/21": [{"task_id": "EvoEval/21", "solution": "\nfrom typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_val = min(numbers)\n    max_val = max(numbers)\n    rescaled_numbers = [(x - min_val) / (max_val - min_val) for x in numbers]\n    return sorted(rescaled_numbers, reverse=True)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/3": [{"task_id": "EvoEval/3", "solution": "\nfrom typing import List\n\n\ndef below_one(operations: List[int]) -> bool:\n    balance = 1\n    for operation in operations:\n        balance += operation\n        if balance < 1:\n            return True\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/68": [{"task_id": "EvoEval/68", "solution": "\ndef pluck(arr):\n    odd_values = [value for (index, value) in enumerate(arr) if value % 2 != 0]\n    if not odd_values:\n        return []\n    smallest_odd_value = min(odd_values)\n    smallest_odd_index = arr.index(smallest_odd_value)\n    return [smallest_odd_index, smallest_odd_value]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/46": [{"task_id": "EvoEval/46", "solution": "\ndef fib4(n: int) -> str:\n    if n == 0:\n        return '0'\n    elif n == 1:\n        return '0'\n    elif n == 2:\n        return '2'\n    elif n == 3:\n        return '0'\n    else:\n        fib = [0, 0, 2, 0]\n        for i in range(4, n + 1):\n            fib.append(fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4])\n        return str(fib[n])", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/27": [{"task_id": "EvoEval/27", "solution": "\ndef flip_case(string: str, exclusive_case: str='lower') -> str:\n    result = ''\n    for char in string:\n        if exclusive_case == 'lower' and char.isupper():\n            result += char.lower()\n        elif exclusive_case == 'upper' and char.islower():\n            result += char.upper()\n        else:\n            result += char\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/23": [{"task_id": "EvoEval/23", "solution": "\n\ndef strlen(string: str) -> int:\n    return len(string) + 1", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/8": [{"task_id": "EvoEval/8", "solution": "\nfrom typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    sum_result = 0\n    product_result = 1\n    for number in numbers:\n        if number >= 0:\n            sum_result += number\n            product_result *= number\n    return (sum_result, product_result)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/99": [{"task_id": "EvoEval/99", "solution": "\ndef closest_integer(value):\n    num = float(value)\n    if num >= 0:\n        if num - int(num) < 0.5:\n            return int(num)\n        else:\n            return int(num) + 1\n    elif int(num) - num < 0.5:\n        return int(num)\n    else:\n        return int(num) - 1", "base_status": "fail", "plus_status": null, "base_fail_tests": [["14.5"]], "plus_fail_tests": []}], "EvoEval/1": [{"task_id": "EvoEval/1", "solution": "from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(' ', '')\n    groups = []\n    start = 0\n    count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            count += 1\n        elif paren_string[i] == ')':\n            count -= 1\n        if count == 0:\n            groups.append(paren_string[start:i + 1])\n            start = i + 1\n    groups.sort()\n    return groups", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/11": [{"task_id": "EvoEval/11", "solution": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    result = []\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result.append('0')\n        else:\n            result.append('1')\n    return ''.join(result[::-1])", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/95": [{"task_id": "EvoEval/95", "solution": "\ndef check_dict_case(dictionary):\n    if len(dictionary) < 3 or not dictionary:\n        return False\n    lower_case = all((isinstance(key, str) and key.islower() for key in dictionary.keys()))\n    upper_case = all((isinstance(key, str) and key.isupper() for key in dictionary.keys()))\n    return lower_case or upper_case", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/29": [{"task_id": "EvoEval/29", "solution": "\nfrom typing import List\n\n\ndef filter_by_suffix(strings: List[str], suffix: str) -> List[str]:\n    return [s for s in strings if s.endswith(suffix)]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/76": [{"task_id": "EvoEval/76", "solution": "\ndef is_simple_power(x, n):\n    i = 0\n    while n ** i <= x:\n        if n ** i == x:\n            return (True, i)\n        i += 1\n    return (False, None)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[2, -1]], "plus_fail_tests": []}], "EvoEval/6": [{"task_id": "EvoEval/6", "solution": "\nfrom typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    groups = paren_string.split()\n    max_levels = []\n    for group in groups:\n        level = 0\n        max_level = 0\n        for char in group:\n            if char == '(':\n                level += 1\n                if level > max_level:\n                    max_level = level\n            elif char == ')':\n                level -= 1\n        max_levels.append(max_level)\n    max_levels.sort(reverse=True)\n    return max_levels", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/39": [{"task_id": "EvoEval/39", "solution": "\ndef prime_fib(n: int) -> int:\n    if n < 1:\n        return None\n    fib = [0, 1]\n    count = 0\n    while count < n:\n        fib.append(fib[-1] + fib[-2])\n        if is_prime(fib[-1]) and fib[-1] % 2 != 0:\n            count += 1\n    return fib[-1]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1]], "plus_fail_tests": []}], "EvoEval/43": [{"task_id": "EvoEval/43", "solution": "\ndef pairs_sum_to_one(l):\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            if l[i] + l[j] == 1:\n                return True\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/56": [{"task_id": "EvoEval/56", "solution": "\ndef correct_bracketing(brackets: str) -> bool:\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif bracket == ')':\n            if not stack or stack.pop() != '(':\n                return False\n    return not stack", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/41": [{"task_id": "EvoEval/41", "solution": "\ndef car_race_collision(n: int) -> int:\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of 2*n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \"\"\"\n    return n * (n - 1)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[2]], "plus_fail_tests": []}], "EvoEval/93": [{"task_id": "EvoEval/93", "solution": "\n\ndef encode(message):\n    result = ''\n    for char in message:\n        if char.isalpha():\n            if char.islower():\n                if char in 'aeiou':\n                    result += chr((ord(char) - ord('a') + 3) % 26 + ord('a'))\n                else:\n                    result += char.upper()\n            elif char in 'AEIOU':\n                result += chr((ord(char) - ord('A') + 3) % 26 + ord('A'))\n            else:\n                result += char.lower()\n        else:\n            result += char\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["TEST"]], "plus_fail_tests": []}], "EvoEval/49": [{"task_id": "EvoEval/49", "solution": "\ndef modp(n: int, p: int, q: int) -> int:\n    \"\"\"Return 2^(n+q) modulo p (be aware of numerics).\n    >>> modp(3, 5, 1)\n    1\n    >>> modp(1101, 101, 2)\n    8\n    >>> modp(0, 101, 1)\n    2\n    >>> modp(3, 11, 2)\n    10\n    >>> modp(100, 101, 1)\n    2\n    \"\"\"\n    return pow(2, n + q, p)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/9": [{"task_id": "EvoEval/9", "solution": "\nfrom typing import List, Tuple\n\n\ndef rolling_min(numbers: List[int]) -> List[int]:\n    result = []\n    min_value = numbers[0]\n    for number in numbers:\n        if number < min_value:\n            min_value = number\n        result.append(min_value)\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[]]], "plus_fail_tests": []}], "EvoEval/77": [{"task_id": "EvoEval/77", "solution": "\ndef iscube(a):\n    \"\"\"\n    Write a function that takes an integer a and returns True \n    if this integer is a cube of some positive integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> False\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    \"\"\"\n    cuberoot = round(a ** (1 / 3))\n    if cuberoot ** 3 == a:\n        return True\n    else:\n        return False", "base_status": "fail", "plus_status": null, "base_fail_tests": [[-1]], "plus_fail_tests": []}], "EvoEval/54": [{"task_id": "EvoEval/54", "solution": "\ndef same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters and the same length.\n    \"\"\"\n    return sorted(s0) == sorted(s1) and len(s0) == len(s1)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["aaaaaaabcd", "dddddddabc"]], "plus_fail_tests": []}], "EvoEval/7": [{"task_id": "EvoEval/7", "solution": "\nfrom typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring not in s]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/32": [{"task_id": "EvoEval/32", "solution": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\"xs are coefficients of a polynomial xs[0] + xs[1] * x^1 + xs[2] * x^3 + .... xs[n] * x^(2*n-1)\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only one zero point, even if there are many.\n    Moreover, find_zero only takes list xs having at least two coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    \"\"\"\n    if len(xs) < 2:\n        raise ValueError('List must have at least two coefficients')\n    if xs[-1] == 0:\n        raise ValueError('Largest non-zero coefficient must be non-zero')\n    x = 0\n    while abs(poly(xs, x)) > 1e-06:\n        x -= poly(xs, x) / poly(xs, 2 * x)\n    return x", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[-10, -2]]], "plus_fail_tests": []}], "EvoEval/64": [{"task_id": "EvoEval/64", "solution": "FIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s):\n    vowels = 'aeiou'\n    count = 0\n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n    if s[-1] == 'y':\n        count += 1\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Alone"]], "plus_fail_tests": []}], "EvoEval/73": [{"task_id": "EvoEval/73", "solution": "\ndef smallest_change(arr):\n    n = len(arr)\n    changes = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            changes += 1\n    return changes", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/87": [{"task_id": "EvoEval/87", "solution": "def get_row(lst, x):\n    result = []\n    for (i, row) in enumerate(lst):\n        for (j, col) in enumerate(row):\n            if col == x:\n                result.append((i, j))\n    result.sort(key=lambda x: (-x[0], x[1]))\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/17": [{"task_id": "EvoEval/17", "solution": "\nfrom typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    notes = music_string.split()\n    note_lengths = []\n    for note in notes:\n        if note == 'o':\n            note_lengths.append(4)\n        elif note == 'o|':\n            note_lengths.append(2)\n        elif note == '.|':\n            note_lengths.append(1)\n    unique_note_lengths = list(set(note_lengths))\n    unique_note_lengths.sort(reverse=True)\n    return unique_note_lengths", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/5": [{"task_id": "EvoEval/5", "solution": "\nfrom typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    result = []\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i != len(numbers) - 1:\n            result.append(delimeter)\n    result.append(delimeter)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/51": [{"task_id": "EvoEval/51", "solution": "\ndef remove_consonants(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char in vowels])", "base_status": "fail", "plus_status": null, "base_fail_tests": [["abcdef\nghijklm"]], "plus_fail_tests": []}], "EvoEval/28": [{"task_id": "EvoEval/28", "solution": "\nfrom typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string, separated by a comma.\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'a,b,c'\n    \"\"\"\n    return ','.join(strings)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/69": [{"task_id": "EvoEval/69", "solution": "\ndef search(lst):\n    freq = {}\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    for num in lst:\n        if freq[num] >= num and num > 0:\n            return num\n    return -1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[4, 1, 4, 1, 4, 4]]], "plus_fail_tests": []}], "EvoEval/66": [{"task_id": "EvoEval/66", "solution": "\ndef digitSum(s):\n    \"\"\"\n    This function takes a string as input and returns the sum of the lower characters only'\n    ASCII codes.\n    \"\"\"\n    return sum((ord(c) for c in s if c.islower()))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/79": [{"task_id": "EvoEval/79", "solution": "\ndef decimal_to_binary(decimal):\n    binary = bin(decimal)[2:]\n    return 'db' + binary + 'bd'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/86": [{"task_id": "EvoEval/86", "solution": "\ndef anti_shuffle(s):\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word, reverse=True))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/72": [{"task_id": "EvoEval/72", "solution": "\ndef will_it_fly(q, w):\n    if q != q[::-1]:\n        return False\n    if sum(q) % 2 != 0 or sum(q) > w:\n        return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/4": [{"task_id": "EvoEval/4", "solution": "\nfrom typing import List\n\n\ndef median_absolute_deviation(numbers: List[float]) -> float:\n    median = statistics.median(numbers)\n    diffs = [abs(x - median) for x in numbers]\n    mad = statistics.median(diffs)\n    return mad", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1.0, 2.0, 3.0]]], "plus_fail_tests": []}], "EvoEval/83": [{"task_id": "EvoEval/83", "solution": "\ndef starts_one_ends(n):\n    count = 0\n    for i in range(10 ** (n - 1), 10 ** n):\n        if str(i)[0] == '1' or str(i)[-1] == '2':\n            count += 1\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [[10]], "plus_fail_tests": []}], "EvoEval/45": [{"task_id": "EvoEval/45", "solution": "\n\ndef triangle_perimeter(a, b, c):\n    \"\"\"Given length of three sides return perimeter for a triangle.\n    >>> triangle_perimeter(5, 3, 3)\n    11\n    \"\"\"\n    return a + b + c", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/48": [{"task_id": "EvoEval/48", "solution": "\n\ndef is_palindrome(text: str, case_sensitive: bool=True) -> bool:\n    if case_sensitive:\n        return text == text[::-1]\n    else:\n        return text.lower() == text.lower()[::-1]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/58": [{"task_id": "EvoEval/58", "solution": "\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists in descending order.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [653, 5, 1]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [3, 2]\n    \"\"\"\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1.intersection(set2)\n    sorted_common_elements = sorted(common_elements, reverse=True)\n    return sorted_common_elements", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/18": [{"task_id": "EvoEval/18", "solution": "\ndef how_many_times(string: str, substring: str) -> int:\n    count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i + len(substring)] == substring:\n            count += 1\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [["cacacacac", "cac"]], "plus_fail_tests": []}], "EvoEval/60": [{"task_id": "EvoEval/60", "solution": "\ndef sum_to_n(n: int, m: int=1):\n    \"\"\"sum_to_n is a function that sums numbers from m to n.\n    >>> sum_to_n(30, 10)\n    420\n    >>> sum_to_n(100, 50)\n    3825\n    >>> sum_to_n(5, 2)\n    14\n    >>> sum_to_n(10, 5)\n    45\n    >>> sum_to_n(1, 1)\n    1\n    \"\"\"\n    return sum(range(m, n + 1))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/80": [{"task_id": "EvoEval/80", "solution": "\ndef is_happy(s):\n    if len(s) < 4:\n        return False\n    for i in range(len(s) - 3):\n        if s[i] == s[i + 1] or s[i + 1] == s[i + 2] or s[i + 2] == s[i + 3]:\n            return False\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [["iopaxpoi"]], "plus_fail_tests": []}], "EvoEval/53": [{"task_id": "EvoEval/53", "solution": "\ndef add(x: int, y: int) -> int:\n    \"\"\"Add two numbers x and y and return the result increased by 1\n    >>> add(2, 3)\n    6\n    >>> add(5, 7)\n    13\n    \"\"\"\n    return x + y + 1", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/12": [{"task_id": "EvoEval/12", "solution": "\nfrom typing import List, Optional\n\n\ndef shortest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    shortest_string = strings[0]\n    for string in strings:\n        if len(string) < len(shortest_string):\n            shortest_string = string\n    return shortest_string", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/0": [{"task_id": "EvoEval/0", "solution": "\nfrom typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/36": [{"task_id": "EvoEval/36", "solution": "\ndef fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('8')\n    return count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/94": [{"task_id": "EvoEval/94", "solution": "\ndef skjkasdkd(lst):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        return 0\n    smallest_prime = min(primes)\n    return sum((int(digit) for digit in str(smallest_prime)))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/15": [{"task_id": "EvoEval/15", "solution": "\ndef string_sequence(n: int) -> str:\n    return ' '.join((str(i) for i in range(1, n + 1)))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}]}}