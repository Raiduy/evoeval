{"eval": {"EvoEval/50": [{"task_id": "EvoEval/50", "solution": "\ndef get_closest_upper_vowel(word):\n    vowels = 'AEIOU'\n    for i in range(len(word) - 1, 0, -2):\n        if word[i] in vowels and word[i - 1].islower() and word[i + 1].islower():\n            return word[i]\n    return ''", "base_status": "fail", "plus_status": null, "base_fail_tests": [["cAmp"]], "plus_fail_tests": []}], "EvoEval/59": [{"task_id": "EvoEval/59", "solution": "def odd_count_base_change(lst, base):\n    result = []\n    for string in lst:\n        odd_count = 0\n        for digit in string:\n            if int(digit, base) % 2 != 0:\n                odd_count += 1\n        result.append(f'the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.')\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["3", "11111111"], 3]], "plus_fail_tests": []}], "EvoEval/57": [{"task_id": "EvoEval/57", "solution": "def palindromic_and_odd_digit_array(arr):\n    changes = 0\n    odd_digits = set('13579')\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[-i - 1]:\n            changes += 1\n    for num in arr:\n        for digit in str(num):\n            if digit not in odd_digits:\n                changes += 1\n    return changes", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 4, 3, 6, 2]]], "plus_fail_tests": []}], "EvoEval/70": [{"task_id": "EvoEval/70", "solution": "\nfrom typing import List, Tuple\nimport math\n\n\ndef closest_special_factorial(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    This function will receive a list of integers as input and should return a tuple of two integers \n    that have the closest special factorials. The special factorial is defined as:\n    special_factorial(n) = n! * (n-1)! * ... * 1! where n > 0\n\n    The function should return the two numbers whose special factorials are the closest to each other. \n    The result should be in ascending order.\n    \"\"\"\n    special_factorials = [special_factorial(n) for n in numbers]\n    closest_pair = (numbers[0], numbers[1])\n    min_difference = abs(special_factorials[0] - special_factorials[1])\n    for i in range(len(special_factorials)):\n        for j in range(i + 1, len(special_factorials)):\n            difference = abs(special_factorials[i] - special_factorials[j])\n            if difference < min_difference:\n                min_difference = difference\n                closest_pair = (numbers[i], numbers[j])\n    return tuple(sorted(closest_pair))", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[4, 5, 6]]], "plus_fail_tests": []}], "EvoEval/81": [{"task_id": "EvoEval/81", "solution": "\nfrom typing import List\n\n", "base_status": "fail", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/44": [{"task_id": "EvoEval/44", "solution": "\nfrom typing import List\n\ndef roman_prefixes(number: int) -> List[str]:\n    roman_numerals = {1: 'i', 4: 'iv', 5: 'v', 9: 'ix', 10: 'x', 40: 'xl', 50: 'l', 90: 'xc', 100: 'c', 400: 'cd', 500: 'd', 900: 'cm', 1000: 'm'}\n    roman_prefixes = []\n    roman_num = ''\n    for value in sorted(roman_numerals.keys(), reverse=True):\n        while number >= value:\n            roman_num += roman_numerals[value]\n            number -= value\n    for i in range(len(roman_num)):\n        roman_prefixes.append(roman_num[:i + 1])\n    return roman_prefixes", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/75": [{"task_id": "EvoEval/75", "solution": "def transform_dict(input_dict):\n    if not input_dict or not all((isinstance(key, str) for key in input_dict.keys())):\n        return {}\n    if not all((key.isupper() or key.islower() for key in input_dict.keys())):\n        return {}\n    result = {}\n    for (key, value) in input_dict.items():\n        try:\n            num = float(value)\n            if num >= 0:\n                result[key] = int(num + 0.5)\n            else:\n                result[key] = int(num - 0.5)\n        except ValueError:\n            return {}\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"a": "10", "B": "15.3"}]], "plus_fail_tests": []}], "EvoEval/22": [{"task_id": "EvoEval/22", "solution": "def binary_planet_distance(planet1, planet2):\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ''\n    planet1_index = planets.index(planet1)\n    planet2_index = planets.index(planet2)\n    if planet1_index > planet2_index:\n        (planet1_index, planet2_index) = (planet2_index, planet1_index)\n    planets_between = planets[planet1_index + 1:planet2_index]\n    binary_string = 'bd' + ''.join(['1' if planet in planets_between else '0' for planet in planets]) + 'bd'\n    return binary_string", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Mercury", "Venus"]], "plus_fail_tests": []}], "EvoEval/32": [{"task_id": "EvoEval/32", "solution": "\nfrom typing import List\n\ndef circular_shift_nested_parens(input: List[str], shift: int) -> List[int]:\n    nesting_depths = [max(0, sum((1 for c in s if c == '('))) for s in input]\n    num = int(''.join((str(d) for d in nesting_depths)))\n    shifted_num = num * 10 ** shift % 10 ** len(str(num))\n    return [int(d) for d in str(shifted_num)]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["(()())", "((()))", "()", "", "((())()())"], 5]], "plus_fail_tests": []}], "EvoEval/55": [{"task_id": "EvoEval/55", "solution": "import hashlib\n\ndef mini_roman_to_md5(number):\n    if number <= 0:\n        return None\n    roman_numerals = {1000: 'm', 900: 'cm', 500: 'd', 400: 'cd', 100: 'c', 90: 'xc', 50: 'l', 40: 'xl', 10: 'x', 9: 'ix', 5: 'v', 4: 'iv', 1: 'i'}\n    roman_string = ''\n    for (value, numeral) in sorted(roman_numerals.items(), reverse=True):\n        while number >= value:\n            roman_string += numeral\n            number -= value\n    md5_hash = hashlib.md5(roman_string.encode()).hexdigest()\n    return md5_hash", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/31": [{"task_id": "EvoEval/31", "solution": "\nfrom typing import List\n\ndef special_prime_factorial(n: int) -> int:\n\n    def factorize(n):\n        factors = []\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                factors.append(i)\n        if n > 1:\n            factors.append(n)\n        return factors\n    factors = factorize(n)\n    result = 1\n    for factor in factors:\n        result *= factorial(factor)\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[70]], "plus_fail_tests": []}], "EvoEval/91": [{"task_id": "EvoEval/91", "solution": "\ndef sort_prime_even(l: list, x, y):\n    even_indices = [i for i in range(len(l)) if i % 2 == 0]\n    even_values = sorted([l[i] for i in even_indices])\n    for i in range(len(l)):\n        if i % 2 == 0:\n            if even_values[0] % 2 == 0:\n                l[i] = x\n            else:\n                l[i] = y\n            even_values.pop(0)\n    return l", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[7, 1, 9, 2, 8], 15, 30]], "plus_fail_tests": []}], "EvoEval/83": [{"task_id": "EvoEval/83", "solution": "\nimport re\n\n\ndef prime_underscored_length(text):\n    text = re.sub(' {2,}', '_', text)\n    text = re.sub(' ', '_', text)\n    return is_prime(len(text))", "base_status": "fail", "plus_status": null, "base_fail_tests": [[" Example    4"]], "plus_fail_tests": []}], "EvoEval/19": [{"task_id": "EvoEval/19", "solution": "from typing import List, Tuple, Optional\n\ndef account_operations(operations: List[int]) -> Tuple[Optional[int], Optional[int], bool]:\n    balance = 0\n    largest_withdrawal = None\n    smallest_deposit = None\n    balance_below_zero = False\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            balance_below_zero = True\n            break\n        if operation < 0 and (largest_withdrawal is None or operation > largest_withdrawal):\n            largest_withdrawal = operation\n        elif operation > 0 and (smallest_deposit is None or operation < smallest_deposit):\n            smallest_deposit = operation\n    return (largest_withdrawal, smallest_deposit, balance_below_zero)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, -3, 2, -2, 5]]], "plus_fail_tests": []}], "EvoEval/10": [{"task_id": "EvoEval/10", "solution": "\ndef class_grades_with_flip(name_grade_list):\n    gpa_to_letter_grade = {4.0: 'A+', 3.7: 'A', 3.3: 'A-', 3.0: 'B+', 2.7: 'B', 2.3: 'B-', 2.0: 'C+', 1.7: 'C', 1.3: 'C-', 1.0: 'D+', 0.7: 'D', 0.0: 'D-', 0.0: 'E'}\n    results = []\n    for (name, gpa) in name_grade_list:\n        name = name.title()\n        letter_grade = gpa_to_letter_grade.get(gpa, 'E')\n        results.append((name, letter_grade))\n    return results", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[["JOHN", 4.0], ["sarah", 3.0], ["ALICE", 1.7], ["BOB", 2.0], ["linda", 3.5]]]], "plus_fail_tests": []}], "EvoEval/82": [{"task_id": "EvoEval/82", "solution": "\ndef odd_fibfib(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        (a, b, c) = (0, 0, 1)\n        for _ in range(3, n + 1):\n            (a, b, c) = (b, c, a + b + c)\n            if c % 2 == 0:\n                c = 0\n                for digit in str(c):\n                    if int(digit) % 2 != 0:\n                        c *= int(digit)\n        return c", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/89": [{"task_id": "EvoEval/89", "solution": "\nfrom typing import List\n\ndef md5_substring_filter(strings: List[str], hash_substring: str) -> List[str]:\n    if not strings:\n        return None\n    result = []\n    for string in strings:\n        if string:\n            md5_hash = hashlib.md5(string.encode()).hexdigest()\n            if hash_substring in md5_hash:\n                result.append(string)\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["Python", "Hello", "123", ""], "96"]], "plus_fail_tests": []}], "EvoEval/35": [{"task_id": "EvoEval/35", "solution": "def check_dict_happiness(dict):\n    if not dict:\n        return False\n    for key in dict.keys():\n        if not isinstance(key, str):\n            return False\n        if not key.islower() and (not key.isupper()):\n            return False\n        if len(key) < 3:\n            return False\n        for i in range(len(key) - 2):\n            if key[i] == key[i + 1] or key[i] == key[i + 2] or key[i + 1] == key[i + 2]:\n                return False\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"abc": "apple", "ABD": "banana"}]], "plus_fail_tests": []}], "EvoEval/16": [{"task_id": "EvoEval/16", "solution": "def get_music_notes(word: str, music_string: str):\n    vowels = 'AEIOUaeiou'\n    beats = {'o': 4, 'o|': 2, '.|': 1}\n    notes = []\n    for i in range(len(word) - 1, 0, -1):\n        if word[i] in vowels and word[i - 1] not in vowels and (word[i + 1] not in vowels):\n            for j in range(len(music_string)):\n                if music_string[j] == word[i]:\n                    for k in range(j, len(music_string)):\n                        if music_string[k] in beats:\n                            notes.append(beats[music_string[k]])\n                        elif music_string[k] == ' ':\n                            break\n                        else:\n                            continue\n                    break\n            break\n    return notes", "base_status": "fail", "plus_status": null, "base_fail_tests": [["FULL", "o o| .| o| o| .| .| .| .| o o"]], "plus_fail_tests": []}], "EvoEval/26": [{"task_id": "EvoEval/26", "solution": "\nfrom typing import List, Tuple\n\ndef sort_and_pluck(values: List[str]) -> Tuple[str, int]:\n    even_numerals = []\n    for (i, value) in enumerate(values):\n        numerals = value.split()\n        numerals.sort()\n        for numeral in numerals:\n            if numeral in ['zero', 'two', 'four', 'six', 'eight']:\n                even_numerals.append((numeral, i))\n    if not even_numerals:\n        return ()\n    even_numerals.sort(key=lambda x: (int(x[0][0]) % 2, x[1]))\n    return even_numerals[0]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["three two one", "five four zero", "six zero eight"]]], "plus_fail_tests": []}], "EvoEval/78": [{"task_id": "EvoEval/78", "solution": "\ndef solve_and_count(s):\n    has_letters = any((c.isalpha() for c in s))\n    if not has_letters:\n        return (s[::-1], 0)\n    result = ''\n    for c in s:\n        if c.isalpha():\n            result += c.lower() if c.isupper() else c.upper()\n        else:\n            result += c\n    count = sum((1 for i in range(0, len(result), 2) if result[i] in 'AEIOU'))\n    return (result, count)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/92": [{"task_id": "EvoEval/92", "solution": "\ndef get_common_max_triples(n, l1):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    common_elements = sorted(list(set(a) & set(l1)))\n    if not any((x % 3 == 0 for x in common_elements)):\n        return 0\n    count = 0\n    for i in range(len(common_elements)):\n        for j in range(i + 1, len(common_elements)):\n            for k in range(j + 1, len(common_elements)):\n                if (common_elements[i] + common_elements[j] + common_elements[k]) % 3 == 0:\n                    count += 1\n    return (common_elements, count)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[10, [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]]], "plus_fail_tests": []}], "EvoEval/62": [{"task_id": "EvoEval/62", "solution": "\ndef strange_word_sort(text):\n    words = text.split()\n    sorted_words = []\n    while words:\n        min_word = min(words, key=lambda x: x.lower())\n        sorted_words.append(min_word)\n        words.remove(min_word)\n        if words:\n            max_word = max(words, key=lambda x: x.lower())\n            sorted_words.append(max_word)\n            words.remove(max_word)\n    return '_'.join(sorted_words).replace(' ', '_').replace('--', '-')", "base_status": "fail", "plus_status": null, "base_fail_tests": [["House   car"]], "plus_fail_tests": []}], "EvoEval/94": [{"task_id": "EvoEval/94", "solution": "\ndef sort_count_nums(arr):\n    count = 0\n    for num in arr:\n        if sum((int(digit) for digit in str(abs(num)))) > 0:\n            count += 1\n    if count % 2 == 0:\n        return sorted(arr, reverse=True)\n    else:\n        return sorted(arr)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[15, -23, 56, 78, -90, 0, 34, 23, -45, 67]]], "plus_fail_tests": []}], "EvoEval/40": [{"task_id": "EvoEval/40", "solution": "\ndef largest_prime_odd_ends(nums):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    largest_prime = None\n    for num in nums:\n        if num > 10 and num % 10 % 2 == 1 and (num // 10 % 2 == 1):\n            for factor in range(3, int(num ** 0.5) + 1, 2):\n                if num % factor == 0 and is_prime(factor):\n                    largest_prime = max(largest_prime, factor)\n    return largest_prime", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[51, -73, 14, -15]]], "plus_fail_tests": []}], "EvoEval/88": [{"task_id": "EvoEval/88", "solution": "\ndef process_and_sort_string(s):\n    words = s.replace(',', '').split()\n    words = [word for word in words if len(word) % 2 == 0]\n    words.sort(key=lambda x: (len(x), x))\n    return words", "base_status": "fail", "plus_status": null, "base_fail_tests": [[",a,b,c,d,e,f,g,h,i,j,"]], "plus_fail_tests": []}], "EvoEval/76": [{"task_id": "EvoEval/76", "solution": "def sort_prime_digit_sum(lst):\n    new_lst = []\n    for num in lst:\n        if is_prime(num):\n            new_lst.append(sum((int(digit) for digit in str(num))))\n        else:\n            new_lst.append(num)\n    if (new_lst[0] + new_lst[-1]) % 2 == 0:\n        return sorted(new_lst, reverse=True)\n    else:\n        return sorted(new_lst)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]]], "plus_fail_tests": []}], "EvoEval/61": [{"task_id": "EvoEval/61", "solution": "\nfrom typing import List, Optional, Tuple\n\ndef longest_planet_chain(planet1: str, planet2: str, chains: List[Tuple[str, ...]]) -> Optional[Tuple[str, ...]]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return None\n    longest_chain = None\n    max_length = 0\n    for chain in chains:\n        if chain[0] == planet1 and chain[-1] == planet2:\n            if len(chain) > max_length:\n                longest_chain = chain\n                max_length = len(chain)\n    return longest_chain", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/24": [{"task_id": "EvoEval/24", "solution": "from typing import List\n\ndef sort_happy_numbers(numbers: str) -> str:\n    numeral_to_int = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    numbers = numbers.replace(' ', '')\n    for i in range(len(numbers) - 2):\n        if numbers[i] == numbers[i + 1] or numbers[i] == numbers[i + 2] or numbers[i + 1] == numbers[i + 2]:\n            return 'Not a happy string'\n    numbers_list = [numeral_to_int[num] for num in numbers]\n    numbers_list.sort()\n    sorted_numbers = ' '.join([str(num) for num in numbers_list])\n    return sorted_numbers", "base_status": "fail", "plus_status": null, "base_fail_tests": [["five two eight"]], "plus_fail_tests": []}], "EvoEval/2": [{"task_id": "EvoEval/2", "solution": "\nfrom typing import List\n\ndef modp_intersperse(numbers: List[int], n: int, p: int) -> List[int]:\n    result = []\n    for i in range(len(numbers)):\n        result.append(numbers[i])\n        if i < len(numbers) - 1:\n            result.append(pow(2, n, p))\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/71": [{"task_id": "EvoEval/71", "solution": "\nimport math\n\ndef special_brazilian_balloon(n, w):\n    brazilian_factorial = 1\n    for i in range(1, n + 1):\n        brazilian_factorial *= math.factorial(i)\n    is_palindrome = w == w[::-1]\n    sum_of_weights = sum(w)\n    is_within_weight_limit = sum_of_weights <= brazilian_factorial\n    return is_palindrome and is_within_weight_limit", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/85": [{"task_id": "EvoEval/85", "solution": "def next_smallest_sorted_binary(lst):\n    if len(lst) < 2:\n        return None\n    lst.sort(key=lambda x: (bin(x).count('1'), x))\n    return lst[1]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 1]]], "plus_fail_tests": []}], "EvoEval/47": [{"task_id": "EvoEval/47", "solution": "def count_odd_upper(s, lst):\n    n = sum((1 for i in range(0, len(s), 2) if s[i] in 'AEIOU'))\n    return [f'In the string, the number of uppercase vowels in even indices is {n}, and the number of odd digits is {sum((int(c) % 2 for c in s))}.' for s in lst]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/52": [{"task_id": "EvoEval/52", "solution": "def pluck_and_prod(arr):\n    if not arr:\n        return ([], None)\n    smallest_even_index = -1\n    smallest_even_value = float('inf')\n    for (i, num) in enumerate(arr):\n        if num % 2 == 0 and num < smallest_even_value:\n            smallest_even_index = i\n            smallest_even_value = num\n    if smallest_even_index == -1:\n        return ([], None)\n    else:\n        plucked_node = [arr[smallest_even_index], smallest_even_index]\n        remaining_nodes = arr[:smallest_even_index] + arr[smallest_even_index + 1:]\n        remaining_sum = sum([abs(num) * (1 if num > 0 else -1 if num < 0 else 0) for num in remaining_nodes])\n        return (plucked_node, remaining_sum)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[-5, -2, 3, 0, -4]]], "plus_fail_tests": []}], "EvoEval/74": [{"task_id": "EvoEval/74", "solution": "def sum_exchange(lst1, lst2, x, y, z):\n    even_lst1 = [num for num in lst1 if num % 2 == 0]\n    odd_lst1 = [num for num in lst1 if num % 2 != 0]\n    even_lst2 = [num for num in lst2 if num % 2 == 0]\n    odd_lst2 = [num for num in lst2 if num % 2 != 0]\n    if len(even_lst1) == len(lst1):\n        answer = 'YES'\n    elif len(odd_lst1) == len(lst1):\n        answer = 'NO'\n    else:\n        answer = 'YES' if len(even_lst1) + len(odd_lst2) == len(lst1) else 'NO'\n    if x + y == z or x + z == y or y + z == x:\n        answer = 'SUM ' + answer\n    else:\n        answer = 'NO_SUM ' + answer\n    return answer", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 3, 5, 7], [2, 4, 6, 8], 10, 2, 8]], "plus_fail_tests": []}], "EvoEval/34": [{"task_id": "EvoEval/34", "solution": "from typing import List\n\ndef md5_nested_parens(paren_string: str) -> List[str]:\n    result = []\n    if not paren_string:\n        return result\n    groups = paren_string.split()\n    for group in groups:\n        if not is_balanced(group):\n            result.append(hashlib.md5(b'None').hexdigest())\n            continue\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n        result.append(hashlib.md5(str(max_depth).encode()).hexdigest())\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["(()()) (((((()))()((())()()))))"]], "plus_fail_tests": []}], "EvoEval/13": [{"task_id": "EvoEval/13", "solution": "def filter_exchange(arr, lst1):\n    arr = [num for num in arr if sum((int(digit) for digit in str(abs(num)))) > 0]\n    even_lst1 = [num for num in lst1 if num % 2 == 0]\n    odd_lst1 = [num for num in lst1 if num % 2 != 0]\n    even_arr = [num for num in arr if num % 2 == 0]\n    odd_arr = [num for num in arr if num % 2 != 0]\n    if len(odd_lst1) > len(even_arr):\n        return 'NO'\n    return 'YES'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[-100, -200, -300, -400, -500], [0, 1, 2, 3, 4, 5]]], "plus_fail_tests": []}], "EvoEval/98": [{"task_id": "EvoEval/98", "solution": "\ndef check_dict_bracketing(dict):\n    if not dict:\n        return False\n    lower_case = all((key.islower() for key in dict.keys()))\n    upper_case = all((key.isupper() for key in dict.keys()))\n    if not (lower_case or upper_case):\n        return False\n    for value in dict.values():\n        if not all((c in '()' for c in value)):\n            return False\n        if value.count('(') != value.count(')'):\n            return False\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"A": "((((()))))", "B": "([])"}]], "plus_fail_tests": []}], "EvoEval/63": [{"task_id": "EvoEval/63", "solution": "\ndef sort_planets(planet1: str, planet2: str, order: str) -> str:\n    planets = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7}\n    if planet1 not in planets or planet2 not in planets:\n        return 'Invalid'\n    planet1_index = planets[planet1]\n    planet2_index = planets[planet2]\n    if planet1_index > planet2_index:\n        (planet1_index, planet2_index) = (planet2_index, planet1_index)\n    order_list = order.split()\n    if len(order_list) != 8 or len(set(order_list)) != 8:\n        return 'Invalid'\n    for planet in order_list:\n        if planet not in planets:\n            return 'Invalid'\n    result = []\n    for planet in order_list:\n        planet_index = planets[planet]\n        if planet_index > planet1_index and planet_index < planet2_index:\n            result.append(planet)\n    result.sort(key=lambda x: planets[x])\n    return ' '.join(result)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Mercury", "Uranus", "zero one two three four five six seven"]], "plus_fail_tests": []}], "EvoEval/20": [{"task_id": "EvoEval/20", "solution": "\ndef grade_and_case(s, grades):\n    result = []\n    for i in range(len(s)):\n        name = s[i]\n        grade = grades[i]\n        if grade == 4.0:\n            letter_grade = 'A+'\n        elif grade > 3.7:\n            letter_grade = 'A'\n        elif grade > 3.3:\n            letter_grade = 'A-'\n        elif grade > 3.0:\n            letter_grade = 'B+'\n        elif grade > 2.7:\n            letter_grade = 'B'\n        elif grade > 2.3:\n            letter_grade = 'B-'\n        elif grade > 2.0:\n            letter_grade = 'C+'\n        elif grade > 1.7:\n            letter_grade = 'C'\n        elif grade > 1.3:\n            letter_grade = 'C-'\n        elif grade > 1.0:\n            letter_grade = 'D+'\n        elif grade > 0.7:\n            letter_grade = 'D'\n        elif grade > 0.0:\n            letter_grade = 'D-'\n        else:\n            letter_grade = 'E'\n        reversed_name = name[::-1]\n        result.append((reversed_name, letter_grade))\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["Amy", "BOB", "miLEs"], [4.0, 3, 1.7]]], "plus_fail_tests": []}], "EvoEval/96": [{"task_id": "EvoEval/96", "solution": "\ndef common_pairs_with_zero_sum(l1: list, l2: list) -> bool:\n    common_elements = set(l1) & set(l2)\n    for element in common_elements:\n        if -element in common_elements:\n            return True\n    return False", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 3, 5, -3, 0], [0, -3, 1, 5, 2]]], "plus_fail_tests": []}], "EvoEval/33": [{"task_id": "EvoEval/33", "solution": "\ndef roman_happiness(s):\n    roman_numerals = {'i': 1, 'v': 5, 'x': 10, 'l': 50, 'c': 100, 'd': 500, 'm': 1000}\n    if len(s) < 3:\n        return False\n    total = 0\n    for i in range(len(s)):\n        if i > 0 and s[i] == s[i - 1]:\n            return False\n        if i > 1 and s[i] == s[i - 2]:\n            return False\n        total += roman_numerals[s[i]]\n        if total > 1000:\n            return False\n    return total", "base_status": "fail", "plus_status": null, "base_fail_tests": [["xliv"]], "plus_fail_tests": []}], "EvoEval/67": [{"task_id": "EvoEval/67", "solution": "\nfrom typing import List\n\ndef max_close_element_difference(numbers: List[float], threshold: float) -> float:\n    max_diff = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                diff = abs(numbers[i] - numbers[j])\n                if diff > max_diff:\n                    max_diff = diff\n    return max_diff", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/90": [{"task_id": "EvoEval/90", "solution": "\ndef vowels_in_dict_keys(dictionary):\n    vowels = set('aeiouAEIOU')\n    result = {}\n    for key in dictionary:\n        if not isinstance(key, str):\n            return {}\n        if any((c.islower() and c.isupper() for c in key)):\n            return {}\n        if all((c.islower() for c in key)) or all((c.isupper() for c in key)):\n            result[key] = sum((1 for c in key if c in vowels))\n            if key.endswith('y'):\n                result[key] -= 1\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"a": "apple", "A": "banana", "B": "banana"}]], "plus_fail_tests": []}], "EvoEval/42": [{"task_id": "EvoEval/42", "solution": "\ndef check_expression(expression: str) -> bool:\n    fractions = expression.split(',')\n    open_brackets = 0\n    product = 1\n    for fraction in fractions:\n        if not fraction.startswith('<') or not fraction.endswith('>'):\n            return False\n        (numerator, denominator) = fraction[1:-1].split('/')\n        if not numerator.isdigit() or not denominator.isdigit():\n            return False\n        if fraction.startswith('<'):\n            open_brackets += 1\n        product *= int(numerator) // int(denominator)\n    if open_brackets != fractions.count('>'):\n        return False\n    if product.is_integer():\n        return True\n    else:\n        return False", "base_status": "fail", "plus_status": null, "base_fail_tests": [["<1/2,2/1><2/3,3/2>"]], "plus_fail_tests": []}], "EvoEval/15": [{"task_id": "EvoEval/15", "solution": "from typing import List\n\ndef balance_triples(operations: List[int]) -> bool:\n    balance = 0\n    count = 0\n    for op in operations:\n        balance += op\n        if balance == 0:\n            count += 1\n        if balance < 0:\n            return False\n    return count >= 3", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/37": [{"task_id": "EvoEval/37", "solution": "\nimport math\n\ndef minSubArraySumEvenOdd(nums):\n    min_sum = float('inf')\n    even_count = 0\n    odd_count = 0\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        if current_sum < min_sum:\n            min_sum = current_sum\n    return (even_count, odd_count)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[-1, 4, -3, 2, -5, 7, -9, -13]]], "plus_fail_tests": []}], "EvoEval/30": [{"task_id": "EvoEval/30", "solution": "\nfrom typing import List\n\ndef parse_music_simplify(x: str, music_string: str) -> List[bool]:\n    (numerator, denominator) = map(int, x.split('/'))\n    note_beats = {'o': 4, 'o|': 2, '.|': 1}\n    results = []\n    notes = music_string.split()\n    for note in notes:\n        beats = note_beats[note]\n        if numerator * beats % denominator == 0:\n            results.append(True)\n        else:\n            results.append(False)\n    return results", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/97": [{"task_id": "EvoEval/97", "solution": "\ndef fib_max_triples(n):\n    fib = [0, 0, 1]\n    for i in range(3, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2] + fib[i - 3] + i * i - i + 1)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (fib[i] + fib[j] + fib[k]) % 3 == 0:\n                    count += 1\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [[5]], "plus_fail_tests": []}], "EvoEval/21": [{"task_id": "EvoEval/21", "solution": "\nfrom typing import List\n\ndef base_change_prefixes(x: int, base: int) -> List[str]:\n    new_base_x = []\n    while x > 0:\n        new_base_x.append(str(x % base))\n        x //= base\n    new_base_x = new_base_x[::-1]\n    prefixes = []\n    for i in range(len(new_base_x)):\n        prefix = ''.join(new_base_x[:i + 1])\n        prefixes.append(prefix)\n    return prefixes", "base_status": "fail", "plus_status": null, "base_fail_tests": [[0, 2]], "plus_fail_tests": []}], "EvoEval/3": [{"task_id": "EvoEval/3", "solution": "\nfrom typing import List\n\ndef sort_parentheses(lst: List[str]) -> str:\n    string = ''.join(lst)\n    open_parentheses = 0\n    for char in string:\n        if char == '(':\n            open_parentheses += 1\n        elif char == ')':\n            open_parentheses -= 1\n        if open_parentheses < 0:\n            return 'No'\n    if open_parentheses != 0:\n        return 'No'\n    return 'Yes'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["(one)", "(two)", "(three)", "(four", "five)", "(six)", "(seven)", "(eight)", "(nine", "zero)"]]], "plus_fail_tests": []}], "EvoEval/68": [{"task_id": "EvoEval/68", "solution": "\ndef minOddDigitsProductSubArray(nums):\n    n = len(nums)\n    min_product = float('inf')\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            odd_digits_product = 1\n            for num in nums[i:j + 1]:\n                odd_digits = [int(d) for d in str(num) if int(d) % 2 != 0]\n                if odd_digits:\n                    odd_digits_product *= int(''.join(map(str, odd_digits)))\n            product *= odd_digits_product\n            min_product = min(min_product, product)\n    return min_product", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[2, 3, 4, 1, 2, 4]]], "plus_fail_tests": []}], "EvoEval/46": [{"task_id": "EvoEval/46", "solution": "\ndef get_max_even_positive(l: list):\n    even_positive_numbers = [num for num in l if num > 0 and num % 2 == 0]\n    if not even_positive_numbers:\n        return -1\n    return max(even_positive_numbers)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/27": [{"task_id": "EvoEval/27", "solution": "\ndef list_prime_exchange(lst1, lst2, x, y):\n    prime_lst1 = [num for num in lst1 if is_prime(num)]\n    non_prime_lst1 = [num for num in lst1 if not is_prime(num)]\n    prime_lst2 = [num for num in lst2 if is_prime(num)]\n    non_prime_lst2 = [num for num in lst2 if not is_prime(num)]\n    if len(non_prime_lst1) == 0:\n        return x\n    elif len(prime_lst2) == 0:\n        return y\n    else:\n        for num in non_prime_lst1:\n            if len(prime_lst2) == 0:\n                break\n            if num in prime_lst2:\n                prime_lst1.append(num)\n                prime_lst2.remove(num)\n                non_prime_lst1.remove(num)\n        if len(non_prime_lst1) == 0:\n            return x\n        else:\n            return y", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 4], [6, 7, 8, 12], 30, 40]], "plus_fail_tests": []}], "EvoEval/84": [{"task_id": "EvoEval/84", "solution": "\nfrom typing import List, Dict\n\ndef prefixes_histogram(string: str) -> Dict[str, Dict[str, int]]:\n    result = {}\n    for i in range(len(string)):\n        prefix = string[:i + 1]\n        histogram = {}\n        for j in range(len(prefix)):\n            letter = prefix[j]\n            if letter in histogram:\n                histogram[letter] += 1\n            else:\n                histogram[letter] = 1\n        max_count = max(histogram.values())\n        max_letters = [k for (k, v) in histogram.items() if v == max_count]\n        result[prefix] = {k: v for (k, v) in histogram.items() if k in max_letters}\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/8": [{"task_id": "EvoEval/8", "solution": "\ndef correct_bracket_sequence_and_count(string: str, bracket: str) -> tuple:\n    count = 0\n    stack = []\n    for char in string:\n        if char == bracket:\n            count += 1\n        if char == '<':\n            stack.append(char)\n        elif char == '>' and stack:\n            stack.pop()\n        else:\n            return (False, count)\n    return (not stack, count)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["><<>", ">"]], "plus_fail_tests": []}], "EvoEval/23": [{"task_id": "EvoEval/23", "solution": "\ndef special_stone_factorial(n):\n    result = []\n    for i in range(n, 0, -1):\n        if i % 2 == 0:\n            stones = i * 2\n        else:\n            stones = i * 2 - 1\n        factorial = 1\n        for j in range(1, stones + 1):\n            factorial *= j\n        result.append(factorial)\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[4]], "plus_fail_tests": []}], "EvoEval/99": [{"task_id": "EvoEval/99", "solution": "\ndef len_base_conversion(x: int, base: int) -> int:\n    \"\"\" \n    Convert the numerical base of input number x to base and \n    return the length of string representation after the conversion. \n    base numbers are less than 10.\n    \n    >>> len_base_conversion(8, 3)\n    2\n    >>> len_base_conversion(8, 2)\n    4\n    >>> len_base_conversion(7, 2)\n    3\n    \"\"\"", "base_status": "fail", "plus_status": null, "base_fail_tests": [[7, 2]], "plus_fail_tests": []}], "EvoEval/1": [{"task_id": "EvoEval/1", "solution": "def round_and_flip(value: str) -> str:\n    num = float(value[:-3])\n    str_ = value[-3:]\n    if num >= 0:\n        num = round(num)\n    else:\n        num = round(num)\n    return str(num) + ' ' + str_.swapcase()", "base_status": "fail", "plus_status": null, "base_fail_tests": [["10.5abc"]], "plus_fail_tests": []}], "EvoEval/11": [{"task_id": "EvoEval/11", "solution": "\ndef planet_vowel_count(planet1, planet2):\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    vowel_count = 0\n    if planet1 not in planets or planet2 not in planets:\n        return 0\n    planet1_index = planets.index(planet1)\n    planet2_index = planets.index(planet2)\n    if planet1_index < planet2_index:\n        for planet in planets[planet1_index + 1:planet2_index]:\n            for letter in planet:\n                if letter in vowels:\n                    vowel_count += 1\n                elif letter == 'y' and planet[-1] == letter:\n                    vowel_count += 1\n    else:\n        for planet in planets[planet2_index + 1:planet1_index]:\n            for letter in planet:\n                if letter in vowels:\n                    vowel_count += 1\n                elif letter == 'y' and planet[-1] == letter:\n                    vowel_count += 1\n    return vowel_count", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Mercury", "Uranus"]], "plus_fail_tests": []}], "EvoEval/29": [{"task_id": "EvoEval/29", "solution": "def largest_prime_factor_or_value(n, x, y):\n    if n == 1:\n        return y\n    elif is_prime(n):\n        return x\n    else:\n        return largest_prime_factor(n)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[60, 34, 12]], "plus_fail_tests": []}], "EvoEval/95": [{"task_id": "EvoEval/95", "solution": "\nfrom typing import List\n\ndef filter_sort_strings(strings: List[str], substring: str) -> List[str]:\n    filtered_strings = [s for s in strings if substring in s and len(s) % 2 == 0]\n    sorted_strings = sorted(filtered_strings, key=lambda s: (len(s), s))\n    return sorted_strings", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/43": [{"task_id": "EvoEval/43", "solution": "\ndef sorted_fib4_sequence(n: int):\n    fib4 = [0, 0, 2, 0]\n    for i in range(4, n):\n        fib4.append(fib4[i - 1] + fib4[i - 2] + fib4[i - 3] + fib4[i - 4])\n    if (fib4[0] + fib4[-1]) % 2 == 0:\n        return sorted(fib4, reverse=True)\n    else:\n        return sorted(fib4)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1]], "plus_fail_tests": []}], "EvoEval/39": [{"task_id": "EvoEval/39", "solution": "def smallest_change_and_sum(arr, x, y):\n    n = len(arr)\n    changes = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            changes += 1\n    return changes + x + y", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/56": [{"task_id": "EvoEval/56", "solution": "def product_of_odd_prime_factors(n):\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    odd_factors = [f for f in factors if f % 2 != 0]\n    if odd_factors:\n        return int(prod(odd_factors))\n    else:\n        return 0", "base_status": "fail", "plus_status": null, "base_fail_tests": [[20]], "plus_fail_tests": []}], "EvoEval/93": [{"task_id": "EvoEval/93", "solution": "\ndef prime_vowel(string):\n    if not is_prime(len(string)):\n        return ''\n    vowels = 'aeiouAEIOU'\n    for i in range(len(string) - 2, 0, -1):\n        if string[i] in vowels and string[i - 1] not in vowels and (string[i + 1] not in vowels):\n            return string[i]\n    return ''", "base_status": "fail", "plus_status": null, "base_fail_tests": [["ab"]], "plus_fail_tests": []}], "EvoEval/41": [{"task_id": "EvoEval/41", "solution": "\ndef shifted_upper_count(s, shift):\n    vowels = 'AEIOU'\n    count = 0\n    if shift > len(s):\n        s = s[::-1]\n    for i in range(len(s)):\n        if i % 2 == 0 and s[i].isupper() and (s[i] in vowels):\n            count += 1\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [["dBBE", 3]], "plus_fail_tests": []}], "EvoEval/49": [{"task_id": "EvoEval/49", "solution": "\ndef modp_count(arr, n: int, p: int):\n    twon_mod_p = pow(2, n, p)\n    count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            first_digit = -1\n        else:\n            first_digit = 1\n        digit_sum = sum((int(digit) for digit in str(num)))\n        if digit_sum > twon_mod_p:\n            count += first_digit\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[-1, 11, -11], 4, 5]], "plus_fail_tests": []}], "EvoEval/9": [{"task_id": "EvoEval/9", "solution": "def planet_to_roman_distance(planet1, planet2):\n    planets = {'mercury': 1, 'venus': 2, 'earth': 3, 'mars': 4, 'jupiter': 5, 'saturn': 6, 'uranus': 7, 'neptune': 8}\n    roman_numerals = {1: 'i', 2: 'ii', 3: 'iii', 4: 'iv', 5: 'v', 6: 'vi', 7: 'vii', 8: 'viii'}\n    if planet1 not in planets or planet2 not in planets:\n        return {}\n    planet1_position = planets[planet1.lower()]\n    planet2_position = planets[planet2.lower()]\n    if planet1_position > planet2_position:\n        (planet1_position, planet2_position) = (planet2_position, planet1_position)\n    result = {}\n    for (planet, position) in planets.items():\n        if planet1_position < position < planet2_position:\n            result[planet] = roman_numerals[position]\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Mercury", "Neptune"]], "plus_fail_tests": []}], "EvoEval/54": [{"task_id": "EvoEval/54", "solution": "\nimport math\n\ndef max_sum_of_prime_subarray(nums):\n    max_sum = 0\n    current_sum = 0\n    start = 0\n    for end in range(len(nums)):\n        if is_prime(nums[end]):\n            current_sum += nums[end]\n        else:\n            if current_sum > max_sum:\n                max_sum = current_sum\n                start = end\n            current_sum = 0\n    if current_sum > max_sum:\n        max_sum = current_sum\n    return max_sum", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[2, 3, 5, 7, 11, 13]]], "plus_fail_tests": []}], "EvoEval/77": [{"task_id": "EvoEval/77", "solution": "\ndef mixed_solution(arr):\n    result = 0\n    for i in range(len(arr)):\n        if i % 2 == 0 and arr[i] % 2 != 0:\n            digits = list(str(arr[i]))\n            if any((int(d) > 0 for d in digits)):\n                result += arr[i]\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[-35, 13, 24, 321]]], "plus_fail_tests": []}], "EvoEval/38": [{"task_id": "EvoEval/38", "solution": "\ndef even_odd_zero_sum(l, n):\n    even_palindromes = 0\n    odd_palindromes = 0\n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                even_palindromes += 1\n            else:\n                odd_palindromes += 1\n    even_sum = False\n    odd_sum = False\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            if l[i] + l[j] == even_palindromes:\n                even_sum = True\n            if l[i] + l[j] == odd_palindromes:\n                odd_sum = True\n    return (even_sum, odd_sum)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/73": [{"task_id": "EvoEval/73", "solution": "\nfrom typing import List\nfrom fractions import Fraction\n\ndef filter_and_simplify(fractions: List[str], n: str) -> List[bool]:\n    n_fraction = Fraction(n)\n    result = []\n    for fraction in fractions:\n        frac = Fraction(fraction)\n        if frac * n_fraction == frac.numerator:\n            result.append(True)\n        else:\n            result.append(False)\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["1/3", "2/1", "3/2"], "2/1"]], "plus_fail_tests": []}], "EvoEval/60": [{"task_id": "EvoEval/60", "solution": "\ndef smallest_even_triple(arr, n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    triple = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    triple.append((a[i], a[j], a[k]))\n    if not triple:\n        return []\n    triple.sort(key=lambda x: x[0])\n    arr.append(triple[0][0])\n    even_val = [x for x in arr if x % 2 == 0]\n    if not even_val:\n        return []\n    even_val.sort()\n    return [even_val[0], arr.index(even_val[0])]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/64": [{"task_id": "EvoEval/64", "solution": "\ndef modp_prime_numbers(n: int, p: int):\n    modulo_result = pow(2, n, p)\n    prime_numbers = []\n    if modulo_result < 2:\n        return prime_numbers\n    if modulo_result == 2:\n        return [2]\n    if modulo_result == 3:\n        return [3]\n    if modulo_result == 5:\n        return [5]\n    if modulo_result == 7:\n        return [7]\n    if modulo_result % 2 == 0:\n        return prime_numbers\n    if modulo_result % 3 == 0:\n        return prime_numbers\n    if modulo_result % 5 == 0:\n        return prime_numbers\n    if modulo_result % 7 == 0:\n        return prime_numbers\n    if modulo_result > 7:\n        for i in range(3, int(modulo_result ** 0.5) + 1, 2):\n            if modulo_result % i == 0:\n                break", "base_status": "fail", "plus_status": null, "base_fail_tests": [[3, 11]], "plus_fail_tests": []}], "EvoEval/87": [{"task_id": "EvoEval/87", "solution": "\ndef match_and_remove_unbalanced(text):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    stack = []\n    for char in text:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or stack[-1] != '(':\n                return ''.join([c for c in text if c not in vowels])\n            stack.pop()\n    if stack:\n        return ''.join([c for c in text if c not in vowels])\n    return text", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/7": [{"task_id": "EvoEval/7", "solution": "\ndef sum_square_cube_to_n(n: int):\n    result = []\n    for i in range(1, n + 1):\n        if i % 3 == 0:\n            result.append(i ** 2)\n        elif i % 4 == 0:\n            result.append(i ** 3)\n        else:\n            result.append(i)\n    return sum(result)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/5": [{"task_id": "EvoEval/5", "solution": "\nfrom typing import List\n\ndef sort_and_check(numbers: List[float], threshold: float) -> List[float]:\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                if round(sum(numbers[:2])) % 2 == 0:\n                    return sorted(numbers, reverse=True)\n                else:\n                    return sorted(numbers)\n    return numbers", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3]], "plus_fail_tests": []}], "EvoEval/28": [{"task_id": "EvoEval/28", "solution": "\ndef grade_with_same_chars(grades: list, s0: str, s1: str):\n    grading_table = {4.0: 'A+', 3.7: 'A', 3.3: 'A-', 3.0: 'B+', 2.7: 'B', 2.3: 'B-', 2.0: 'C+', 1.7: 'C', 1.3: 'C-', 1.0: 'D+', 0.7: 'D', 0.0: 'D-', 0.0: 'E'}\n    if set(s0) == set(s1):\n        return [grading_table[gpa] for gpa in grades]\n    else:\n        return []", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[4.0, 3, 1.7, 2, 3.5], "aaabcd", "dddcba"]], "plus_fail_tests": []}], "EvoEval/51": [{"task_id": "EvoEval/51", "solution": "\ndef modify_and_compare(a, b):\n    if isinstance(a, str) and any((char.isalpha() for char in a)):\n        if a.isupper():\n            a = a.lower()\n        else:\n            a = a.upper()\n    elif isinstance(a, str):\n        a = a[::-1]\n    if isinstance(b, str) and any((char.isalpha() for char in b)):\n        if b.isupper():\n            b = b.lower()\n        else:\n            b = b.upper()\n    elif isinstance(b, str):\n        b = b[::-1]\n    try:\n        a = float(a.replace(',', '.'))\n    except ValueError:\n        pass\n    try:\n        b = float(b.replace(',', '.'))\n    except ValueError:\n        pass\n    if isinstance(a, float) and isinstance(b, float):\n        if a > b:\n            return a\n        elif a < b:\n            return b\n        else:\n            return None\n    elif isinstance(a, float):\n        return a\n    else:\n        return b", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1, "1"]], "plus_fail_tests": []}], "EvoEval/69": [{"task_id": "EvoEval/69", "solution": "def sorted_happy_strings(lst):\n    happy_strings = []\n    for string in lst:\n        if len(string) >= 3:\n            is_happy = True\n            for i in range(len(string) - 2):\n                if string[i] == string[i + 1] or string[i] == string[i + 2] or string[i + 1] == string[i + 2]:\n                    is_happy = False\n                    break\n            if is_happy:\n                happy_strings.append(string)\n    happy_strings.sort(key=lambda x: (len(x), x))\n    return happy_strings", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["abcd", "aaa", "abc", "abccba", "cd"]]], "plus_fail_tests": []}], "EvoEval/66": [{"task_id": "EvoEval/66", "solution": "\ndef find_max_triple_sum(x, y, n):\n    largest_even = -1\n    for i in range(x, y + 1):\n        if i % 2 == 0 and i > largest_even:\n            largest_even = i\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    max_sum = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0 and a[i] + a[j] + a[k] > max_sum:\n                    max_sum = a[i] + a[j] + a[k]\n    if max_sum == -1:\n        return -1\n    if largest_even != -1:\n        max_sum += largest_even\n    return max_sum", "base_status": "fail", "plus_status": null, "base_fail_tests": [[17, 13, 6]], "plus_fail_tests": []}], "EvoEval/36": [{"task_id": "EvoEval/36", "solution": "\ndef mod_shift_sort(arr, n: int, p: int):\n    if not arr:\n        return True\n    arr.sort()\n    for i in range(len(arr)):\n        if arr[i] != arr[i % len(arr)]:\n            return False\n    return 2 ** n % p <= len(arr)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 4, 5, 1, 2], 0, 101]], "plus_fail_tests": []}], "EvoEval/79": [{"task_id": "EvoEval/79", "solution": "\ndef happy_case_string(s):\n    if len(s) < 3:\n        return s[::-1]\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i + 1] == s[i + 2] or s[i] == s[i + 2]:\n            return s[::-1]\n    new_s = ''\n    for c in s:\n        if c.isalpha():\n            new_s += c.lower() if c.isupper() else c.upper()\n        else:\n            new_s += c\n    return new_s", "base_status": "fail", "plus_status": null, "base_fail_tests": [["*#@"]], "plus_fail_tests": []}], "EvoEval/86": [{"task_id": "EvoEval/86", "solution": "\ndef evaluate_common_expressions(operators, operand_lists):\n    common_operands = set(operand_lists[0])\n    for operand_list in operand_lists[1:]:\n        common_operands &= set(operand_list)\n    if not common_operands:\n        return None\n    common_operands = sorted(common_operands)\n    result = common_operands[0]\n    for i in range(1, len(common_operands)):\n        operator = operators[i - 1]\n        if operator == '+':\n            result += common_operands[i]\n        elif operator == '-':\n            result -= common_operands[i]\n        elif operator == '*':\n            result *= common_operands[i]\n        elif operator == '//':\n            result //= common_operands[i]\n        elif operator == '**':\n            result **= common_operands[i]\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["+", "*", "-"], [[3, 4, 5, 2], [3, 5, 7, 8, 2], [3, 4, 5, 9, 2], [2, 3, 5, 6, 7, 8, 9]]]], "plus_fail_tests": []}], "EvoEval/72": [{"task_id": "EvoEval/72", "solution": "\nfrom typing import List\nfrom math import factorial\n\ndef special_close_factorials(numbers: List[int], threshold: int) -> bool:\n    \"\"\" \n    Check if in given list of numbers, are any two special factorials closer to each other than \n    given threshold. The special factorial (Brazilian factorial) is defined as n! * (n-1)! * (n-2)! * ... * 1! \n    where n > 0.\n\n    For example:\n    >>> special_close_factorials([2, 3], 10)\n    False\n    >>> special_close_factorials([1, 2, 3, 4], 100)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            special_factorial_i = factorial(numbers[i])\n            special_factorial_j = factorial(numbers[j])\n            if abs(special_factorial_i - special_factorial_j) <= threshold:\n                return True\n    return False", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 4], 100]], "plus_fail_tests": []}], "EvoEval/4": [{"task_id": "EvoEval/4", "solution": "\ndef largest_prime_divisor_digit_sum(lst: list) -> int:\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    largest_prime = 0\n    for num in lst:\n        if is_prime(num):\n            largest_prime = max(largest_prime, num)\n        else:\n            for i in range(2, num):\n                if num % i == 0 and is_prime(i):\n                    largest_prime = max(largest_prime, i)\n    return sum((int(digit) for digit in str(largest_prime)))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/48": [{"task_id": "EvoEval/48", "solution": "\nfrom typing import List\n\ndef prime_prefixed_strings(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Return a list of strings from the input list which start with the given prefix and their lengths are prime numbers.\n    \"\"\"\n    result = []\n    for string in strings:\n        if string.startswith(prefix) and is_prime(len(string)):\n            result.append(string)\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["apple", "avocado", "banana", "apricot"], "a"]], "plus_fail_tests": []}], "EvoEval/45": [{"task_id": "EvoEval/45", "solution": "\nfrom typing import List, Tuple\n\ndef primes_sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the prime numbers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1. Non-prime numbers should be ignored.\n    \"\"\"\n    sum_primes = 0\n    product_primes = 1\n    for num in numbers:\n        if is_prime(num):\n            sum_primes += num\n            product_primes *= num\n    return (sum_primes, product_primes)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[5, 25]]], "plus_fail_tests": []}], "EvoEval/6": [{"task_id": "EvoEval/6", "solution": "\ndef pile_median(n):\n    pile = []\n    for i in range(n):\n        if n % 2 == 0:\n            pile.append(n + 2 * i)\n        else:\n            pile.append(n + 2 * i)\n    pile.sort()\n    if n % 2 == 0:\n        return (pile[n // 2 - 1] + pile[n // 2]) / 2\n    else:\n        return pile[n // 2]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/18": [{"task_id": "EvoEval/18", "solution": "\ndef min_triplets_sum(nums: list):\n    n = len(nums)\n    if n < 3:\n        return 0\n    min_sum = float('inf')\n    for i in range(n - 2):\n        (left, right) = (i + 1, n - 1)\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            min_sum = min(min_sum, current_sum)\n            if current_sum < 0:\n                left += 1\n            else:\n                right -= 1\n    return min_sum if min_sum != float('inf') else 0", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, -6, 5, 1, 2]]], "plus_fail_tests": []}], "EvoEval/53": [{"task_id": "EvoEval/53", "solution": "\ndef hex_grade_calculator(grades):\n    prime_grades = ['D', 'B', '7', '5', '3']\n    count = 0\n    for grade in grades:\n        if grade == 4.0:\n            count += 1\n        elif grade > 3.7:\n            count += 1\n        elif grade > 3.3:\n            count += 1\n        elif grade > 3.0:\n            count += 1\n        elif grade > 2.7:\n            count += 1\n        elif grade > 2.3:\n            count += 1\n        elif grade > 2.0:\n            count += 1\n        elif grade > 1.7:\n            count += 1\n        elif grade > 1.3:\n            count += 1\n        elif grade > 1.0:\n            count += 1\n        elif grade > 0.7:\n            count += 1\n        elif grade > 0.0:\n            count += 1\n    return count", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[4.0, 3, 2.75, 1.9, 3.5]]], "plus_fail_tests": []}], "EvoEval/12": [{"task_id": "EvoEval/12", "solution": "\ndef grade_students(student_info, n):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    grades = {4.0: 'A+', 3.7: 'A', 3.3: 'A-', 3.0: 'B+', 2.7: 'B', 2.3: 'B-', 2.0: 'C+', 1.7: 'C', 1.3: 'C-', 1.0: 'D+', 0.7: 'D', 0.0: 'D-', 0.0: 'E'}\n    result = []\n    for student in student_info:\n        name = student['name']\n        gpa = student['GPA']\n        consonants = sum((1 for c in name if c.lower() not in vowels))\n        if consonants == n:\n            grade = grades.get(gpa, 'E')\n        else:\n            grade = grades.get(gpa - 0.3, 'E')\n        result.append({'name': name, 'grade': grade})\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[{"name": "Alice", "GPA": 3.0}, {"name": "Bob", "GPA": 2.3}, {"name": "Charlie", "GPA": 3.3}, {"name": "Dave", "GPA": 0.0}, {"name": "Eve", "GPA": 0.0}], 2]], "plus_fail_tests": []}], "EvoEval/80": [{"task_id": "EvoEval/80", "solution": "def cyclic_encode_delete(s: str, c: str) -> tuple:\n    encoded = ''\n    for i in range(0, len(s), 3):\n        group = s[i:i + 3]\n        encoded += group[1] + group[2] + group[0]\n    result = ''\n    for char in encoded:\n        if char not in c:\n            result += char\n    is_palindrome = result == result[::-1]\n    if not is_palindrome:\n        decoded = ''\n        for i in range(0, len(result), 3):\n            group = result[i:i + 3]\n            decoded += group[2] + group[0] + group[1]\n        result = decoded\n    return (result, is_palindrome)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["abcdef", "b"]], "plus_fail_tests": []}], "EvoEval/0": [{"task_id": "EvoEval/0", "solution": "def compare_happiness(a, b):\n\n    def is_happy(s):\n        if len(s) < 3:\n            return False\n        for i in range(len(s) - 2):\n            if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n                return False\n        return True\n    if not is_happy(a) and (not is_happy(b)):\n        return None\n    elif is_happy(a) and (not is_happy(b)):\n        return a\n    elif not is_happy(a) and is_happy(b):\n        return b\n    else:\n        a = float(a.replace(',', '.'))\n        b = float(b.replace(',', '.'))\n        if a > b:\n            return str(a).replace('.', ',')\n        elif a < b:\n            return str(b).replace('.', ',')\n        else:\n            return None", "base_status": "fail", "plus_status": null, "base_fail_tests": [["123.45", "234.56"]], "plus_fail_tests": []}], "EvoEval/25": [{"task_id": "EvoEval/25", "solution": "\nfrom typing import List, Tuple\n\ndef sum_product_triples(n: int) -> Tuple[int, int]:\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    sum_first_elements = 0\n    product_first_elements = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    sum_first_elements += a[i]\n                    product_first_elements *= a[i]\n    return (sum_first_elements, product_first_elements)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/58": [{"task_id": "EvoEval/58", "solution": "def max_freq_and_sum_check(lst, a, b):\n    freq = {}\n    max_freq = -1\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n        if freq[num] >= num and num > max_freq:\n            max_freq = num\n    if max_freq == -1:\n        return (-1, False)\n    elif a == max_freq + b or b == max_freq + a:\n        return (max_freq, True)\n    else:\n        return (max_freq, False)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/65": [{"task_id": "EvoEval/65", "solution": "\ndef modp_largest_divisor(n: int, p: int) -> int:\n    \"\"\"Return the largest number smaller than 'p' which divides (2^n modulo p) evenly. \n    If no such number exists, return 1.\n    \n    >>> modp_largest_divisor(3, 5)\n    3\n    >>> modp_largest_divisor(1101, 101)\n    2\n    >>> modp_largest_divisor(0, 101)\n    1\n    >>> modp_largest_divisor(3, 11)\n    8\n    \"\"\"\n    power = 2 ** n % p\n    largest_divisor = 1\n    for i in range(2, p):\n        if power % i == 0:\n            largest_divisor = i\n    return largest_divisor", "base_status": "fail", "plus_status": null, "base_fail_tests": [[99999999, 100000000]], "plus_fail_tests": []}], "EvoEval/17": [{"task_id": "EvoEval/17", "solution": "\ndef fibfib_search(n: int, lst: list) -> int:\n\n    def fibfib(n):\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 0\n        elif n == 2:\n            return 1\n        else:\n            return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n    freq = {}\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    fibfib_n = fibfib(n)\n    for num in sorted(freq.keys(), reverse=True):\n        if num > 0 and freq[num] >= fibfib_n:\n            return num\n    return -1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[100, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]], "plus_fail_tests": []}], "EvoEval/14": [{"task_id": "EvoEval/14", "solution": "\ndef prime_avg_range(n, m):\n    if n > m:\n        return -1\n    primes = []\n    for i in range(n, m + 1):\n        if i > 1:\n            for j in range(2, i):\n                if i % j == 0:\n                    break\n            else:\n                primes.append(i)\n    if not primes:\n        return -1\n    avg = round(sum(primes) / len(primes))\n    return bin(avg)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[7919, 104729]], "plus_fail_tests": []}]}}