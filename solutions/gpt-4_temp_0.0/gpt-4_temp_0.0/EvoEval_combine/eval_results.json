{"eval": {"EvoEval/98": [{"task_id": "EvoEval/98", "solution": "\ndef check_dict_bracketing(dict):\n    \"\"\"\n    Given a dictionary where all keys and values are strings, return True if all keys and values \n    follow these two rules, else return False. The function should return False if the given\n    dictionary is empty. \n\n    Rule 1: All keys are strings in lower case or all keys are strings in upper case.\n    Rule 2: All values are strings of \"(\" and \")\" and have correct bracketing - every opening \n    bracket has a corresponding closing bracket.\n\n    Examples:\n    check_dict_bracketing({\"a\":\"()\", \"b\":\"(())\"}) should return True.\n    check_dict_bracketing({\"a\":\"()\", \"A\":\"()\"}) should return False.\n    check_dict_bracketing({\"a\":\"(\", \"b\":\"()\"}) should return False.\n    check_dict_bracketing({\"Name\":\"()\", \"Age\":\"(())\"}) should return False.\n    check_dict_bracketing({\"STATE\":\"()\", \"ZIP\":\"(())\"}) should return True.\n    \"\"\"\n    if not dict:\n        return False\n    keys = list(dict.keys())\n    values = list(dict.values())\n    if not (all((key.islower() for key in keys)) or all((key.isupper() for key in keys))):\n        return False\n    for value in values:\n        stack = []\n        for char in value:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        if stack:\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/30": [{"task_id": "EvoEval/30", "solution": "\nfrom typing import List\n\ndef parse_music_simplify(x: str, music_string: str) -> List[bool]:\n    \"\"\" \n    Input to this function is a string, x, which is a fraction in the format of <numerator>/<denominator> where both numerator \n    and denominator are positive whole numbers and a string, music_string, representing musical notes in a special ASCII format.\n    \n    Your task is to parse the music_string and return a list of booleans corresponding to whether the beats of each note simplifies \n    the fraction x. \n\n    If x * beats evaluates to a whole number, add True to the list, otherwise add False. \n\n    Here is the legend for music_string:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    Example:\n    parse_music_simplify(\"1/4\", 'o o| .| o| o| .| .| .| .| o o')\n    [True, False, False, False, False, False, False, False, False, True, True]\n    \"\"\"\n    note_to_beats = {'o': 4, 'o|': 2, '.|': 1}\n    (numerator, denominator) = map(int, x.split('/'))\n    notes = music_string.split()\n    results = []\n    for note in notes:\n        product = numerator * note_to_beats[note] / denominator\n        if product.is_integer():\n            results.append(True)\n        else:\n            results.append(False)\n    return results", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/86": [{"task_id": "EvoEval/86", "solution": "\ndef evaluate_common_expressions(operators, operand_lists):\n    common_operands = list(set.intersection(*map(set, operand_lists)))\n    common_operands.sort()\n    if not common_operands:\n        return None\n    expression = str(common_operands[0])\n    for i in range(1, len(common_operands)):\n        expression += ' ' + operators[i - 1] + ' ' + str(common_operands[i])\n    return eval(expression)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/62": [{"task_id": "EvoEval/62", "solution": "\ndef strange_word_sort(text):\n    \"\"\"\n    Given a string text where words are separated by one or more spaces,\n    create a new string where the words are sorted in a strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining words, then minimum and so on.\n    The comparison of words is case-insensitive. \n    If there are more than 2 consecutive spaces between words, replace them with -.\n    If there is one space, replace it with underscore.\n\n    Examples:\n    strange_word_sort(\"apple Banana APPLE BANANA\") == 'apple_BANANA_APPLE_Banana'\n    strange_word_sort(\"  cat  dog   bird  \") == '__bird__dog-cat__'\n    strange_word_sort(\"House   car\") == 'car-House'\n    strange_word_sort(\"\") == \"\"\n    \"\"\"\n    words = text.split()\n    words.sort(key=str.lower)\n    result = []\n    while words:\n        result.append(words.pop(0))\n        if words:\n            result.append(words.pop())\n    result = ' '.join(result)\n    result = result.replace('  ', '-')\n    result = result.replace(' ', '_')\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["House   car"]], "plus_fail_tests": []}], "EvoEval/88": [{"task_id": "EvoEval/88", "solution": "\ndef process_and_sort_string(s):\n    words = s.replace(',', ' ').split()\n    words = [word for word in words if len(word) % 2 == 0]\n    words.sort(key=lambda x: (len(x), x))\n    return words", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/44": [{"task_id": "EvoEval/44", "solution": "\nfrom typing import List\n\ndef roman_prefixes(number: int) -> List[str]:\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string in lowercase.\n    Afterwards, return a list of all prefixes of the roman numeral from shortest to longest.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> roman_prefixes(19) == ['x', 'xi', 'xix']\n    >>> roman_prefixes(152) == ['c', 'cl', 'cli', 'clii']\n    >>> roman_prefixes(426) == ['c', 'cd', 'cdx', 'cdxx', 'cdxxv', 'cdxxvi']\n    \"\"\"\n    roman_numerals = {1: 'i', 4: 'iv', 5: 'v', 9: 'ix', 10: 'x', 40: 'xl', 50: 'l', 90: 'xc', 100: 'c', 400: 'cd', 500: 'd', 900: 'cm', 1000: 'm'}\n    keys = sorted(roman_numerals.keys(), reverse=True)\n    roman_string = ''\n    for key in keys:\n        while number >= key:\n            roman_string += roman_numerals[key]\n            number -= key\n    return [roman_string[:i + 1] for i in range(len(roman_string))]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/69": [{"task_id": "EvoEval/69", "solution": "def sorted_happy_strings(lst):\n\n    def is_happy(s):\n        if len(s) < 3:\n            return False\n        for i in range(len(s) - 2):\n            if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n                return False\n        return True\n    happy_strings = [s for s in lst if is_happy(s) and len(s) % 2 == 0]\n    happy_strings.sort(key=lambda s: (len(s), s))\n    return happy_strings", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/5": [{"task_id": "EvoEval/5", "solution": "\nfrom typing import List\n\ndef sort_and_check(numbers: List[float], threshold: float) -> List[float]:\n    \"\"\"\n    Given an array of numbers, check if any two numbers in the array are closer to each other \n    than the given threshold. If yes, sort the array according to the following rules:\n\n    - If the sum of the first and last numbers in the array is even, sort the array in descending order.\n    - If the sum of the first and last numbers in the array is odd, sort the array in ascending order.\n    \n    If no two numbers are closer than the threshold, return the array as it is.\n    \n    Note: Consider the sum as even or odd after rounding off to the nearest integer.\n\n    Examples:\n    * sort_and_check([1.0, 2.0, 3.0], 0.5) => [1.0, 2.0, 3.0]\n    * sort_and_check([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) => [1.0, 2.0, 2.8, 3.0, 4.0, 5.0]\n    * sort_and_check([4.0, 2.0, 3.0, 0.0], 2.0) => [4.0, 3.0, 2.0, 0.0]\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                if round(numbers[0] + numbers[-1]) % 2 == 0:\n                    return sorted(numbers, reverse=True)\n                else:\n                    return sorted(numbers)\n    return numbers", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/32": [{"task_id": "EvoEval/32", "solution": "\nfrom typing import List\n\ndef circular_shift_nested_parens(input: List[str], shift: int) -> List[int]:\n    \"\"\" \n    The input to this function is a list of strings. Each string represents multiple groups for nested parentheses \n    separated by spaces. For each group, calculate the deepest level of nesting of parentheses.\n    \n    After that, concatenate the list of nesting depths as a single number and apply a circular shift on that number. Shift \n    the digits of the number right by the provided shift value. If shift > number of digits, return digits reversed.\n    \n    Return the result as a list of individual digits after the circular shift.\n\n    >>> circular_shift_nested_parens(['(()())', '((()))', '()', '((())()())'], 2)\n    [1, 3, 2, 3]\n    >>> circular_shift_nested_parens(['(()())', '((()))', '()', '((())()())'], 1)\n    [3, 2, 3, 1]\n    \"\"\"\n    nesting_depths = []\n    for group in input:\n        depth = 0\n        max_depth = 0\n        for char in group:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        nesting_depths.append(max_depth)\n    number = int(''.join(map(str, nesting_depths)))\n    number_str = str(number)\n    if shift > len(number_str):\n        result = list(map(int, reversed(number_str)))\n    else:\n        result = list(map(int, number_str[-shift:] + number_str[:-shift]))\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/93": [{"task_id": "EvoEval/93", "solution": "\ndef prime_vowel(string):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    vowels = 'aeiouAEIOU'\n    if is_prime(len(string)):\n        for i in range(len(string) - 1, 0, -1):\n            if string[i] in vowels and string[i - 1] not in vowels and (string[i + 1] not in vowels):\n                return string[i]\n    return ''", "base_status": "fail", "plus_status": null, "base_fail_tests": [["abcdcba"]], "plus_fail_tests": []}], "EvoEval/47": [{"task_id": "EvoEval/47", "solution": "def count_odd_upper(s, lst):\n    vowels = 'AEIOU'\n    n = sum((1 for i in range(0, len(s), 2) if s[i] in vowels))\n    result = []\n    for string in lst:\n        m = sum((1 for digit in string if int(digit) % 2 != 0))\n        result.append(f'In the string, the number of uppercase vowels in even indices is {n}, and the number of odd digits is {m}.')\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/56": [{"task_id": "EvoEval/56", "solution": "def product_of_odd_prime_factors(n):\n\n    def prime_factors(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                factors.append(i)\n        if n > 1:\n            factors.append(n)\n        return factors\n    factors = prime_factors(n)\n    odd_prime_factors = set(filter(lambda x: x % 2 != 0, factors))\n    if not odd_prime_factors:\n        return 0\n    product = 1\n    for factor in odd_prime_factors:\n        product *= factor\n    return product", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/41": [{"task_id": "EvoEval/41", "solution": "\ndef shifted_upper_count(s, shift):\n    \"\"\"\n    Given a string s and an integer shift, perform a circular shift on the ASCII values of the characters in string \n    by the shift value. Return the count of uppercase vowels in even indices after the shift.\n\n    If shift > length of string, reverse the string before counting.\n\n    For example:\n    shifted_upper_count('aBCdEf', 1) returns 0\n    shifted_upper_count('abcdefg', 2) returns 0\n    shifted_upper_count('dBBE', 3) returns 1\n    \"\"\"\n    vowels = 'AEIOU'\n    if shift > len(s):\n        s = s[::-1]\n    s = [chr((ord(c) + shift - 65) % 26 + 65) if c.isupper() else chr((ord(c) + shift - 97) % 26 + 97) for c in s]\n    return sum((1 for i in range(0, len(s), 2) if s[i] in vowels))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/74": [{"task_id": "EvoEval/74", "solution": "def sum_exchange(lst1, lst2, x, y, z):\n    \"\"\"\n    In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n    If it is possible to exchange elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, the answer is \"YES\".\n    Otherwise, the answer is \"NO\".\n    After that, the function also takes in three more integers, x, y and z.\n    It will check if one of these integers is equal to the sum of the other two.\n    If this is true, append \"SUM\" to the front of the answer string.\n    Otherwise, append \"NO_SUM\" to the front of the answer string.\n    For example:\n    sum_exchange([1, 2, 3, 4], [1, 2, 3, 4], 5, 2, 2) => \"NO_SUM YES\"\n    sum_exchange([1, 2, 3, 4], [1, 5, 3, 4], 4, 2, 2) => \"SUM NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    even_lst1 = [num for num in lst1 if num % 2 == 0]\n    odd_lst2 = [num for num in lst2 if num % 2 != 0]\n    if len(even_lst1) + len(odd_lst2) >= len(lst1):\n        answer = 'YES'\n    else:\n        answer = 'NO'\n    if x == y + z or y == x + z or z == x + y:\n        answer = 'SUM ' + answer\n    else:\n        answer = 'NO_SUM ' + answer\n    return answer", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 4], [1, 5, 3, 4], 4, 2, 2]], "plus_fail_tests": []}], "EvoEval/31": [{"task_id": "EvoEval/31", "solution": "\nfrom typing import List\n\ndef special_prime_factorial(n: int) -> int:\n    \"\"\" \n    This function first factorizes the input 'n' into its prime factors and then calculates a special factorial.\n    The 'special factorial' is defined as the product of factorials of all the prime factors of 'n'.\n    The factors should be calculated number of times corresponding to how many times they appear in the factorization.\n    The function should return the product of these factorials.\n    \n    For instance,\n    >>> special_prime_factorial(8)\n    8  # because 8 = 2*2*2; 2! * 2! * 2! = 2 * 2 * 2 = 8\n    >>> special_prime_factorial(25)\n    14400 # because 25 = 5*5; 5! * 5! = 120 * 120 = 14400\n    >>> special_prime_factorial(70)\n    1209600 # because 70 = 2 * 5 * 7; 2! * 5! * 7! = 2 * 120 * 5040 = 1209600\n    \"\"\"\n    \" \\n    This function first factorizes the input 'n' into its prime factors and then calculates a special factorial.\\n    The 'special factorial' is defined as the product of factorials of all the prime factors of 'n'.\\n    The factors should be calculated number of times corresponding to how many times they appear in the factorization.\\n    The function should return the product of these factorials.\\n    \"\n    factors = prime_factors(n)\n    result = 1\n    for factor in factors:\n        result *= math.factorial(factor)\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[70]], "plus_fail_tests": []}], "EvoEval/76": [{"task_id": "EvoEval/76", "solution": "def sort_prime_digit_sum(lst):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def digit_sum(n):\n        return sum((int(digit) for digit in str(n)))\n    new_lst = [digit_sum(n) if is_prime(n) else n for n in lst]\n    if (new_lst[0] + new_lst[-1]) % 2 == 0:\n        return sorted(new_lst, reverse=True)\n    else:\n        return sorted(new_lst)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[]]], "plus_fail_tests": []}], "EvoEval/54": [{"task_id": "EvoEval/54", "solution": "\nimport math\n\ndef max_sum_of_prime_subarray(nums):\n    \"\"\"\n    Given an array of integers nums, find the maximum sum of any non-empty sub-array\n    of prime nums. If no prime subarray exists, return 0.\n    A prime number is a number that has exactly two distinct positive divisors: 1 and itself.\n    You may assume that all numbers in the array are greater than 0.\n    \n    Example\n    max_sum_of_prime_subarray([1, 2, 3, 4, 5, 6]) == 5  # The subarray [2, 3] is a subarray with primes, and it has the maximum sum, so their sum, 5, is returned\n    max_sum_of_prime_subarray([4, 6, 8, 10]) == 0 # There are no primes in the list\n    max_sum_of_prime_subarray([2, 3, 5, 7, 11, 13]) == 41 # All numbers in this list are primes, so their sum, 41, is returned\n    \"\"\"\n    max_sum = 0\n    current_sum = 0\n    for num in nums:\n        if is_prime(num):\n            current_sum += num\n            max_sum = max(max_sum, current_sum)\n        else:\n            current_sum = 0\n    return max_sum", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[2, 3, 5, 7, 11, 13]]], "plus_fail_tests": []}], "EvoEval/22": [{"task_id": "EvoEval/22", "solution": "def binary_planet_distance(planet1, planet2):\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return ''\n    else:\n        planet1_index = planets.index(planet1)\n        planet2_index = planets.index(planet2)\n        if planet1_index < planet2_index:\n            distance = planet2_index - planet1_index - 1\n        else:\n            distance = planet1_index - planet2_index - 1\n        binary_distance = bin(distance)[2:]\n        return 'bd' + binary_distance + 'bd'", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Neptune", "Neptune"]], "plus_fail_tests": []}], "EvoEval/75": [{"task_id": "EvoEval/75", "solution": "def transform_dict(input_dict):\n    \"\"\"\n    Create a function that takes a dictionary as an input where keys are strings and values are strings \n    representing numbers. The function should return a new dictionary where the keys remain the same, \n    but each value is replaced with the closest integer to it. If the number is equidistant from two \n    integers, round it away from zero. The function should return an empty dictionary if keys are not \n    all in upper case or all in lower case.\n\n    The function should also return an empty dictionary if the given dictionary is empty or if keys are not all strings.\n\n    Examples:\n\n    >>> transform_dict({\"a\":\"10\", \"b\":\"15.3\"})\n    {\"a\": 10, \"b\": 15}\n    >>> transform_dict({\"A\":\"10.5\", \"B\":\"-15.5\"})\n    {\"A\": 11, \"B\": -16}\n    >>> transform_dict({\"a\":\"10\", \"B\":\"15.3\"})\n    {}\n    >>> transform_dict({\"a\": \"10.5\", 8: \"-15.5\"})\n    {}\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant from two integers, the one \n    you should return is the one that is the farthest from zero. For example, if the value string \n    represents \"14.5\", it should return 15 and if it represents \"-14.5\", it should return -15.\n    \"\"\"\n    if not input_dict or not all((isinstance(k, str) for k in input_dict.keys())):\n        return {}\n    if not all((k.isupper() for k in input_dict.keys())) and (not all((k.islower() for k in input_dict.keys()))):\n        return {}\n    return {k: round(float(v)) if float(v) - int(float(v)) != 0.5 else int(float(v)) + 1 if float(v) > 0 else int(float(v)) - 1 for (k, v) in input_dict.items()}", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"A": "", "B": " "}]], "plus_fail_tests": []}], "EvoEval/20": [{"task_id": "EvoEval/20", "solution": "\ndef grade_and_case(s, grades):\n    result = []\n    for i in range(len(s)):\n        name = s[i].swapcase()\n        if grades[i] == 4.0:\n            grade = 'A+'\n        elif grades[i] > 3.7:\n            grade = 'A'\n        elif grades[i] > 3.3:\n            grade = 'A-'\n        elif grades[i] > 3.0:\n            grade = 'B+'\n        elif grades[i] > 2.7:\n            grade = 'B'\n        elif grades[i] > 2.3:\n            grade = 'B-'\n        elif grades[i] > 2.0:\n            grade = 'C+'\n        elif grades[i] > 1.7:\n            grade = 'C'\n        elif grades[i] > 1.3:\n            grade = 'C-'\n        elif grades[i] > 1.0:\n            grade = 'D+'\n        elif grades[i] > 0.7:\n            grade = 'D'\n        elif grades[i] > 0.0:\n            grade = 'D-'\n        else:\n            grade = 'E'\n        result.append((name, grade))\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/11": [{"task_id": "EvoEval/11", "solution": "\ndef planet_vowel_count(planet1, planet2):\n    \"\"\"\n    There are eight planets in our solar system: the closest to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return an integer representing the number of vowels \n    in the names of the planets whose orbits are located between the orbit of \n    planet1 and the orbit of planet2, sorted by the proximity to the sun. \n\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given planet name.\n\n    If planet1 or planet2 are not correct planet names, the function should return 0.\n\n    Examples\n    planet_vowel_count(\"Jupiter\", \"Neptune\") ==> 5  # (Saturn = 2, Uranus = 3)\n    planet_vowel_count(\"Earth\", \"Mercury\") ==> 2  # (Venus = 2)\n    planet_vowel_count(\"Mercury\", \"Uranus\") ==> 10  # (Venus = 2, Earth = 2, Mars = 1, Jupiter = 3, Saturn = 2)\n    \"\"\"\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return 0\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    if index1 > index2:\n        (index1, index2) = (index2, index1)\n    between_planets = planets[index1 + 1:index2]\n    vowel_count = 0\n    for planet in between_planets:\n        for char in planet:\n            if char.lower() in 'aeiou' or (char.lower() == 'y' and char == planet[-1]):\n                vowel_count += 1\n    return vowel_count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/8": [{"task_id": "EvoEval/8", "solution": "\ndef correct_bracket_sequence_and_count(string: str, bracket: str) -> tuple:\n    \"\"\"\n    This function checks if a given string has correctly paired opening and closing brackets and \n    counts how many times a specific bracket appears in the string, including overlapping cases.\n    \n    The function takes a string of \"<\" and \">\" characters and a specific bracket (\"<\" or \">\") \n    as inputs, and returns a tuple with a boolean value and an integer. The boolean value represents \n    whether every opening bracket has a corresponding closing bracket. The integer represents the \n    count of the specific bracket in the string.\n\n    >>> correct_bracket_sequence_and_count('<<><>>', '<')\n    (True, 3)\n    >>> correct_bracket_sequence_and_count('<<><>>', '>')\n    (True, 3)\n    >>> correct_bracket_sequence_and_count('<>', '<')\n    (True, 1)\n    >>> correct_bracket_sequence_and_count('><<>', '>')\n    (False, 2)\n    >>> correct_bracket_sequence_and_count('', '>')\n    (True, 0)\n    \"\"\"", "base_status": "fail", "plus_status": null, "base_fail_tests": [["", ">"]], "plus_fail_tests": []}], "EvoEval/15": [{"task_id": "EvoEval/15", "solution": "from typing import List\n\ndef balance_triples(operations: List[int]) -> bool:\n    balance = 0\n    zero_count = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return False\n        if balance == 0:\n            zero_count += 1\n    return zero_count >= 3", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/17": [{"task_id": "EvoEval/17", "solution": "\ndef fibfib_search(n: int, lst: list) -> int:\n    \"\"\"\n    Implement a function that computes the n-th element of the FibFib sequence as defined by:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n    \n    The function should then evaluate a non-empty list of positive integers, and return the greatest \n    integer in the list that is greater than zero, and has a frequency equal to or greater than the value\n    of the calculated n-th FibFib element. The frequency of an integer is the number of times it appears \n    in the list.\n\n    If no such value exists, return -1.\n\n    Examples:\n        fibfib_search(5, [4, 1, 2, 2, 3, 1, 1, 1, 1]) == 1\n        fibfib_search(3, [1, 2, 2, 3, 3, 3, 4, 4, 4]) == 4\n        fibfib_search(6, [5, 5, 4, 4, 4, 1, 1, 1, 1, 1]) == -1\n    \"\"\"\n    fibfib = [0, 0, 1]\n    for i in range(3, n + 1):\n        fibfib.append(fibfib[i - 1] + fibfib[i - 2] + fibfib[i - 3])\n    nth_fibfib = fibfib[n]\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    max_num = -1\n    for (num, freq) in freq_dict.items():\n        if num > 0 and freq >= nth_fibfib and (num > max_num):\n            max_num = num\n    return max_num", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/78": [{"task_id": "EvoEval/78", "solution": "\ndef solve_and_count(s):\n    if not any((c.isalpha() for c in s)):\n        return (s[::-1], 0)\n    else:\n        s = s.swapcase()\n        vowels = 'AEIOU'\n        count = sum((1 for i in range(0, len(s), 2) if s[i] in vowels))\n        return (s, count)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/46": [{"task_id": "EvoEval/46", "solution": "\ndef get_max_even_positive(l):\n    positive_even_numbers = [num for num in l if num > 0 and num % 2 == 0]\n    if not positive_even_numbers:\n        return -1\n    return max(positive_even_numbers)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/23": [{"task_id": "EvoEval/23", "solution": "\ndef special_stone_factorial(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones. The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n\n    For each level, calculate the Brazilian factorial (defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!), \n    where n is the number of stones in the level.\n\n    Return the list of Brazilian factorials for each level.\n\n    For example:\n    >>> special_stone_factorial(3)\n    [12, 34560, 125411328000]\n    \"\"\"\n    result = []\n    for i in range(n, 0, -1):\n        result.append(brazilian_factorial(i))\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1]], "plus_fail_tests": []}], "EvoEval/84": [{"task_id": "EvoEval/84", "solution": "\nfrom typing import List, Dict\n\ndef prefixes_histogram(string: str) -> Dict[str, Dict[str, int]]:\n    \"\"\" Given a string, return a dictionary where the keys are all the prefixes of the string,\n    and the values are dictionaries representing the histograms of the individual letters in each prefix. \n    The histogram dictionaries should contain the letter with the most repetition and the corresponding count.\n    If several letters have the same occurrence, include all of them.\n    \n    Example:\n    prefixes_histogram('abc') == {'a': {'a': 1}, 'ab': {'a': 1, 'b': 1}, 'abc': {'a': 1, 'b': 1, 'c': 1}}\n    prefixes_histogram('aba') == {'a': {'a': 1}, 'ab': {'a': 1, 'b': 1}, 'aba': {'a': 2}}\n    prefixes_histogram('') == {}\n    \"\"\"\n    result = {}\n    for i in range(1, len(string) + 1):\n        prefix = string[:i]\n        histogram = Counter(prefix)\n        max_count = max(histogram.values(), default=0)\n        result[prefix] = {char: count for (char, count) in histogram.items() if count == max_count}\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["aba"]], "plus_fail_tests": []}], "EvoEval/42": [{"task_id": "EvoEval/42", "solution": "\ndef check_expression(expression: str) -> bool:\n    import re\n    from fractions import Fraction\n    expressions = re.findall('<(.*?)>', expression)\n    if expression.count('<') != expression.count('>'):\n        return False\n    for expr in expressions:\n        fractions = expr.split(',')\n        product = 1\n        for fraction in fractions:\n            (numerator, denominator) = map(int, fraction.split('/'))\n            product *= Fraction(numerator, denominator)\n        if product.denominator != 1:\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/4": [{"task_id": "EvoEval/4", "solution": "\ndef largest_prime_divisor_digit_sum(lst):\n    largest_prime = 0\n    for num in lst:\n        if is_prime(num):\n            largest_prime = max(largest_prime, num)\n        else:\n            for i in range(num - 1, 1, -1):\n                if num % i == 0 and is_prime(i):\n                    largest_prime = max(largest_prime, i)\n                    break\n    return sum((int(digit) for digit in str(largest_prime)))", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[84, 91, 97, 101, 105]]], "plus_fail_tests": []}], "EvoEval/66": [{"task_id": "EvoEval/66", "solution": "\ndef find_max_triple_sum(x, y, n):\n    largest_even = -1\n    for i in range(y, x - 1, -1):\n        if i % 2 == 0:\n            largest_even = i\n            break\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    triple_sum = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                current_sum = a[i] + a[j] + a[k]\n                if current_sum % 3 == 0 and current_sum > triple_sum:\n                    triple_sum = current_sum\n    if triple_sum == -1:\n        return -1\n    if largest_even == -1:\n        return triple_sum\n    return triple_sum + largest_even", "base_status": "fail", "plus_status": null, "base_fail_tests": [[17, 13, 6]], "plus_fail_tests": []}], "EvoEval/12": [{"task_id": "EvoEval/12", "solution": "\ndef grade_students(student_info, n):\n    \"\"\"You are a programming teacher and the semester is ending. You have a list of dictionaries, each containing \n    the name and GPA of a student. Additionally, you have a special grading system. Each student's name contributes \n    to their final grade based on the number of consonants in their name. If their name contains exactly n consonants,\n    their final grade gets bumped up one level according to the grading scale below:\n\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n\n    Write a function that takes the list of students and the number n and returns a list of dictionaries with each \n    student's name and their final letter grade. If the student name does not contain exactly n consonants, the grade \n    is not bumped up.\n\n    Example:\n    grade_students([{'name': 'Alice', 'GPA': 3.0}, {'name': 'Bob', 'GPA': 2.3}, {'name': 'Charlie', 'GPA': 3.3}], 2) \n    ==> [{'name': 'Alice', 'grade': 'B+'}, {'name': 'Bob', 'grade': 'B-'}, {'name': 'Charlie', 'grade': 'B+'}]\n    \"\"\"\n\n    def count_consonants(name):\n        return sum((1 for char in name.lower() if char in 'bcdfghjklmnpqrstvwxyz'))\n\n    def get_grade(gpa):\n        if gpa == 4.0:\n            return 'A+'\n        elif gpa > 3.7:\n            return 'A'\n        elif gpa > 3.3:\n            return 'A-'\n        elif gpa > 3.0:\n            return 'B+'\n        elif gpa > 2.7:\n            return 'B'\n        elif gpa > 2.3:\n            return 'B-'\n        elif gpa > 2.0:\n            return 'C+'\n        elif gpa > 1.7:\n            return 'C'\n        elif gpa > 1.3:\n            return 'C-'\n        elif gpa > 1.0:\n            return 'D+'\n        elif gpa > 0.7:\n            return 'D'\n        elif gpa > 0.0:\n            return 'D-'\n        else:\n            return 'E'\n\n    def bump_grade(grade):\n        if grade == 'A+':\n            return 'A+'\n        elif grade == 'A':\n            return 'A+'\n        elif grade == 'A-':\n            return 'A'\n        elif grade == 'B+':\n            return 'A-'\n        elif grade == 'B':\n            return 'B+'\n        elif grade == 'B-':\n            return 'B'\n        elif grade == 'C+':\n            return 'B-'\n        elif grade == 'C':\n            return 'C+'\n        elif grade == 'C-':\n            return 'C'\n        elif grade == 'D+':\n            return 'C-'\n        elif grade == 'D':\n            return 'D+'\n        elif grade == 'D-':\n            return 'D'\n        else:\n            return 'D+'\n    for student in student_info:\n        student['grade'] = get_grade(student['GPA'])\n        if count_consonants(student['name']) == n:\n            student['grade'] = bump_grade(student['grade'])\n    return student_info", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[{"name": "Alice", "GPA": 3.0}, {"name": "Bob", "GPA": 2.3}, {"name": "Charlie", "GPA": 3.3}, {"name": "Dave", "GPA": 0.0}, {"name": "Eve", "GPA": 0.0}], 2]], "plus_fail_tests": []}], "EvoEval/99": [{"task_id": "EvoEval/99", "solution": "\ndef len_base_conversion(x: int, base: int) -> int:\n    \"\"\" \n    Convert the numerical base of input number x to base and \n    return the length of string representation after the conversion. \n    base numbers are less than 10.\n    \n    >>> len_base_conversion(8, 3)\n    2\n    >>> len_base_conversion(8, 2)\n    4\n    >>> len_base_conversion(7, 2)\n    3\n    \"\"\"\n    converted_number = ''\n    while x > 0:\n        (x, remainder) = divmod(x, base)\n        converted_number = str(remainder) + converted_number\n    return len(converted_number)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/58": [{"task_id": "EvoEval/58", "solution": "def max_freq_and_sum_check(lst, a, b):\n    from collections import Counter\n    count = Counter(lst)\n    max_freq = -1\n    for (num, freq) in count.items():\n        if freq >= num and num > max_freq:\n            max_freq = num\n    if max_freq == -1:\n        return (-1, False)\n    else:\n        return (max_freq, a == max_freq + b or b == max_freq + a)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/0": [{"task_id": "EvoEval/0", "solution": "def compare_happiness(a, b):\n\n    def is_happy(s):\n        s = s.replace(',', '.')\n        if len(s) < 3:\n            return False\n        for i in range(len(s) - 2):\n            if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n                return False\n        return True\n    a_happy = is_happy(a)\n    b_happy = is_happy(b)\n    if not a_happy and (not b_happy):\n        return None\n    elif a_happy and (not b_happy):\n        return a\n    elif not a_happy and b_happy:\n        return b\n    else:\n        a = a.replace(',', '.')\n        b = b.replace(',', '.')\n        if float(a) > float(b):\n            return a\n        elif float(b) > float(a):\n            return b\n        else:\n            return None", "base_status": "fail", "plus_status": null, "base_fail_tests": [["1,234", "5,678"]], "plus_fail_tests": []}], "EvoEval/90": [{"task_id": "EvoEval/90", "solution": "\ndef vowels_in_dict_keys(dict):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    result = {}\n    keys = list(dict.keys())\n    if not all((isinstance(key, str) for key in keys)):\n        return {}\n    if not (all((key.islower() for key in keys)) or all((key.isupper() for key in keys))):\n        return {}\n    for key in keys:\n        count = sum((1 for char in key if char.lower() in vowels))\n        if key.endswith('y') or key.endswith('Y'):\n            count += 1\n        result[key] = count\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/24": [{"task_id": "EvoEval/24", "solution": "from typing import List\n\ndef sort_happy_numbers(numbers: str) -> str:\n    \"\"\" \n    Input is a space-delimited string of numerals from 'zero' to 'nine'. Valid choices are 'zero', 'one', 'two', \n    'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'. This function has two main operations:\n    \n    1) It checks if the string of numbers is 'happy'. A string is happy if, after removing spaces from the string, every 3 consecutive letters are distinct.\n    For instance, 'one two three' is not happy, but 'one one two' is happy. If the string is not happy, return 'Not a happy string'.\n    \n    2) If the string is happy, it sorts the string with numbers from smallest to largest and returns the sorted string.\n    \n    >>> sort_happy_numbers('three one five')\n    'Not a happy string'\n    \n    >>> sort_happy_numbers('three two two')\n    'Not a happy string'\n    \n    >>> sort_happy_numbers('five two eight')\n    'two five eight'\n    \"\"\"\n    no_spaces = numbers.replace(' ', '')\n    for i in range(len(no_spaces) - 2):\n        if no_spaces[i] == no_spaces[i + 1] or no_spaces[i] == no_spaces[i + 2] or no_spaces[i + 1] == no_spaces[i + 2]:\n            return 'Not a happy string'\n    num_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    num_list = numbers.split()\n    num_list.sort(key=lambda x: num_dict[x])\n    return ' '.join(num_list)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/89": [{"task_id": "EvoEval/89", "solution": "\nfrom typing import List\n\ndef md5_substring_filter(strings: List[str], hash_substring: str) -> List[str]:\n    \"\"\"\n    Given a list of strings 'strings' and a hash_substring, return a list of strings \n    for which the md5 hash equivalent string contains the hash_substring.\n    If 'strings' is an empty list, return None.\n    The md5 hash of an empty string should not be considered.\n\n    >>> md5_substring_filter(['Hello world', 'Python', ''], '3e25960a79dbc69b674cd4ec67a72c62')\n    ['Hello world']\n    >>> md5_substring_filter(['Python', 'Hello', '123', ''], '96')\n    ['Hello', '123']\n    \"\"\"\n    if not strings:\n        return None\n    result = []\n    for string in strings:\n        if string:\n            md5_hash = hashlib.md5(string.encode()).hexdigest()\n            if hash_substring in md5_hash:\n                result.append(string)\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["Python", "Hello", "123", ""], "96"]], "plus_fail_tests": []}], "EvoEval/96": [{"task_id": "EvoEval/96", "solution": "\ndef common_pairs_with_zero_sum(l1: list, l2: list) -> bool:\n    common_elements = set(l1) & set(l2)\n    for element in common_elements:\n        if -element in common_elements and element != -element:\n            return True\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/97": [{"task_id": "EvoEval/97", "solution": "\ndef fib_max_triples(n):\n    fib = [0, 0, 1]\n    for i in range(3, n + 1):\n        fib.append(fib[i - 1] + fib[i - 2] + fib[i - 3] + i * i - i + 1)\n    count = 0\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                if (fib[i] + fib[j] + fib[k]) % 3 == 0:\n                    count += 1\n    return count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/77": [{"task_id": "EvoEval/77", "solution": "\ndef mixed_solution(arr):\n\n    def sum_digits(n):\n        return sum((int(digit) for digit in str(abs(n))))\n    return sum((num for (i, num) in enumerate(arr) if i % 2 == 0 and num % 2 != 0 and (sum_digits(num) > 0)))", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 3, -3, 3, 3]]], "plus_fail_tests": []}], "EvoEval/34": [{"task_id": "EvoEval/34", "solution": "from typing import List\n\ndef md5_nested_parens(paren_string: str) -> List[str]:\n    \"\"\"\n    Given a string 'paren_string' that represents multiple groups of nested parentheses separated by spaces,\n    compute the md5 hash of the string that represents the deepest level of nesting of parentheses for each group.\n    For example '(()())' has deepest level string of '2'.\n    Each deepest level is converted to a string before hashing.\n\n    If a group is not balanced (balanced means each open brace is properly closed), return an md5 hash of the string 'None'.\n    If 'paren_string' is an empty string, return an empty list.\n\n    An md5 hash is a 32-character hexadecimal number.\n\n    >>> md5_nested_parens('(()()) ((())) () ((())()())')\n    ['c81e728d9d4c2f636f067f89cc14862c', 'eccbc87e4b5ce2fe28308fd9f2a7baf3', 'c4ca4238a0b923820dcc509a6f75849b', 'eccbc87e4b5ce2fe28308fd9f2a7baf3']\n    \"\"\"\n    if not paren_string:\n        return []\n    groups = paren_string.split()\n    result = []\n    for group in groups:\n        depth = 0\n        max_depth = 0\n        for char in group:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                if depth == 0:\n                    max_depth = 'None'\n                    break\n                depth -= 1\n        if depth != 0:\n            max_depth = 'None'\n        result.append(hashlib.md5(str(max_depth).encode()).hexdigest())\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["(()()) (((((()))()((())()()))))"]], "plus_fail_tests": []}], "EvoEval/35": [{"task_id": "EvoEval/35", "solution": "def check_dict_happiness(dict):\n    \"\"\"\n    Given a dictionary, where all keys are strings, return True if the following conditions are met:\n    1. All keys are either all lower case or all upper case.\n    2. Each key is a happy string. A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n    The function should return False if the given dictionary is empty or if any of the conditions are not met.\n    Examples:\n    check_dict_happiness({\"abc\":\"apple\", \"def\":\"banana\"}) should return True.\n    check_dict_happiness({\"abc\":\"apple\", \"ABD\":\"banana\"}) should return False.\n    check_dict_happiness({\"aab\":\"apple\", \"abc\":\"banana\"}) should return False.\n    check_dict_happiness({\"aab\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_happiness({\"ABC\":\"John\", \"DEF\":\"36\", \"GHI\":\"Houston\"}) should return True.\n    check_dict_happiness({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return False.\n    \"\"\"\n    if not dict:\n        return False\n    is_lower = dict.keys()[0].islower()\n    for key in dict.keys():\n        if not isinstance(key, str):\n            return False\n        if is_lower and key.isupper() or (not is_lower and key.islower()):\n            return False\n        if len(key) < 3:\n            return False\n        for i in range(len(key) - 2):\n            if key[i] == key[i + 1] or key[i] == key[i + 2] or key[i + 1] == key[i + 2]:\n                return False\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[{"STATE": "NC", "ZIP": "12345"}]], "plus_fail_tests": []}], "EvoEval/9": [{"task_id": "EvoEval/9", "solution": "def planet_to_roman_distance(planet1, planet2):\n    planets = {'mercury': 1, 'venus': 2, 'earth': 3, 'mars': 4, 'jupiter': 5, 'saturn': 6, 'uranus': 7, 'neptune': 8}\n    roman_numerals = {1: 'i', 2: 'ii', 3: 'iii', 4: 'iv', 5: 'v', 6: 'vi', 7: 'vii', 8: 'viii'}\n    planet1 = planet1.lower()\n    planet2 = planet2.lower()\n    if planet1 not in planets or planet2 not in planets:\n        return {}\n    planet1_position = planets[planet1]\n    planet2_position = planets[planet2]\n    if planet1_position > planet2_position:\n        (planet1_position, planet2_position) = (planet2_position, planet1_position)\n    result = {}\n    for (planet, position) in planets.items():\n        if planet1_position < position < planet2_position:\n            result[planet] = roman_numerals[position]\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Uranus", 1]], "plus_fail_tests": []}], "EvoEval/53": [{"task_id": "EvoEval/53", "solution": "\ndef hex_grade_calculator(grades):\n    prime_grades = ['D', 'B', '7', '5', '3']\n    hex_grades = []\n    for grade in grades:\n        if grade == 4.0:\n            hex_grades.append('F')\n        elif grade > 3.7:\n            hex_grades.append('E')\n        elif grade > 3.3:\n            hex_grades.append('D')\n        elif grade > 3.0:\n            hex_grades.append('C')\n        elif grade > 2.7:\n            hex_grades.append('B')\n        elif grade > 2.3:\n            hex_grades.append('A')\n        elif grade > 2.0:\n            hex_grades.append('9')\n        elif grade > 1.7:\n            hex_grades.append('8')\n        elif grade > 1.3:\n            hex_grades.append('7')\n        elif grade > 1.0:\n            hex_grades.append('6')\n        elif grade > 0.7:\n            hex_grades.append('5')\n        elif grade > 0.0:\n            hex_grades.append('4')\n        else:\n            hex_grades.append('3')\n    return len([grade for grade in hex_grades if grade in prime_grades])", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/33": [{"task_id": "EvoEval/33", "solution": "\ndef roman_happiness(s):\n    \"\"\"\n    Given a string s of Roman numerals in lowercase, your task is to check if the roman numeral string is happy or not.\n\n    Definition:\n    A Roman numeral string is happy if:\n    1. Its length is at least 3.\n    2. It represents a positive integer less than or equal to 1000.\n    3. Every 3 consecutive letters are distinct.\n\n    If the string does not meet the criteria, return False. If the string is happy, return the integer that it represents.\n\n    For example:\n    roman_happiness('i') => False\n    roman_happiness('ii') => False\n    roman_happiness('xiv') => 14\n    roman_happiness('iiv') => False\n    roman_happiness('xiv') => 14\n    roman_happiness('xxxi') => False\n    roman_happiness('xliv') => 44\n    \"\"\"\n    roman_to_int = {'i': 1, 'v': 5, 'x': 10, 'l': 50, 'c': 100, 'd': 500, 'm': 1000}\n    int_val = 0\n    prev = 0\n    for i in range(len(s)):\n        curr = roman_to_int[s[i]]\n        if curr > prev:\n            int_val += curr - 2 * prev\n        else:\n            int_val += curr\n        prev = curr\n    if len(s) < 3 or int_val > 1000:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            return False\n    return int_val", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/87": [{"task_id": "EvoEval/87", "solution": "\ndef match_and_remove_unbalanced(text):\n    \"\"\"\n    This function takes a string as an input. The string consists of parentheses '(',')' and alphabets only.\n    The task is to check if the parentheses in the string are balanced and if unbalanced, remove the vowels from the string.\n    Return the same string if the parentheses are balanced.\n    The parentheses are considered balanced if every open parenthesis has a corresponding close parenthesis. \n\n    Examples:\n    match_and_remove_unbalanced('a(b)c(def)') == 'a(b)c(def)'\n    match_and_remove_unbalanced('a(bc)de(fg') == '(bc)d(fg'\n    match_and_remove_unbalanced('ab)c(de)f') == 'b)c(d)f'\n    match_and_remove_unbalanced('ab(cd') == 'b(cd'\n    \"\"\"\n    stack = []\n    for char in text:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                stack.append(char)\n    if stack:\n        return ''.join([char for char in text if char.lower() not in 'aeiou'])\n    else:\n        return text", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/43": [{"task_id": "EvoEval/43", "solution": "\ndef sorted_fib4_sequence(n: int):\n    \"\"\"The sorted Fib4 sequence is a sequence similar to the Fib4 sequence \n    that's defined as follows:\n\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    \n    However, for the sorted Fib4 sequence we are not just interested in a single element but rather \n    the entire sequence up to the n-th element.\n    Furthermore, depending on the sum of the first and last elements of the sequence, \n    you will sort the sequence in ascending order if the sum is odd, \n    or sort it in descending order if the sum is even.\n    Please write a function to efficiently compute the sorted Fib4 sequence.  Do not use recursion.\n\n    Examples:\n    >>> sorted_fib4_sequence(5)\n    [0, 0, 0, 2, 2]\n    >>> sorted_fib4_sequence(6)\n    [4, 2, 2, 0, 0, 0]\n    >>> sorted_fib4_sequence(7)\n    [8, 4, 2, 2, 0, 0, 0]\n    \"\"\"\n    fib4 = [0, 0, 2, 0]\n    for i in range(4, n):\n        fib4.append(fib4[i - 1] + fib4[i - 2] + fib4[i - 3] + fib4[i - 4])\n    fib4 = fib4[:n]\n    if (fib4[0] + fib4[-1]) % 2 == 0:\n        fib4.sort(reverse=True)\n    else:\n        fib4.sort()\n    return fib4", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/28": [{"task_id": "EvoEval/28", "solution": "\ndef grade_with_same_chars(grades: list, s0: str, s1: str):\n    \"\"\"\n    A teacher has a special grading system where she assigns her students letter grades \n    based on their GPA according to the following table:\n\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n\n    However, this year she adds an extra condition: the students can only receive a grade \n    if their name (s0) and the course title (s1) have the same characters. The function \n    receives a list of GPAs and two strings (s0 and s1) and returns a list of grades \n    for the students that pass the condition, or an empty list if no student passes.\n\n    Example:\n    grade_with_same_chars([4.0, 3, 1.7, 2, 3.5], 'abcd', 'dcba') ==> ['A+', 'B', 'C-', 'C', 'A-']\n    grade_with_same_chars([4.0, 3, 1.7, 2, 3.5], 'aaabcd', 'dddcba') ==> ['A+', 'B', 'C-', 'C', 'A-']\n    grade_with_same_chars([4.0, 3, 1.7, 2, 3.5], 'abcd', 'dcbae') ==> []\n    \"\"\"\n    if sorted(s0) != sorted(s1):\n        return []\n    grading_system = {4.0: 'A+', 3.7: 'A', 3.3: 'A-', 3.0: 'B+', 2.7: 'B', 2.3: 'B-', 2.0: 'C+', 1.7: 'C', 1.3: 'C-', 1.0: 'D+', 0.7: 'D', 0.0: 'D-', 0.0: 'E'}\n    grades_assigned = []\n    for gpa in grades:\n        for key in sorted(grading_system.keys(), reverse=True):\n            if gpa >= key:\n                grades_assigned.append(grading_system[key])\n                break\n    return grades_assigned", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[4.0, 3, 1.7, 2, 3.5], "aaabcd", "dddcba"]], "plus_fail_tests": []}], "EvoEval/13": [{"task_id": "EvoEval/13", "solution": "def filter_exchange(arr, lst1):\n    arr = [num for num in arr if sum((int(digit) for digit in str(abs(num)))) > 0]\n    odd_nums_in_lst1 = [num for num in lst1 if num % 2 != 0]\n    even_nums_in_arr = [num for num in arr if num % 2 == 0]\n    if len(odd_nums_in_lst1) <= len(even_nums_in_arr):\n        return 'YES'\n    else:\n        return 'NO'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[-100, -200, -300, -400, -500], [0, 1, 2, 3, 4, 5]]], "plus_fail_tests": []}], "EvoEval/95": [{"task_id": "EvoEval/95", "solution": "\nfrom typing import List\n\ndef filter_sort_strings(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain a given substring and have an even length. \n    Return the resulted list in ascending order by the length of each word. \n    If two words have the same length, sort the list alphabetically.\n    The list may contain duplicate strings.\n    \n    For example:\n    >>> filter_sort_strings([], 'a')\n    []\n    >>> filter_sort_strings(['abc', 'bacd', 'cd', 'array'], 'a')\n    ['bacd']\n    >>> filter_sort_strings(['abc', 'bacd', 'cd', 'array', 'play'], 'a')\n    ['bacd', 'play']\n    \"\"\"\n    filtered_strings = [s for s in strings if substring in s and len(s) % 2 == 0]\n    sorted_strings = sorted(filtered_strings, key=lambda s: (len(s), s))\n    return sorted_strings", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/7": [{"task_id": "EvoEval/7", "solution": "\ndef sum_square_cube_to_n(n: int) -> int:\n    sum = 0\n    for i in range(1, n + 1):\n        if i % 3 == 0:\n            sum += i ** 2\n        elif i % 4 == 0:\n            sum += i ** 3\n        else:\n            sum += i\n    return sum", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/3": [{"task_id": "EvoEval/3", "solution": "\nfrom typing import List\n\ndef sort_parentheses(lst: List[str]) -> str:\n    \"\"\"\n    You are given a list of strings, each string consist of open parentheses '(' or close parentheses ')' \n    and numberals from 'zero' to 'nine' in text form.\n    Your job is to sort the numbers from smallest to largest and then check if it is possible to concatenate \n    the strings in this order so that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S are balanced. \n    For example: the string '(three)(one)(five)' is good, while the string '(three)(one(five)' is not.\n    Return 'Yes' if there's a way to make a good string after sorting, and return 'No' otherwise.\n\n    Examples:\n    sort_parentheses(['(three)(', '(five)', '(one)']) == 'No'\n    sort_parentheses(['(five)', '(three)', '(one)']) == 'Yes'\n    \"\"\"\n    num_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    sorted_lst = sorted(lst, key=lambda x: num_dict[x.strip('()')])\n    sorted_str = ''.join(sorted_lst)\n    open_count = 0\n    for char in sorted_str:\n        if char == '(':\n            open_count += 1\n        elif char == ')':\n            if open_count == 0:\n                return 'No'\n            open_count -= 1\n    return 'Yes' if open_count == 0 else 'No'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/79": [{"task_id": "EvoEval/79", "solution": "\ndef happy_case_string(s):\n\n    def is_happy(s):\n        if len(s) < 3:\n            return False\n        for i in range(len(s) - 2):\n            if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n                return False\n        return True\n    if is_happy(s):\n        return ''.join([c.upper() if c.islower() else c.lower() for c in s])\n    else:\n        return s[::-1]", "base_status": "fail", "plus_status": null, "base_fail_tests": [["*#@"]], "plus_fail_tests": []}], "EvoEval/92": [{"task_id": "EvoEval/92", "solution": "\ndef get_common_max_triples(n, l1: list):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    common_elements = sorted(set(a) & set(l1))\n    multiples_of_three = [i for i in common_elements if i % 3 == 0]\n    if not multiples_of_three:\n        return (common_elements, 0)\n    triples_count = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            for k in range(j + 1, len(a)):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    triples_count += 1\n    return (common_elements, triples_count)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/81": [{"task_id": "EvoEval/81", "solution": "\nfrom typing import List\n\ndef mean_absolute_deviation_fibfib(n: int) -> float:\n\n    def fibfib(n: int) -> int:\n        if n == 0 or n == 1:\n            return 0\n        elif n == 2:\n            return 1\n        else:\n            return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n    fibfib_sequence = [fibfib(i) for i in range(n)]\n    mean = sum(fibfib_sequence) / n\n    mad = sum((abs(x - mean) for x in fibfib_sequence)) / n\n    return mad", "base_status": "fail", "plus_status": null, "base_fail_tests": [[100]], "plus_fail_tests": []}], "EvoEval/45": [{"task_id": "EvoEval/45", "solution": "\nfrom typing import List, Tuple\n\ndef primes_sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the prime numbers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1. Non-prime numbers should be ignored.\n    >>> primes_sum_product([])\n    (0, 1)\n    >>> primes_sum_product([1, 2, 3, 4])\n    (5, 6)\n    >>> primes_sum_product([5, 6, 7, 101, 11])\n    (124, 38885)\n    \"\"\"\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    primes = [n for n in numbers if is_prime(n)]\n    primes_sum = sum(primes)\n    primes_product = 1\n    for prime in primes:\n        primes_product *= prime\n    return (primes_sum, primes_product)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/59": [{"task_id": "EvoEval/59", "solution": "def odd_count_base_change(lst, base):\n    \"\"\"Given a list of strings and a base number, \n    where each string consists of only digits, \n    return a list where each element k of the output should be \n    \"the number of odd elements in the string i of the input.\" \n    where all the i's are replaced by the number of odd digits in the k'th string \n    of the input after changing the base of each digit to the given base.\n\n    >>> odd_count_base_change(['1234567'], 2)\n    [\"the number of odd elements 12n the str12ng 12 of the 12nput.\"]\n    >>> odd_count_base_change(['3',\"11111111\"], 3)\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum((1 for c in s if int(c, base) % 2 == 1))\n        result.append('the number of odd elements {}n the str{}ng {} of the {}nput.'.format(odd_count, odd_count, odd_count, odd_count))\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["3", "11111111"], 3]], "plus_fail_tests": []}], "EvoEval/63": [{"task_id": "EvoEval/63", "solution": "\ndef sort_planets(planet1: str, planet2: str, order: str) -> str:\n    planet_dict = {'Mercury': 'zero', 'Venus': 'one', 'Earth': 'two', 'Mars': 'three', 'Jupiter': 'four', 'Saturn': 'five', 'Uranus': 'six', 'Neptune': 'seven'}\n    order_list = order.split()\n    if planet1 not in planet_dict or planet2 not in planet_dict or len(set(order_list)) != 8 or any((i not in order_list for i in planet_dict.values())):\n        return 'Invalid'\n    planet1_index = order_list.index(planet_dict[planet1])\n    planet2_index = order_list.index(planet_dict[planet2])\n    if planet1_index < planet2_index:\n        return ' '.join(order_list[planet1_index + 1:planet2_index])\n    else:\n        return ' '.join(order_list[planet2_index + 1:planet1_index])", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/68": [{"task_id": "EvoEval/68", "solution": "\ndef minOddDigitsProductSubArray(nums):\n    \"\"\"\n    Given an array of positive integers nums, find the minimum product of odd digits of any \n    non-empty sub-array of nums. For each integer in the sub-array, you need to calculate \n    the product of its odd digits. If all digits are even in an integer, consider its product as 0.\n    You need to return the minimum sum of these products.\n    \n    Example:\n    minOddDigitsProductSubArray([2, 3, 4, 1, 2, 4]) == 0\n    minOddDigitsProductSubArray([235, 912, 43]) == 3 (as 235 -> 15, 912 -> 9, 43 -> 3)\n\n    Note: \n    A sub-array is a contiguous part of an array. And you should calculate the products for \n    each integer in the sub-array independently.\n    \"\"\"\n\n    def product_of_odd_digits(n):\n        product = 1\n        has_odd = False\n        while n:\n            (n, digit) = divmod(n, 10)\n            if digit % 2 == 1:\n                product *= digit\n                has_odd = True\n        return product if has_odd else 0\n    min_product = float('inf')\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            product_sum = sum((product_of_odd_digits(n) for n in nums[i:j + 1]))\n            min_product = min(min_product, product_sum)\n    return min_product", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/29": [{"task_id": "EvoEval/29", "solution": "def largest_prime_factor_or_value(n, x, y):\n\n    def is_prime(num):\n        if num > 1:\n            for i in range(2, num):\n                if num % i == 0:\n                    return False\n            else:\n                return True\n        else:\n            return False\n\n    def largest_prime_factor(num):\n        i = 2\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                num //= i\n        return num\n    if n == 1:\n        return y\n    elif is_prime(n):\n        return x\n    else:\n        return largest_prime_factor(n)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[999999937, 15, 20]], "plus_fail_tests": []}], "EvoEval/39": [{"task_id": "EvoEval/39", "solution": "def smallest_change_and_sum(arr, x, y):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n    After finding the minimum changes, add the value of x and y to it.\n\n    For example:\n    smallest_change_and_sum([1, 2, 3, 5, 4, 7, 9, 6], 2, 3) == 9\n    smallest_change_and_sum([1, 2, 3, 4, 3, 2, 2], 1, 2) == 4\n    smallest_change_and_sum([1, 2, 3, 2, 1], 3, 2) == 5\n    \"\"\"\n    changes = 0\n    n = len(arr)\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            changes += 1\n    return changes + x + y", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/52": [{"task_id": "EvoEval/52", "solution": "def pluck_and_prod(arr):\n    if not arr:\n        return ([], None)\n    smallest_even = min(((v, i) for (i, v) in enumerate(arr) if v % 2 == 0)) if any((v % 2 == 0 for v in arr)) else None\n    if smallest_even is None:\n        return ([], None)\n    arr.pop(smallest_even[1])\n    if not arr:\n        return ([smallest_even[0], smallest_even[1]], None)\n    sum_magnitude = sum((abs(v) for v in arr))\n    product_signs = 1 if all((v >= 0 for v in arr)) else -1 if sum((1 for v in arr if v < 0)) % 2 else 0\n    return ([smallest_even[0], smallest_even[1]], sum_magnitude * product_signs)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[0, -2, -4, -6, -8]]], "plus_fail_tests": []}], "EvoEval/73": [{"task_id": "EvoEval/73", "solution": "\nfrom typing import List\nfrom fractions import Fraction\n\ndef filter_and_simplify(fractions: List[str], n: str) -> List[bool]:\n    \"\"\" Filter an input list of fractions only for ones that, when multiplied by n, simplify to a whole number. Both, fractions in the list and n, are string representation of a fraction, and have the following format, <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that the fractions, and n are valid fractions, and do not have zero as denominator.\n\n    filter_and_simplify([\"1/5\", \"1/6\", \"7/10\"], \"5/1\") = [True, False, False]\n    filter_and_simplify([\"1/3\", \"2/1\", \"3/2\"], \"2/1\") = [False, True, True]\n    \"\"\"\n    n_fraction = Fraction(n)\n    result = []\n    for fraction in fractions:\n        product = Fraction(fraction) * n_fraction\n        result.append(product.denominator == 1)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/94": [{"task_id": "EvoEval/94", "solution": "\ndef sort_count_nums(arr):\n\n    def sum_digits(n):\n        return sum((int(digit) for digit in str(abs(n))))\n    count = sum((1 for num in arr if sum_digits(num) > 0))\n    return sorted(arr, reverse=count % 2 == 0)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[15, -23, 56, 78, -90, 0, 34, 23, -45, 67]]], "plus_fail_tests": []}], "EvoEval/83": [{"task_id": "EvoEval/83", "solution": "\nimport re\n\n\ndef prime_underscored_length(text):\n    text = re.sub(' +', '_', text)\n    return is_prime(len(text))", "base_status": "fail", "plus_status": null, "base_fail_tests": [[" Example    4"]], "plus_fail_tests": []}], "EvoEval/65": [{"task_id": "EvoEval/65", "solution": "\ndef modp_largest_divisor(n: int, p: int) -> int:\n    \"\"\"Return the largest number smaller than 'p' which divides (2^n modulo p) evenly. \n    If no such number exists, return 1.\n    \n    >>> modp_largest_divisor(3, 5)\n    3\n    >>> modp_largest_divisor(1101, 101)\n    2\n    >>> modp_largest_divisor(0, 101)\n    1\n    >>> modp_largest_divisor(3, 11)\n    8\n    \"\"\"\n    mod = pow(2, n, p)\n    for i in range(p - 1, 0, -1):\n        if mod % i == 0:\n            return i\n    return 1", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/48": [{"task_id": "EvoEval/48", "solution": "\nfrom typing import List\n\ndef prime_prefixed_strings(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Write a function that takes a list of strings and a prefix, it should return a list of \n    strings from the input list which start with the given prefix and their lengths are prime numbers.\n    \n    Examples\n    prime_prefixed_strings([], 'a') == []\n    prime_prefixed_strings(['abc', 'bcd', 'cde', 'array'], 'a') == ['abc', 'array']\n    prime_prefixed_strings(['abcd', 'bcd', 'cde', 'array'], 'a') == ['array']\n    prime_prefixed_strings(['apple', 'avocado', 'banana', 'apricot'], 'a') == ['apple', 'avocado', 'apricot']\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix) and is_prime(len(s))]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["apple", "avocado", "banana", "apricot"], "a"]], "plus_fail_tests": []}], "EvoEval/51": [{"task_id": "EvoEval/51", "solution": "\ndef modify_and_compare(a, b):\n\n    def convert(s):\n        if s.isnumeric():\n            return s[::-1]\n        else:\n            return s.swapcase()\n\n    def to_real(s):\n        try:\n            return float(s.replace(',', '.'))\n        except ValueError:\n            return s\n    (a, b) = map(convert, map(str, (a, b)))\n    (a_real, b_real) = map(to_real, (a, b))\n    if isinstance(a_real, float) and isinstance(b_real, float):\n        if a_real > b_real:\n            return a if isinstance(a, type(a_real)) else a_real\n        elif a_real < b_real:\n            return b if isinstance(b, type(b_real)) else b_real\n        else:\n            return None\n    else:\n        return b", "base_status": "fail", "plus_status": null, "base_fail_tests": [["5,1", 6]], "plus_fail_tests": []}], "EvoEval/50": [{"task_id": "EvoEval/50", "solution": "\ndef get_closest_upper_vowel(word):\n    vowels = 'AEIOU'\n    consonants = 'BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz'\n    for i in range(len(word) - 1, -1, -2):\n        if word[i] in vowels and i != 0 and (i != len(word) - 1):\n            if word[i - 1] in consonants and word[i + 1] in consonants:\n                return word[i]\n    return ''", "base_status": "fail", "plus_status": null, "base_fail_tests": [["FULL"]], "plus_fail_tests": []}], "EvoEval/38": [{"task_id": "EvoEval/38", "solution": "\ndef even_odd_zero_sum(l, n):\n    \"\"\"\n    even_odd_zero_sum takes a list of integers `l` and a positive integer `n` as inputs.\n    \n    It first calculates the number of even and odd integer palindromes that fall within the range(1, n), inclusive.\n    \n    It then checks if there are two distinct elements in the list `l` that sum to either of the two numbers obtained from the previous step.\n    \n    The function should return a tuple of two booleans. The first boolean indicates whether there are two distinct elements in the list `l` that sum to the number of even palindromes, and the second boolean indicates the same for odd palindromes.\n \n    Example:\n        Input: l = [1, 3, -2, -3, -1, 5, -2], n = 10\n        Output: (True, False)\n        Explanation:\n        Integer palindromes within the range (1, 10) are 1, 2, 3, 4, 5, 6, 7, 8, 9. There are 4 even palindromes and 5 odd palindromes.\n        In the list `l`, there are two distinct elements that sum to 4 (3, 1) but there are no two distinct elements that sum to 5.\n        \n    Note:\n        1. 1 <= n <= 10^3\n        2. List `l` can contain both positive and negative integers.\n        3. Distinct elements mean that the same element cannot be used twice to make the sum.\n    \"\"\"\n\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    def has_two_elements_sum(lst, target):\n        seen = set()\n        for num in lst:\n            if target - num in seen:\n                return True\n            seen.add(num)\n        return False\n    even_palindromes = sum((1 for i in range(1, n + 1) if is_palindrome(i) and i % 2 == 0))\n    odd_palindromes = sum((1 for i in range(1, n + 1) if is_palindrome(i) and i % 2 != 0))\n    return (has_two_elements_sum(l, even_palindromes), has_two_elements_sum(l, odd_palindromes))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/70": [{"task_id": "EvoEval/70", "solution": "\nfrom typing import List, Tuple\nimport math\n\n\ndef closest_special_factorial(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"Find the two numbers with the closest special factorials.\"\"\"\n    special_factorials = {n: special_factorial(n) for n in numbers}\n    sorted_numbers = sorted(special_factorials, key=special_factorials.get)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[4, 5, 6]]], "plus_fail_tests": []}], "EvoEval/14": [{"task_id": "EvoEval/14", "solution": "\ndef prime_avg_range(n, m):\n    \"\"\"You are given two positive integers n and m. Your task is to create a list of all \n    prime numbers between n and m (inclusive), compute the average of these prime numbers, \n    round the answer to the nearest integer, and convert that to binary. \n    If there are no prime numbers in the range or if n is greater than m, return -1.\n    Example:\n    prime_avg_range(1, 5) => \"0b11\"\n    prime_avg_range(7, 11) => \"0b1001\"\n    prime_avg_range(20, 30) => \"0b11010\"\n    prime_avg_range(15, 10) => -1\n    prime_avg_range(10, 10) => -1\n    \"\"\"\n    if n > m:\n        return -1\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    primes = [i for i in range(n, m + 1) if is_prime(i)]\n    if not primes:\n        return -1\n    avg = round(sum(primes) / len(primes))\n    return bin(avg)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/16": [{"task_id": "EvoEval/16", "solution": "def get_music_notes(word: str, music_string: str):\n    vowels = 'aeiouAEIOU'\n    consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ'\n    music_notes = music_string.split()\n    music_dict = {'o': 4, 'o|': 2, '.|': 1}\n    beats = []\n    for i in range(len(word) - 1, 0, -1):\n        if word[i] in vowels and word[i - 1] in consonants and (word[i + 1] in consonants):\n            for j in range(i + 1):\n                beats.append(music_dict[music_notes[j]])\n            return beats\n    return []", "base_status": "fail", "plus_status": null, "base_fail_tests": [["yogurt", ""]], "plus_fail_tests": []}], "EvoEval/21": [{"task_id": "EvoEval/21", "solution": "\nfrom typing import List\n\ndef base_change_prefixes(x: int, base: int) -> List[str]:\n    \"\"\" For a given number x and a base less than 10, first change the numerical base of x to the given base.\n    Then return a list of all prefixes from the shortest to the longest of the new base representation of x.\n    \n    >>> base_change_prefixes(8, 3)\n    ['2', '22']\n    >>> base_change_prefixes(8, 2)\n    ['1', '10', '100', '1000']\n    >>> base_change_prefixes(7, 2)\n    ['1', '11', '111']\n    \"\"\"\n    new_base_num = ''\n    while x > 0:\n        new_base_num = str(x % base) + new_base_num\n        x = x // base\n    prefixes = [new_base_num[:i + 1] for i in range(len(new_base_num))]\n    return prefixes", "base_status": "fail", "plus_status": null, "base_fail_tests": [[0, 2]], "plus_fail_tests": []}], "EvoEval/25": [{"task_id": "EvoEval/25", "solution": "\nfrom typing import List, Tuple\n\ndef sum_product_triples(n: int) -> Tuple[int, int]:\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n    For each i (from 1 to n), the value of a[i] = i * i - i + 1.\n    Find the triples (a[i], a[j], a[k]) of a where i < j < k, and a[i] + a[j] + a[k] is a multiple of 3.\n    From these triples, return a tuple consisting of the sum and the product of all the first elements of these triples.\n    \n    Empty sum should be equal to 0 and empty product should be equal to 1 if there are no valid triples.\n    \n    Example :\n        Input: n = 5\n        Output: (1, 1)\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13). The sum and product of the first element is 1. \n    \"\"\"\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    sum_val = 0\n    product_val = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    sum_val += a[i]\n                    product_val *= a[i]\n    if sum_val == 0:\n        product_val = 1\n    return (sum_val, product_val)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/71": [{"task_id": "EvoEval/71", "solution": "\nimport math\n\ndef special_brazilian_balloon(n, w):\n\n    def brazilian_factorial(n):\n        result = 1\n        for i in range(1, n + 1):\n            result *= math.factorial(i)\n        return result\n\n    def is_palindrome(w):\n        return w == w[::-1]\n    max_weight = brazilian_factorial(n)\n    sum_weights = sum(w)\n    if sum_weights <= max_weight and is_palindrome(w):\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/55": [{"task_id": "EvoEval/55", "solution": "import hashlib\n\ndef mini_roman_to_md5(number):\n    if number <= 0:\n        return None\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n    roman = ''\n    for i in range(len(values)):\n        count = int(number / values[i])\n        roman += numerals[i] * count\n        number -= values[i] * count\n    md5_hash = hashlib.md5()\n    md5_hash.update(roman.encode())\n    return md5_hash.hexdigest()", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/61": [{"task_id": "EvoEval/61", "solution": "\nfrom typing import List, Optional, Tuple\n\ndef longest_planet_chain(planet1: str, planet2: str, chains: List[Tuple[str, ...]]) -> Optional[Tuple[str, ...]]:\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    if planet1 not in planets or planet2 not in planets:\n        return None\n    longest_chain = None\n    for chain in chains:\n        if chain[0] == planet1 and chain[-1] == planet2:\n            if longest_chain is None or len(chain) > len(longest_chain):\n                longest_chain = chain\n    return longest_chain", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/82": [{"task_id": "EvoEval/82", "solution": "\ndef odd_fibfib(n: int):\n    \"\"\"The Odd FibFib sequence is a sequence similar to the FibFib sequence that's defined as follows:\n    odd_fibfib(0) == 0\n    odd_fibfib(1) == 0\n    odd_fibfib(2) == 1\n    odd_fibfib(n) == odd_fibfib(n-1) + odd_fibfib(n-2) + odd_fibfib(n-3).\n    However, if the result is an even number, it is replaced by the product of its odd digits. If all digits are even, it is replaced by 0.\n    Please write a function to compute the n-th element of the odd_fibfib sequence efficiently.\n    >>> odd_fibfib(1)\n    0\n    >>> odd_fibfib(5)\n    0\n    >>> odd_fibfib(7)\n    1\n    >>> odd_fibfib(9)\n    0\n    \"\"\"\n    if n < 3:\n        return [0, 0, 1][n]\n    else:\n        fibfib = [0, 0, 1] + [0] * (n - 2)\n        for i in range(3, n + 1):\n            fibfib[i] = fibfib[i - 1] + fibfib[i - 2] + fibfib[i - 3]\n            if fibfib[i] % 2 == 0:\n                fibfib[i] = product_of_odd_digits(fibfib[i])\n        return fibfib[n]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[9]], "plus_fail_tests": []}], "EvoEval/91": [{"task_id": "EvoEval/91", "solution": "\ndef sort_prime_even(l: list, x, y):\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    even_indices = [l[i] for i in range(len(l)) if i % 2 == 0]\n    even_indices.sort()\n    for i in range(len(l)):\n        if i % 2 == 0:\n            if is_prime(even_indices[0]):\n                l[i] = x\n            else:\n                l[i] = y\n            even_indices.pop(0)\n    return l", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/40": [{"task_id": "EvoEval/40", "solution": "\ndef largest_prime_odd_ends(nums):\n    \"\"\"Write a function that takes an array of numbers as input and returns \n    the largest prime factor of the elements in the array that are greater than 10 and both \n    first and last digits of a number are odd (1, 3, 5, 7, 9). \n    Assume all numbers in the array are integers and are greater than 1.\n    If no prime factor satisfies the condition, return None.\n    For example:\n    largest_prime_odd_ends([15, -73, 14, -15]) => 5 \n    largest_prime_odd_ends([33, -2, -3, 45, 21, 109]) => 109\n    largest_prime_odd_ends([10, -2, -3, 5, 21, 4]) => None\n    \"\"\"\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def odd_ends(n):\n        str_n = str(n)\n        return str_n[0] in '13579' and str_n[-1] in '13579'\n    prime_factors = []\n    for num in nums:\n        if num > 10 and odd_ends(num) and is_prime(num):\n            prime_factors.append(num)\n    return max(prime_factors) if prime_factors else None", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[51, -73, 14, -15]]], "plus_fail_tests": []}], "EvoEval/27": [{"task_id": "EvoEval/27", "solution": "\ndef list_prime_exchange(lst1, lst2, x, y):\n    \"\"\"The function takes two lists of numbers lst1 and lst2, and two integers x and y. The task is to \n    determine whether it is possible to perform an exchange of elements between lst1 and lst2 to \n    make lst1 a list of only prime numbers. \n\n    If it is possible, return the value of x. If it is not possible, return the value of y. \n\n    There is no limit on the number of exchanged elements between lst1 and lst2.\n\n    For example:\n    list_prime_exchange([1, 2, 3, 4], [5, 7, 11, 13], 10, 20) => 10\n    list_prime_exchange([1, 2, 3, 4], [6, 8, 10, 12], 30, 40) => 40\n\n    It is assumed that the input lists will be non-empty and the integers x and y will be non-zero.\n    \"\"\"\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    non_primes_in_lst1 = sum((not is_prime(i) for i in lst1))\n    primes_in_lst2 = sum((is_prime(i) for i in lst2))\n    if non_primes_in_lst1 <= primes_in_lst2:\n        return x\n    else:\n        return y", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/18": [{"task_id": "EvoEval/18", "solution": "\ndef min_triplets_sum(nums: list):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array of size three. \n\n    If no such sub-array exists, return 0. A sub-array is a contiguous part of an array.\n\n    Examples:\n    min_triplets_sum([2, 3, 4, 1, -7, 4]) == -2   # The sub-array is [1, -7, 4]\n    min_triplets_sum([1, 2, 3, -6, 5, 1, 2]) == -1  # The sub-array is [2, 3, -6]\n    min_triplets_sum([2, 3]) == 0   # No such sub-array exists\n    min_triplets_sum([-1, -2, -3]) == -6   # The sub-array is [-1, -2, -3]\n    \"\"\"\n    if len(nums) < 3:\n        return 0\n    min_sum = float('inf')\n    for i in range(len(nums) - 2):\n        current_sum = nums[i] + nums[i + 1] + nums[i + 2]\n        min_sum = min(min_sum, current_sum)\n    return min_sum", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/80": [{"task_id": "EvoEval/80", "solution": "def cyclic_encode_delete(s: str, c: str) -> tuple:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def encode(s: str) -> str:\n        encoded = ''\n        for i in range(0, len(s), 3):\n            group = s[i:i + 3]\n            encoded += group[1:] + group[:1]\n        return encoded\n\n    def decode(s: str) -> str:\n        decoded = ''\n        for i in range(0, len(s), 3):\n            group = s[i:i + 3]\n            decoded += group[-1:] + group[:-1]\n        return decoded\n    encoded_s = encode(s)\n    result = ''.join([ch for ch in encoded_s if ch not in c])\n    if is_palindrome(result):\n        return (result, True)\n    else:\n        return (decode(result), False)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["abcdef", "b"]], "plus_fail_tests": []}], "EvoEval/36": [{"task_id": "EvoEval/36", "solution": "\ndef mod_shift_sort(arr, n: int, p: int):\n    \"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N]. The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n        However, the number of times you can perform the shift operation is \n        limited by the result of 2^n modulo p (modp(n, p)).\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    within the determined limit then return True else return False.\n    If the given array is empty then return True.\n\n    Note: The given list is guaranteed to have unique elements and the values of n \n    and p are positive integers.\n\n    For Example:\n    \n    mod_shift_sort([3, 4, 5, 1, 2], 3, 5) ==> True\n    Explanation: By performing 2 right shift operations, non-decreasing order can\n                 be achieved for the given array and 2 is less than 3 (2^3 mod 5).\n    mod_shift_sort([3, 5, 4, 1, 2], 2, 3) ==> False\n    Explanation: It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n    mod_shift_sort([3, 4, 5, 1, 2], 2, 3) ==> False\n    Explanation: Although it is possible to get non-decreasing order for the array \n                by performing enough right shift operations, the number of operations \n                required is more than the limit (2^3 mod 5).\n    \"\"\"\n    if not arr:\n        return True\n    limit = pow(2, n) % p\n    sorted_arr = sorted(arr)\n    for i in range(len(arr)):\n        if arr == sorted_arr:\n            return True\n        if i >= limit:\n            return False\n        arr = [arr[-1]] + arr[:-1]\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/85": [{"task_id": "EvoEval/85", "solution": "def next_smallest_sorted_binary(lst):\n    \"\"\"\n    You are given a list of non-negative integers.\n    First, sort the input list based on the number of ones in their binary representation in ascending order. \n    For the same number of ones, sort based on original value. \n    \n    Then, return the 2nd smallest element from the sorted list. \n    Return None if there is no such element.\n\n    next_smallest_sorted_binary([1, 2, 3, 4, 5]) == 2\n    next_smallest_sorted_binary([5, 1, 4, 3, 2]) == 2\n    next_smallest_sorted_binary([]) == None\n    next_smallest_sorted_binary([1, 1]) == None\n    \"\"\"\n    lst.sort(key=lambda x: (bin(x).count('1'), x))\n    return lst[1] if len(lst) > 1 else None", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 1]]], "plus_fail_tests": []}], "EvoEval/60": [{"task_id": "EvoEval/60", "solution": "\ndef smallest_even_triple(arr, n):\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    smallest_triple = None\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    if smallest_triple is None or a[i] < a[smallest_triple[0]]:\n                        smallest_triple = (i, j, k)\n    if smallest_triple is None:\n        return []\n    arr.append(a[smallest_triple[0]])\n    smallest_even = None\n    smallest_even_index = None\n    for (i, val) in enumerate(arr):\n        if val % 2 == 0:\n            if smallest_even is None or val < smallest_even:\n                smallest_even = val\n                smallest_even_index = i\n    if smallest_even is None:\n        return []\n    return [smallest_even, smallest_even_index]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/1": [{"task_id": "EvoEval/1", "solution": "def round_and_flip(value: str) -> str:\n    (number, text) = (''.join(filter(lambda i: i.isdigit() or i == '.' or i == '-', value)), ''.join(filter(lambda i: i.isalpha(), value)))\n    number = round(float(number))\n    text = text.swapcase()\n    return f'{number} {text}'", "base_status": "fail", "plus_status": null, "base_fail_tests": [["10.5abc"]], "plus_fail_tests": []}], "EvoEval/57": [{"task_id": "EvoEval/57", "solution": "def palindromic_and_odd_digit_array(arr):\n    \"\"\"Given a list of positive integers 'arr', return the minimum number of elements\n    that need to be changed to make the array both palindromic and containing only odd digits. \n    A palindromic array is an array that is read the same backwards and forwards. \n    An array containing only odd digits is an array where every digit in every element is an odd number. \n    In one change, you can change one element to any other positive integer.\n    \n    For example:\n    >>> palindromic_and_odd_digit_array([1, 2, 3, 5, 4, 2, 9, 6])\n    4\n    >>> palindromic_and_odd_digit_array([1, 2, 3, 4, 3, 6, 2])\n    4\n    >>> palindromic_and_odd_digit_array([1, 2, 3, 2, 1])\n    2\n    \"\"\"\n    n = len(arr)\n    changes = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1] or arr[i] % 2 == 0 or arr[n - i - 1] % 2 == 0:\n            changes += 1\n    if n % 2 != 0 and arr[n // 2] % 2 == 0:\n        changes += 1\n    return changes", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 2, 5]]], "plus_fail_tests": []}], "EvoEval/10": [{"task_id": "EvoEval/10", "solution": "\ndef class_grades_with_flip(name_grade_list):\n    \"\"\"A teacher has to give the grades to students. The teacher has a list of students with their GPAs.\n    The teacher wants to convert these GPAs into letter grades. However, due to an administrative error, \n    some students' names have been input in the wrong case (all caps or all lowercase). \n    To fix this, their names need to be converted to proper case i.e., only the first letter of the name \n    should be in uppercase and the rest in lowercase.\n\n    Additionally, the teacher has her own algorithm for grading. Write a function that will output a list\n    of tuples where each tuple contains the student's name in proper case and the corresponding letter grade \n    using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n\n    Example: \n    class_grades_with_flip([('JOHN', 4.0), ('sarah', 3.0), ('ALICE', 1.7), ('BOB', 2.0), ('linda', 3.5)]) \n    ==> [('John', 'A+'), ('Sarah', 'B'), ('Alice', 'C-'), ('Bob', 'C'), ('Linda', 'A-')]\n    \"\"\"\n    grading_scale = [(4.0, 'A+'), (3.7, 'A'), (3.3, 'A-'), (3.0, 'B+'), (2.7, 'B'), (2.3, 'B-'), (2.0, 'C+'), (1.7, 'C'), (1.3, 'C-'), (1.0, 'D+'), (0.7, 'D'), (0.0, 'D-'), (-1, 'E')]\n    result = []\n    for (name, grade) in name_grade_list:\n        name = name.capitalize()\n        for (gpa, letter_grade) in grading_scale:\n            if grade >= gpa:\n                result.append((name, letter_grade))\n                break\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[["JOHN", 4.0], ["sarah", 3.0], ["ALICE", 1.7], ["BOB", 2.0], ["linda", 3.5]]]], "plus_fail_tests": []}], "EvoEval/49": [{"task_id": "EvoEval/49", "solution": "\ndef modp_count(arr, n: int, p: int):\n    \"\"\"\n    Write a function modp_count which takes an array of integers and two integers n and p as inputs.\n    The function should first calculate 2^n modulo p. \n    It then counts the number of elements in the array which has a sum of digits > the result of 2^n modulo p.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> modp_count([], 2, 5) == 0\n    >>> modp_count([-1, 11, -11], 4, 5) == 1\n    >>> modp_count([1, 1, 2], 0, 101) == 1\n    >>> modp_count([12, 15, 20], 11, 3) == 2\n    \"\"\"\n    mod = pow(2, n, p)\n    count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            digit_sum = -int(str(num)[0]) + sum((int(digit) for digit in str(num)[1:]))\n        else:\n            digit_sum = sum((int(digit) for digit in str(num)))\n        if digit_sum > mod:\n            count += 1\n    return count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/26": [{"task_id": "EvoEval/26", "solution": "\nfrom typing import List, Tuple\n\ndef sort_and_pluck(values: List[str]) -> Tuple[str, int]:\n    \"\"\"\n    Given a list of space-delimited strings representing numerals from 'zero' to 'nine', \n    your task is to first sort each string of numerals from smallest to largest and then \n    pluck one numeral from the sorted list.\n\n    The plucked numeral should be the numeral with the smallest even value. If multiple numerals \n    with the same smallest even value are found return the numeral that has the smallest index in its \n    original string (before sorting). The plucked numeral should be returned in a tuple, \n    (\"numeral\", its original index in the list), If there are no even values or the given list \n    is empty, return an empty tuple.\n\n    Example 1:\n        Input: ['three two one', 'nine eight seven']\n        Output: ('two', 1)\n        Explanation: After sorting we get ['one two three', 'seven eight nine']. \n                     'two' and 'eight' are the only even numerals.\n\n    Example 2:\n        Input: ['five four three', 'one zero nine']\n        Output: ('zero', 1)\n        Explanation: After sorting we get ['three four five', 'nine one zero']. \n                     'four' and 'zero' are the only even numerals.\n\n    Example 3:\n        Input: []\n        Output: ()\n        \n    Example 4:\n        Input: ['three two one', 'five four zero', 'six nine eight']\n        Output: ('zero', 2)\n        Explanation: After sorting we get ['one two three', 'four five zero', 'eight six nine']. \n                     'two', 'zero', 'four', 'eight' and 'six' are the even numerals.\n\n    Constraints:\n        * 0 <= len(values) <= 10000\n        * 0 <= len(value) <= 50 ( for each value in values list)\n    \"\"\"\n    numeral_to_number = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    number_to_numeral = {v: k for (k, v) in numeral_to_number.items()}\n    even_numerals = []\n    for (i, value) in enumerate(values):\n        numerals = value.split()\n        numerals.sort(key=lambda x: numeral_to_number[x])\n        for numeral in numerals:\n            if numeral_to_number[numeral] % 2 == 0:\n                even_numerals.append((numeral, i))\n                break\n    if even_numerals:\n        even_numerals.sort(key=lambda x: (numeral_to_number[x[0]], x[1]))\n        return even_numerals[0]\n    else:\n        return ()", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["three two one", "five four zero", "six nine eight"]]], "plus_fail_tests": []}], "EvoEval/19": [{"task_id": "EvoEval/19", "solution": "from typing import List, Tuple, Optional\n\ndef account_operations(operations: List[int]) -> Tuple[Optional[int], Optional[int], bool]:\n    balance = 0\n    largest_withdrawal = None\n    smallest_deposit = None\n    balance_below_zero = False\n    for operation in operations:\n        if operation < 0:\n            if balance + operation < 0:\n                balance_below_zero = True\n                break\n            elif largest_withdrawal is None or operation > largest_withdrawal:\n                largest_withdrawal = operation\n        elif smallest_deposit is None or operation < smallest_deposit:\n            smallest_deposit = operation\n        balance += operation\n    return (largest_withdrawal, smallest_deposit, balance_below_zero)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, -3, 2, -2, 5]]], "plus_fail_tests": []}], "EvoEval/67": [{"task_id": "EvoEval/67", "solution": "\nfrom typing import List\n\ndef max_close_element_difference(numbers: List[float], threshold: float) -> float:\n    \"\"\"\n    Given a list of numbers and a threshold, find two elements that are closer to each other than the threshold and return their difference. If multiple pairs meet the criteria, return the maximum difference. If no such pairs exist, return 0.\n    >>> max_close_element_difference([1.0, 2.0, 3.0], 0.5)\n    0\n    >>> max_close_element_difference([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    0.2\n    >>> max_close_element_difference([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 5)\n    4\n    \"\"\"\n    max_diff = 0\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        diff = abs(numbers[i] - numbers[i + 1])\n        if diff < threshold:\n            max_diff = max(max_diff, diff)\n    return max_diff", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1000000000.0, 1000000001.0, 1000000002.0, 1000000003.0, 1000000004.0], 5]], "plus_fail_tests": []}], "EvoEval/6": [{"task_id": "EvoEval/6", "solution": "\ndef pile_median(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the median number of stones in all levels in the pile.\n\n    You should return the answer as a float if the number of levels is even,\n    and as an integer if the number of levels is odd.\n\n    Examples:\n    >>> pile_median(3)\n    5\n    >>> pile_median(4)\n    7.0\n    \"\"\"\n    if n % 2 == 0:\n        return (n + n + 2) / 2.0\n    else:\n        return n + 1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[1]], "plus_fail_tests": []}], "EvoEval/72": [{"task_id": "EvoEval/72", "solution": "\nfrom typing import List\nfrom math import factorial\n\ndef special_close_factorials(numbers: List[int], threshold: int) -> bool:\n    \"\"\" \n    Check if in given list of numbers, are any two special factorials closer to each other than \n    given threshold. The special factorial (Brazilian factorial) is defined as n! * (n-1)! * (n-2)! * ... * 1! \n    where n > 0.\n\n    For example:\n    >>> special_close_factorials([2, 3], 10)\n    False\n    >>> special_close_factorials([1, 2, 3, 4], 100)\n    True\n    \"\"\"\n    special_factorials = []\n    for num in numbers:\n        special_fact = 1\n        for i in range(num, 0, -1):\n            special_fact *= factorial(i)\n        special_factorials.append(special_fact)\n    for i in range(len(special_factorials)):\n        for j in range(i + 1, len(special_factorials)):\n            if abs(special_factorials[i] - special_factorials[j]) < threshold:\n                return True\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/37": [{"task_id": "EvoEval/37", "solution": "\nimport math\n\ndef minSubArraySumEvenOdd(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums. Then, return a tuple that has the number of even and odd digits in \n    this minimum sum respectively.\n\n    Example:\n    minSubArraySumEvenOdd([2, 3, 4, 1, 2, 4]) == (0, 1)  # minimum sum is 1 which has 0 even digit and 1 odd digit\n    minSubArraySumEvenOdd([-1, -2, -3]) == (1, 0)  # minimum sum is -6 which has 1 even digit and 0 odd digit\n    \"\"\"\n    min_sum = float('inf')\n    for i in range(len(nums)):\n        current_sum = 0\n        for j in range(i, len(nums)):\n            current_sum += nums[j]\n            min_sum = min(min_sum, current_sum)\n    min_sum = abs(min_sum)\n    even_count = len([digit for digit in str(min_sum) if int(digit) % 2 == 0])\n    odd_count = len([digit for digit in str(min_sum) if int(digit) % 2 != 0])\n    return (even_count, odd_count)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/64": [{"task_id": "EvoEval/64", "solution": "\ndef modp_prime_numbers(n: int, p: int):\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    mod_result = pow(2, n, p)\n    primes = [i for i in range(2, mod_result) if is_prime(i)]\n    return primes", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/2": [{"task_id": "EvoEval/2", "solution": "\nfrom typing import List\n\ndef modp_intersperse(numbers: List[int], n: int, p: int) -> List[int]:\n    \"\"\" Insert the result of 2^n modulo p between every two consecutive elements of input list `numbers'\n    >>> modp_intersperse([], 3, 5)\n    []\n    >>> modp_intersperse([1, 2, 3], 3, 5)\n    [1, 3, 2, 3, 3]\n    >>> modp_intersperse([10, 20, 30], 1101, 101)\n    [10, 2, 20, 2, 30]\n    \"\"\"\n    result = []\n    mod_value = pow(2, n) % p\n    for num in numbers:\n        result.append(num)\n        result.append(mod_value)\n    return result[:-1]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1], 1000000000000000000, 1000000007]], "plus_fail_tests": []}]}}