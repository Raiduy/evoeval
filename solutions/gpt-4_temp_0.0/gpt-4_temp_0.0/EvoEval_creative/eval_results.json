{"eval": {"EvoEval/30": [{"task_id": "EvoEval/30", "solution": "from typing import List, Tuple\n\ndef find_path(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]:\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque([(start, [start])])\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == end:\n            return path\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (maze[nx][ny] == 1):\n                queue.append(((nx, ny), path + [(nx, ny)]))\n                visited[nx][ny] = True\n    return []", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[1, 0, 1, 1, 1], [1, 0, 1, 0, 1], [1, 1, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]], [0, 0], [4, 4]]], "plus_fail_tests": []}], "EvoEval/98": [{"task_id": "EvoEval/98", "solution": "def nature_sequence_generator(n, a, b):\n    \"\"\"Function to generate the sequence and replace prime numbers with 'prime'.\"\"\"\n    sequence = [a, b]\n    for i in range(2, n):\n        next_num = sequence[-1] + sequence[-2] + i\n        if is_prime(next_num):\n            sequence.append('prime')\n        else:\n            sequence.append(next_num)\n    return sequence", "base_status": "fail", "plus_status": null, "base_fail_tests": [[5, 1, 2]], "plus_fail_tests": []}], "EvoEval/86": [{"task_id": "EvoEval/86", "solution": "def sort_movies_by_ratings_and_release_date(movies_dict):\n    \"\"\"\n    Every movie lover has a favorite genre and likes to watch movies based on their ratings and release year. \n    Given a dictionary where each key-value pair represents a movie, develop a function that sorts these movies \n    according to ratings (from high to low) and if the ratings are same, then sort according to the release year \n    (from new to old). The function should return the sorted list of movie names.\n\n    The dictionary has the following format:\n    { \"movie_name\": [rating, release_year] }\n\n    Ratings are from 1 to 10, and release years are four digit numbers.\n\n    Examples:\n    movies_dict = {\"Inception\": [8.8, 2010], \"The Dark Knight\": [9, 2008], \n                   \"Interstellar\": [8.6, 2014], \"The Dark Knight Rises\": [8.4, 2012]}\n    sort_movies_by_ratings_and_release_date(movies_dict) \u279e [\"The Dark Knight\", \"Inception\", \"Interstellar\",\n                                                             \"The Dark Knight Rises\"]\n    \n    movies_dict = {\"Toy Story\": [8.3, 1995], \"Toy Story 2\": [7.9, 1999], \n                   \"Toy Story 3\": [8.3, 2010], \"Toy Story 4\": [7.8, 2019]}\n    sort_movies_by_ratings_and_release_date(movies_dict) \u279e [\"Toy Story 3\", \"Toy Story\", \n                                                             \"Toy Story 2\", \"Toy Story 4\"]\n    \"\"\"\n    sorted_movies = sorted(movies_dict.items(), key=lambda x: (x[1][0], x[1][1]), reverse=True)\n    return [movie[0] for movie in sorted_movies]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/62": [{"task_id": "EvoEval/62", "solution": "def recipe_converter(recipe, conversion_factor):\n    \"\"\"\n    Write a function that takes a dictionary representing a recipe as input \n    where the keys are the ingredients and the values are the quantities \n    needed for one serving. The function should also take a conversion factor \n    which represents the number of servings required. The function should \n    return a new dictionary where the quantities of each ingredient are \n    multiplied by the conversion factor.\n\n    The quantities in the recipe are integers and the conversion factor is a \n    positive integer. \n\n    Examples:\n    >>> recipe_converter({\"flour\": 500, \"sugar\": 200, \"eggs\": 3}, 2)\n    {'flour': 1000, 'sugar': 400, 'eggs': 6}\n    >>> recipe_converter({\"milk\": 250, \"chocolate\": 75, \"butter\": 50}, 3)\n    {'milk': 750, 'chocolate': 225, 'butter': 150}\n    \"\"\"\n    return {ingredient: quantity * conversion_factor for (ingredient, quantity) in recipe.items()}", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/44": [{"task_id": "EvoEval/44", "solution": "def fairy_tale_transport(q, w, e):\n    \"\"\"\n    In a fairy tale world, three types of magical creatures are there: unicorns, dragons, and griffins. The unicorns can carry 'w' kg, dragons can carry 'e' kg, and griffins can carry 'e' kg of weight. You have a list of weights of different items you want to carry.\n    \n    Write a function that returns True if the combined strength of these magical creatures can carry all the items, and False otherwise. \n\n    The function will take three parameters - a list q of weights of items, an integer w representing the carrying capacity of unicorns, an integer e representing the carrying capacity of dragons and griffins together.\n    \n    Example:\n    fairy_tale_transport([5, 10, 15], 5, 20) \u279e False\n    \n    fairy_tale_transport([10, 20, 30], 5, 10) \u279e False\n\n    fairy_tale_transport([1, 2, 3], 1, 5) \u279e True\n    \n    fairy_tale_transport([5, 10, 15], 15, 15) \u279e True\n    \"\"\"\n    total_weight = sum(q)\n    total_capacity = w + e\n    if total_weight <= total_capacity:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/69": [{"task_id": "EvoEval/69", "solution": "def magicTrick(cards, magicNumber):\n    for i in range(len(cards)):\n        for j in range(i + 1, len(cards)):\n            if cards[i] * cards[j] == magicNumber:\n                return (i, j)\n    return 'No magic today'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/41": [{"task_id": "EvoEval/41", "solution": "def spider_web_jump(arr):\n    rows = len(arr)\n    cols = len(arr[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = arr[0][0]\n    for i in range(1, rows):\n        dp[i][0] = dp[i - 1][0] + arr[i][0]\n    for j in range(1, cols):\n        dp[0][j] = dp[0][j - 1] + arr[0][j]\n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + arr[i][j]\n    return dp[rows - 1][cols - 1]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[0, 2, 3, 4, 5], [1, 1, 1, 1, 1]]]], "plus_fail_tests": []}], "EvoEval/88": [{"task_id": "EvoEval/88", "solution": "def planet_population(dict_of_planets):\n    \"\"\"\n    You are given a dictionary where each key represents a planet\n    and its value is a list of population features.\n    Each list contains two elements: [\"Population\", \"Size\"].\n    The \"Population\" is a positive integer representing the number of inhabitants,\n    and \"Size\" is a positive integer representing the planet's size in square kilometers.\n\n    Your task is to create a function that returns a new dictionary,\n    where each planet is paired with its population density (population/size).\n    If a planet's size or population is not provided, ignore that planet.\n\n    If the dictionary is empty or no planet has complete data, return an empty dictionary.\n\n    The population density should be rounded to two decimal places.\n\n    Examples:\n    planet_population({\"Earth\": [7000000000, 15000000], \"Mars\": [0, 25000000]}) == {'Earth': 466.67, 'Mars': 0.0}\n    planet_population({}) == {}\n    planet_population({\"Jupiter\": [None, 64000000]}) == {}\n    planet_population({\"Venus\": [500000000, None]}) == {} \n    \"\"\"\n    result = {}\n    for (planet, data) in dict_of_planets.items():\n        if data[0] is not None and data[1] is not None:\n            result[planet] = round(data[0] / data[1], 2)\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/5": [{"task_id": "EvoEval/5", "solution": "from typing import List, Tuple\n\n\ndef zigzag_traversal(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Given a 2D list of integers, return a list that represents its elements traversed in a zigzag order starting from the top-left corner and moving rightwards.\n    When the right end is reached, the direction should be downwards to the next row, then to the left end, and so on until all elements are covered. \n    >>> zigzag_traversal([[1, 2], [3, 4], [5, 6, 7], [8, 9, 10]])\n    [1, 2, 4, 3, 5, 6, 7, 10, 9, 8]\n    \"\"\"\n    result = []\n    flip = False\n    for row in matrix:\n        if flip:\n            result.extend(row[::-1])\n        else:\n            result.extend(row)\n        flip = not flip\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/93": [{"task_id": "EvoEval/93", "solution": "def secret_code(message, n_values):\n    encoded_message = ''\n    n_values_len = len(n_values)\n    for i in range(len(message)):\n        char = message[i]\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            encoded_char = chr((ord(char) - ascii_offset + n_values[i % n_values_len]) % 26 + ascii_offset)\n            encoded_message += encoded_char\n        else:\n            encoded_message += char\n    return encoded_message", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/46": [{"task_id": "EvoEval/46", "solution": "def hidden_message(test_cases):\n    \"\"\"\n    Covert Agent X has a unique way of encrypting secret messages for others \n    to decipher. He encrypts his messages by providing strings of words, where \n    the first letter of each word (when pieced together) forms a secret message.\n\n    Your task is to write a function that takes in a group of test cases, \n    and returns the secret message from each test case.\n\n    Each test case is a list of strings. The function should return a list of strings,\n    where each string is a secret message decoded from a test case.\n    If the secret message can be found within the original strings, the secret message is now \"Take the cannoli.\"\n\n    Note: \n    - Words may have symbols next to them, but these should be ignored.\n    - Return the message in lowercase\n\n    Examples:\n    hidden_message([['Hello, world!', 'okay?'], ['Every', 'good', 'boy', 'does', 'fine']]) -> ['ho', 'egbdf']\n    hidden_message([['apple'], ['Banana', 'grape', 'kiwi', 'melon']]) -> ['Take the cannoli.', 'bgkm']\n    hidden_message([['This', 'is', '?a', 'test', 'case??'], ['hi']]) -> ['tiatc', 'Take the cannoli.']\n    \"\"\"\n    result = []\n    for test_case in test_cases:\n        message = ''\n        for string in test_case:\n            words = string.split()\n            for word in words:\n                message += word[0].lower()\n        if message in ' '.join(test_case).lower():\n            message = 'Take the cannoli.'\n        result.append(message)\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[["Hello, world!", "okay?"], ["Every", "good", "boy", "does", "fine"]]]], "plus_fail_tests": []}], "EvoEval/32": [{"task_id": "EvoEval/32", "solution": "def playlist_shuffle(playlist: list, seed: int):\n    \"\"\"Return a new playlist order based on a numerical seed.\n\n    Given a list of song titles (strings) as 'playlist' and an odd integer 'seed',\n    implement an algorithm to shuffle the playlist to create a new order.\n    The same seed should always produce the same shuffled playlist.\n\n    The shuffling algorithm should use the seed to produce a series of swaps in the sorted list.\n    To produce the series, start at index 0 and swap with the element\n    at the index `seed % playlist_length`. It's important to note that if a song title contains the word \"Rock\", it should remain unmoved during the swapping process (the swap operation will be skipped). For the next index, update the\n    seed using the formula: seed = (seed * 16807) % 2147483647. Continue this process\n    from the next index until the end of the list. Note that the seed will be updated for every index (swapped or not).\n\n    >>> playlist_shuffle([\"One More Time\", \"Around the World\", \"Harder Better Faster Stronger\", \"Technologic\", \"Robot Rock\"], 7)\n    ['Harder Better Faster Stronger', 'One More Time', 'Technologic', 'Around the World', 'Robot Rock']\n    >>> playlist_shuffle([\"Song 2\", \"Parklife\", \"Country House\", \"Song 2\", \"Girls & Boys\"], 3)\n    ['Song 2', 'Parklife', 'Girls & Boys', 'Song 2', 'Country House']\n    \"\"\"\n    playlist_length = len(playlist)\n    for i in range(playlist_length):\n        if 'Rock' in playlist[i]:\n            continue\n        swap_index = seed % playlist_length\n        (playlist[i], playlist[swap_index]) = (playlist[swap_index], playlist[i])\n        seed = seed * 16807 % 2147483647\n    return playlist", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["Stairway to Heaven", "Whole Lotta Love", "Kashmir", "Rock and Roll", "D'yer Mak'er", "Immigrant Song", "When the Levee Breaks", "Black Dog", "Good Times Bad Times", "Heartbreaker"], 17]], "plus_fail_tests": []}], "EvoEval/17": [{"task_id": "EvoEval/17", "solution": "def wizard_battle(dragon_hp: int, wizards: list) -> str:\n    \"\"\" Return the name of the wizard who defeated the dragon, given the dragon's hit points (HP) and\n    an ordered list with the name of the wizard and their magic power:\n        - The wizard's magic reduces the dragon's HP by their magic power. \n        - Wizards take turns in the order they are listed, and they only get to attack once.\n        - The dragon is defeated when its HP is reduced to 0 or less.\n\n    If none of the wizards can defeat the dragon return 'The dragon won!'\n\n    Note that the wizards are a list of tuples, where each tuple has the wizard's name as a string and\n    their magic power as an integer. The dragon's HP is a positive integer.\n\n    >>> wizard_battle(20, [('Gandalf', 15), ('Merlin', 10), ('Dumbledore', 30)])\n    'Merlin'\n    >>> wizard_battle(100, [('Harry', 25), ('Ron', 20), ('Hermione', 30), ('Luna', 10)])\n    'The dragon won!'\n    >>> wizard_battle(65, [('Newt', 15), ('Tina', 20)])\n    'The dragon won!'\n    \"\"\"\n    for wizard in wizards:\n        dragon_hp -= wizard[1]\n        if dragon_hp <= 0:\n            return wizard[0]\n    return 'The dragon won!'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/47": [{"task_id": "EvoEval/47", "solution": "def recipe_ingredients(recipe, available):\n    \"\"\"Checks if a particular recipe can be cooked with the available ingredients.\n\n    Args:\n        recipe (dict): A dictionary where the keys are the ingredient names and the values are the quantities.\n        available (dict): A dictionary where the keys are the ingredient names and the values are the quantities.\n\n    Returns:\n        bool: True if all ingredients needed for the recipe are available, False otherwise.\n    \"\"\"\n    for (ingredient, quantity) in recipe.items():\n        if ingredient not in available or available[ingredient] < quantity:\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/74": [{"task_id": "EvoEval/74", "solution": "def cipher_mapping(s, cipher):\n    \"\"\"Given a string 's' and a mapping dictionary 'cipher', your task is to implement \n    a function that returns a new string where each character in 's' has been replaced \n    by its corresponding value in 'cipher'. \n    If a character in 's' does not exist in 'cipher', leave it as it is in the new string.\n    If 's' is an empty string, the function should return an empty string.\n    \"\"\"\n    new_string = ''\n    for char in s:\n        if char in cipher:\n            new_string += cipher[char]\n        else:\n            new_string += char\n    return new_string", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/56": [{"task_id": "EvoEval/56", "solution": "def str_to_morse_code(s):\n    morse_code_dict = {'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', 'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', 's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', 'y': '-.--', 'z': '--..'}\n    words = s.split(' ')\n    morse_code = []\n    for word in words:\n        morse_word = []\n        for letter in word:\n            morse_word.append(morse_code_dict[letter])\n        morse_code.append(' '.join(morse_word))\n    return ' / '.join(morse_code)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/31": [{"task_id": "EvoEval/31", "solution": "def unique_paths(m: int, n: int) -> int:\n    \"\"\"\n    A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n    The robot can only move either down or right at any point in time. \n    The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n    How many possible unique paths are there from start to finish?\n    >>> unique_paths(3, 2)\n    3\n    >>> unique_paths(7, 3)\n    28\n    >>> unique_paths(3, 3)\n    6\n\n    :param m: the number of rows in the grid\n    :param n: the number of columns in the grid\n    :return: the number of possible unique paths from start to finish\n    \"\"\"\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[-1][-1]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/76": [{"task_id": "EvoEval/76", "solution": "def create_pyramid(lst):\n    \"\"\"\n    You are given a list of positive integers. \n    Your task is to create a pyramid out of the numbers, where every level of the pyramid \n    is represented by a string of equal length. The number of characters in a string equals \n    the sum of the positive integers in the corresponding level of the pyramid.\n    The pyramid should be built from the bottom up, i.e. the first element of the list \n    should form the bottom level of the pyramid.\n    Return the pyramid as a list of strings. If the list of integers is empty, return an \n    empty list.\n\n    Note: Use the character '#' to represent the numbers.\n\n    Examples:\n    create_pyramid([3, 2, 1]) == ['#', '##', '###']\n    create_pyramid([5, 4, 2]) == ['##', '####', '#####']\n    create_pyramid([]) == []\n    \"\"\"\n    pyramid = []\n    for num in lst:\n        pyramid.insert(0, '#' * num)\n    return pyramid", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/22": [{"task_id": "EvoEval/22", "solution": "def galactic_travel(t, v):\n    \"\"\"Given the time (t) in years and average velocity (v) in km/s, calculate the distance traveled in light years in a galaxy far, far away.\n    Assume that 1 light year is approximately 9.461 x 10^12 km.\n\n    >>> galactic_travel(1, 300000)\n    0.9999788605855617\n    \"\"\"\n    v_year = v * 60 * 60 * 24 * 365\n    d_km = v_year * t\n    d_ly = d_km / (9.461 * 10 ** 12)\n    return d_ly", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/75": [{"task_id": "EvoEval/75", "solution": "def magical_string_transformer(input_str):\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    digits = '0123456789'\n    special_chars = {'?': '!', '!': '?'}\n    transformed_str = ''\n    for (i, char) in enumerate(input_str):\n        if char.lower() in vowels:\n            transformed_str += vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n            if char.isupper():\n                transformed_str = transformed_str[:-1] + transformed_str[-1].upper()\n        elif char.lower() in consonants:\n            transformed_str += consonants[(consonants.index(char.lower()) + 1) % len(consonants)]\n            if char.isupper():\n                transformed_str = transformed_str[:-1] + transformed_str[-1].upper()\n        elif char in digits:\n            transformed_str += digits[(digits.index(char) + 1) % len(digits)]\n        elif char in special_chars.keys():\n            if i % 2 == 0:\n                transformed_str += special_chars[char]\n            else:\n                transformed_str += char\n        else:\n            transformed_str += char\n    return transformed_str", "base_status": "fail", "plus_status": null, "base_fail_tests": [["?!AEIOUaeiou"]], "plus_fail_tests": []}], "EvoEval/58": [{"task_id": "EvoEval/58", "solution": "def interstellar_translator(earth_phrase):\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    translated_phrase = ''\n    for word in earth_phrase.split():\n        translated_word = ''\n        for char in word:\n            if char in vowels:\n                translated_word += vowels[(vowels.index(char) + 1) % len(vowels)]\n            elif char in consonants:\n                translated_word += consonants[(consonants.index(char) + 1) % len(consonants)]\n            else:\n                translated_word += '@'\n        if word[0] in vowels:\n            translated_word += 'xy'\n        else:\n            translated_word += 'yz'\n        translated_phrase += translated_word.capitalize() + ' '\n    return translated_phrase.rstrip().replace(' ', '@')", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/11": [{"task_id": "EvoEval/11", "solution": "from typing import List\n\ndef fruity_messages(fruits: List[str], location: str) -> str:\n    if len(fruits) == 1:\n        return f'Oh, are those {fruits[0]} from {location}? Marvelous!'\n    elif len(fruits) == 2:\n        return f'Oh, are those {fruits[0]} and {fruits[1]} from {location}? Marvelous!'\n    else:\n        fruit_list = ', '.join(fruits[:-1]) + ' and ' + fruits[-1]\n        return f'Oh, are those {fruit_list} from {location}? Marvelous!'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/8": [{"task_id": "EvoEval/8", "solution": "def transform_canvas(canvas: str) -> str:\n    if canvas.count('P') != 1:\n        return 'Invalid canvas'\n    painter_index = canvas.index('P')\n    left_canvas = canvas[:painter_index]\n    right_canvas = canvas[painter_index + 1:]\n    for i in range(len(left_canvas) - 1, -1, -1):\n        if left_canvas[i] == '-':\n            left_canvas = left_canvas[:i] + '*' + left_canvas[i + 1:]\n        elif left_canvas[i] == '#':\n            break\n    for i in range(len(right_canvas)):\n        if right_canvas[i] == '-':\n            right_canvas = right_canvas[:i] + '*' + right_canvas[i + 1:]\n        elif right_canvas[i] == '#':\n            break\n    painted_canvas = left_canvas + 'P' + right_canvas\n    if painted_canvas.count('*') % painted_canvas.count('-') == 0:\n        return 'Invalid canvas'\n    return painted_canvas", "base_status": "fail", "plus_status": null, "base_fail_tests": [["--#-P#-----#-----#--#--"]], "plus_fail_tests": []}], "EvoEval/15": [{"task_id": "EvoEval/15", "solution": "def evaluate_poker_hand(hand: list):\n    \"\"\" \n    Evaluate a poker hand and return its score.\n\n    In this game, we use the following point scoring rules:\n\n    1. Each card has a value (A=1, 2-10 = card number, J=11, Q=12, K=13)\n    2. A 'pair' (two cards of the same value) scores the value of the card.\n    3. A 'triple' (three cards of the same value) scores double the value of the card.\n    4. A 'four of a kind' (four cards of the same value) scores triple the value of the card.\n    5. A 'five of a kind' (five cards of the same value) scores quadruple the value of the card.\n    6. If hand has no pairs, triples or fours, score is 0\n\n    Note, you should consider all cards in hand, i.e., if there are both pair and triple, score should be score or pair + score of triple.\n\n    The \"hand\" list contains 5 strings, each representing a card in the format 'value+suit'\n    (i.e. ['10H', '10D', '10C', '2S', '2D']). The suit is irrelevant for this game.\n    \"\"\"\n    card_values = {'A': 1, 'J': 11, 'Q': 12, 'K': 13}\n    card_values.update({str(i): i for i in range(2, 11)})\n    card_counts = {value: 0 for value in card_values.keys()}\n    for card in hand:\n        card_counts[card[:-1]] += 1\n    score = 0\n    for (card, count) in card_counts.items():\n        if count == 2:\n            score += card_values[card]\n        elif count == 3:\n            score += 2 * card_values[card]\n        elif count == 4:\n            score += 3 * card_values[card]\n        elif count == 5:\n            score += 4 * card_values[card]\n    return score", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/78": [{"task_id": "EvoEval/78", "solution": "def find_pattern(mat):\n    n = len(mat)\n    result = []\n    for i in range(n):\n        result.append(mat[i][i])\n        result.append(mat[i][n - i - 1])\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9]]]], "plus_fail_tests": []}], "EvoEval/23": [{"task_id": "EvoEval/23", "solution": "def prime_cipher(s: str):\n\n    def generate_primes(n):\n        primes = []\n        candidate = 2\n        while len(primes) < n:\n            if all((candidate % prime != 0 for prime in primes)):\n                primes.append(candidate)\n            candidate += 1\n        return primes\n    primes = generate_primes(26)\n    prime_dict = {chr(97 + i): str(primes[i]) for i in range(26)}\n    return ''.join((prime_dict.get(c, c) for c in s))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/97": [{"task_id": "EvoEval/97", "solution": "def alien_invasion(alien, humans):\n    if not isinstance(alien, str) or not isinstance(humans, dict):\n        return []\n    continents_order = ['Asia', 'Africa', 'Europe', 'North America', 'South America']\n    encounter_order = []\n    for continent in continents_order:\n        for (human, location) in humans.items():\n            if location == continent:\n                encounter_order.append(human)\n    return encounter_order", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/65": [{"task_id": "EvoEval/65", "solution": "def food_order(menu, order):\n    if not order:\n        return menu\n    final_order = menu.copy()\n    for (food, changes) in order.items():\n        if 'remove' in changes:\n            for ingredient in changes['remove']:\n                final_order[food].remove(ingredient)\n        if 'add' in changes:\n            final_order[food].extend(changes['add'])\n    return final_order", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/84": [{"task_id": "EvoEval/84", "solution": "def tree_traversal(tree, path=None, paths=None):\n    if path is None:\n        path = []\n    if paths is None:\n        paths = []\n    for (node, children) in tree.items():\n        new_path = path + [node]\n        if children:\n            tree_traversal(children, new_path, paths)\n        else:\n            paths.append(new_path)\n    return paths", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/42": [{"task_id": "EvoEval/42", "solution": "def find_legendary_item(player_input):\n    \"\"\"\n    In a popular multiplayer online game, players can acquire various items. Each item has a rarity value \n    ranging from 1 (common) to 5 (legendary). In a single game, a player can acquire multiple items but with \n    the condition that the rarity of each item is unique. The player_input is a list representing the items \n    acquired by a player in a single game, where each item is represented by its rarity.\n    \n    Your task is to write a function that determines if the player has acquired a legendary item (rarity 5) \n    in the game. The function should return True if a legendary item has been acquired and False otherwise. \n\n    Further, if a legendary item has been acquired, the function should return the rarity of the second most \n    valuable item that the player has acquired. If the player has only acquired the legendary item, return -1.\n\n    The function should be able to handle player_input lists of any length.\n\n    Examples:\n        find_legendary_item([1, 2, 3, 4, 5]) == (True, 4)\n        find_legendary_item([5]) == (True, -1)\n        find_legendary_item([1, 3, 4]) == (False, None)\n        find_legendary_item([]) == (False, None)\n    \"\"\"\n    if 5 in player_input:\n        player_input.remove(5)\n        if len(player_input) == 0:\n            return (True, -1)\n        else:\n            return (True, max(player_input))\n    else:\n        return (False, None)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/4": [{"task_id": "EvoEval/4", "solution": "from typing import List\n\n\ndef candles_relight(candles: List[int]) -> int:\n    \"\"\"\n    You've got a list representing a row of birthday candles of various heights.\n    A candle at position \"i\" can be lit (gets the flame) if it is taller than all the candles \n    before it. The first candle is always lit. \n    Your task is to return the number of candles that can be lit.\n    An empty list means there were no candles, so return 0.\n\n    >>> candles_relight([3, 2, 1, 3, 2, 4])\n    2\n    >>> candles_relight([1, 2, 3, 4, 5])\n    5\n    >>> candles_relight([])\n    0\n    \"\"\"\n    if not candles:\n        return 0\n    lit_candles = 1\n    max_height = candles[0]\n    for candle in candles[1:]:\n        if candle > max_height:\n            lit_candles += 1\n            max_height = candle\n    return lit_candles", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/54": [{"task_id": "EvoEval/54", "solution": "def find_star_map(lst, star):\n    coordinates = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == star:\n                coordinates.append((i, j))\n    return coordinates", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/99": [{"task_id": "EvoEval/99", "solution": "def musical_chairs(n, rounds, music):\n    players = list(range(1, n + 1))\n    for round in rounds:\n        position = round * music % len(players)\n        del players[position]\n    return players", "base_status": "fail", "plus_status": null, "base_fail_tests": [[10, [1, 2, 3, 4, 5], 1]], "plus_fail_tests": []}], "EvoEval/12": [{"task_id": "EvoEval/12", "solution": "from typing import List\n\ndef teleporter_energy_signature(flux_values: List[int]) -> int:\n    \"\"\"\n    In the year 7082, teleporters are the primary mode of transportation across cities. Teleporter do\n    not function without a unique energy signature. This unique energy signature is formed by\n    performing certain operations over list of flux values recorded daily.\n\n    Given a list of flux values (integers always >= 0), your task is to determine the unique energy signature \n    by using the following steps:\n    - Find the element with maximum occurrence. If there are multiple, select the smallest one.\n    - Find the sum of all elements in the array.\n    - Multiply the sum of all elements with the most occurred number.\n\n    Return the result.\n\n    >>> teleporter_energy_signature([1, 2, 3, 2, 1, 2, 5, 1, 6])\n    23\n\n    Explanation: The number 2 and 1 appear thrice in the list, but 1 is smaller. \n    The sum of all elements in the array is 23. So, 23 * 1 = 23\n    \"\"\"\n    counter = Counter(flux_values)\n    max_occurred_number = min((k for (k, v) in counter.items() if v == max(counter.values())))\n    sum_of_elements = sum(flux_values)\n    return sum_of_elements * max_occurred_number", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 2, 1, 2, 5, 1, 6]]], "plus_fail_tests": []}], "EvoEval/90": [{"task_id": "EvoEval/90", "solution": "def magical_multiply(s1, s2):\n    \"\"\"\n    In the mystical land of Pyth, numbers behave quite differently. Here, when two numbers are multiplied, the result is given by the sum of all possible unique combinations of their digits. \n\n    For example, if two numbers 24 and 13 are multiplied, the result would be the sum of all unique combinations of digits (2, 4) and (1, 3). The combinations would be (2, 1), (2, 3), (4, 1) and (4, 3) and their sums would be 3, 5, 5 and 7, and hence the result of the multiplication would be 3 + 5 + 5 + 7 = 20.\n\n    The function magical_multiply(s) would take in two positive integers as input (in string format) and should return their product according to the laws of the land of Pyth.\n\n    For example:\n    >>> magical_multiply('24', '13')\n    20\n    >>> magical_multiply('56', '79')\n    54\n    \"\"\"\n    s1 = [int(digit) for digit in s1]\n    s2 = [int(digit) for digit in s2]\n    result = 0\n    for digit1 in s1:\n        for digit2 in s2:\n            result += digit1 + digit2\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["999", "999"]], "plus_fail_tests": []}], "EvoEval/0": [{"task_id": "EvoEval/0", "solution": "from typing import List, Union\n\ndef calculate_shipping_cost(items: List[Union[str, float]], location: str) -> str:\n    base_cost = 5.0\n    additional_charge = 10.0\n    string_multiplier = 1.5\n    location_factors = {'Local': 1.0, 'National': 1.5, 'International': 2.5}\n    total_cost = 0.0\n    string_present = False\n    for item in items:\n        if isinstance(item, str):\n            total_cost += base_cost * string_multiplier\n            string_present = True\n        else:\n            total_cost += base_cost\n            if item > 5.0:\n                total_cost += additional_charge\n    location_factor = location_factors.get(location, 1.0)\n    total_cost *= location_factor\n    if string_present:\n        total_cost *= string_multiplier\n    return '{:.2f}'.format(total_cost)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["cipher", 2]], "plus_fail_tests": []}], "EvoEval/24": [{"task_id": "EvoEval/24", "solution": "def alien_language_translator(english_word: str) -> str:\n    \"\"\"\n    Assume there is an alien language where each English alphabet is replaced by a unique symbol. \n    In this language, the symbol for 'a' is '+', 'b' is '-', 'c' is '*', 'd' is '/', 'e' is '%', 'f' is '@', 'g' is '!',\n    'h' is '#', 'i' is '$', 'j' is '^', 'k' is '&', 'l' is '(', 'm' is ')', 'n' is '=', 'o' is '?', 'p' is ':',\n    'q' is ';', 'r' is '`', 's' is '~', 't' is '>', 'u' is '<', 'v' is '{', 'w' is '}', 'x' is '[', 'y' is ']', 'z' is '|'.\n    Write a function that translates an English word into this alien language.\n\n    >>> alien_language_translator(\"hello\")\n    '#%((?'\n\n    >>> alien_language_translator(\"alien\")\n    '+($%='\n    \"\"\"\n    translation_dict = {'a': '+', 'b': '-', 'c': '*', 'd': '/', 'e': '%', 'f': '@', 'g': '!', 'h': '#', 'i': '$', 'j': '^', 'k': '&', 'l': '(', 'm': ')', 'n': '=', 'o': '?', 'p': ':', 'q': ';', 'r': '`', 's': '~', 't': '>', 'u': '<', 'v': '{', 'w': '}', 'x': '[', 'y': ']', 'z': '|'}\n    alien_word = ''\n    for char in english_word:\n        alien_word += translation_dict[char]\n    return alien_word", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/96": [{"task_id": "EvoEval/96", "solution": "def get_magic_indices(lst):\n    magic_indices = []\n    for i in range(len(lst)):\n        val = abs(lst[i])\n        if i == 0 and val == 0:\n            magic_indices.append(i)\n        elif i != 0 and val % i == 0:\n            product = 1\n            for digit in str(val):\n                product *= int(digit)\n            if product == i:\n                magic_indices.append(i)\n    return sorted(magic_indices)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/89": [{"task_id": "EvoEval/89", "solution": "def space_invaders(aliens, ray):\n    \"\"\"\n    A space invader game is being designed. There are n aliens represented by an array where each alien is at a certain position. \n    You are given a ray gun that can destroy an alien at a position in one shot. But the ray gun can also destroy all \n    the aliens in the positions adjacent to it. \n\n    The space_invaders function takes two parameters: an array of integers where each integer represents an alien's position \n    and an integer representing the position to aim the ray gun.\n\n    The function should return an array of the remaining aliens' positions after the ray gun has been fired. \n\n    Assume that the position of aliens and the ray are always positive integers. \n\n    Remember: The ray gun destroys the alien at its aimed position as well as any alien in the adjacent positions. \n    The ray gun does not destroy any aliens that live in odd positions unless they are directly aimed at\n\n    Examples:\n\n    assert space_invaders([1, 2, 3, 4, 5], 3) == [1, 5]\n    assert space_invaders([1, 2, 4, 5, 6], 4) == [1, 2, 5, 6]\n    assert space_invaders([2, 3, 5, 6, 7, 9, 10], 6) == [2, 3, 5, 7, 9, 10]\n    assert space_invaders([1, 2, 3, 5, 6, 7], 1) == [3, 5, 6, 7]\n    \"\"\"\n    remaining_aliens = []\n    for alien in aliens:\n        if alien not in [ray, ray - 1, ray + 1]:\n            remaining_aliens.append(alien)\n    return remaining_aliens", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 4, 5, 6], 4]], "plus_fail_tests": []}], "EvoEval/34": [{"task_id": "EvoEval/34", "solution": "def werewolf_transformation(n: int, m: int):\n    transformation = [0]\n    for i in range(1, n):\n        if i < m:\n            transformation.append(min(transformation[-1] + 10, 100))\n        elif i == m:\n            transformation.append(min(transformation[-1] * 2, 100))\n        else:\n            transformation.append(max(transformation[-1] - 10, 0))\n    return transformation", "base_status": "fail", "plus_status": null, "base_fail_tests": [[5, 3]], "plus_fail_tests": []}], "EvoEval/9": [{"task_id": "EvoEval/9", "solution": "\ndef calculate_word_frequency(string: str) -> dict:\n    \"\"\" Given a string, calculate the frequency of each word present in that string (regardless of case) and return a dictionary with words as keys and their frequencies as values. \n    Words are separated by spaces. Ignore punctuation.\n    \n    >>> calculate_word_frequency('Hello, World! Hello Again.')\n    {'hello': 2, 'world': 1, 'again': 1}\n\n    >>> calculate_word_frequency('This is a test. This is only a test.')\n    {'this': 2, 'is': 2, 'a': 2, 'test': 2, 'only': 1}\n    \"\"\"\n    words = re.sub('[^\\\\w\\\\s]', '', string.lower()).split()\n    frequency = {}\n    for word in words:\n        if word in frequency:\n            frequency[word] += 1\n        else:\n            frequency[word] = 1\n    return frequency", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Hello, World! Hello Again."]], "plus_fail_tests": []}], "EvoEval/35": [{"task_id": "EvoEval/35", "solution": "def validate_email_structure(email: str) -> bool:\n    if email.count('@') == 1 and email[0] != '@' and (email[-1] != '@'):\n        at_index = email.index('@')\n        if '.' in email[at_index:]:\n            return True\n    return False", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/53": [{"task_id": "EvoEval/53", "solution": "def magical_transformation(s):\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    transformed = ''\n    for (i, char) in enumerate(s):\n        if char.lower() in vowels:\n            next_vowel = vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n            transformed += next_vowel.upper() if char.isupper() else next_vowel\n        elif char.lower() in consonants:\n            next_consonant = consonants[(consonants.index(char.lower()) + 1) % len(consonants)]\n            transformed += next_consonant.upper() if char.isupper() else next_consonant\n        elif char in ['?', '!']:\n            transformed += '!' if i % 2 == 0 else '?'\n        else:\n            transformed += char\n    return transformed", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Hello World???"]], "plus_fail_tests": []}], "EvoEval/33": [{"task_id": "EvoEval/33", "solution": "def magical_staircase(n: int, magic_stones: list):\n    ways = [0] * (n + 1)\n    ways[0] = 1\n    for i in range(1, n + 1):\n        for stone in magic_stones:\n            if i >= stone:\n                ways[i] += ways[i - stone]\n    return ways[n]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/87": [{"task_id": "EvoEval/87", "solution": "def word_spiral(arr):\n    if not arr:\n        return ''\n    result = []\n    while arr:\n        result += arr.pop(0)\n        if arr and arr[0]:\n            for row in arr:\n                result.append(row.pop())\n        if arr and arr[-1]:\n            result += arr.pop()[::-1]\n        if arr and arr[0]:\n            for row in arr[::-1]:\n                result.append(row.pop(0))\n    return ''.join(result)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/43": [{"task_id": "EvoEval/43", "solution": "def space_travel(distance, speed, fuel, planet_gravity, spaceship_weight):\n    \"\"\"\n    Given the distance of a planet from Earth in light years, the speed of the spaceship in light years per year, the amount of fuel in the spaceship in years, the gravity of the planet and the weight of the spaceship.\n    Fuel consumption is computed as spaceship_weight * planet_gravity * 0.1 per year.\n    Return the remaining fuel rounded to 2 decimal points once the spaceship reaches the planet, if it is possible for the spaceship to reach the planet.\n    Otherwise, return 'Insufficient fuel'.\n    The spaceship can reach the planet if the amount of fuel is greater than or equal to the duration of the trip (distance divided by speed).\n    The remaining fuel is calculated by subtracting the fuel consumption of the trip from the initial amount of fuel.\n    Note: The spaceship travels at a constant speed and the fuel consumption is constant unless otherwise mentioned.\n\n    Example:\n    space_travel(4.22, 0.5, 10, 9.8, 100) returns 'Insufficient fuel'\n    space_travel(2.5, 1, 2, 3.7, 1.5) returns 0.61\n    \"\"\"\n    trip_duration = distance / speed\n    fuel_consumption_per_year = spaceship_weight * planet_gravity * 0.1\n    total_fuel_consumption = fuel_consumption_per_year * trip_duration\n    if fuel >= total_fuel_consumption:\n        remaining_fuel = fuel - total_fuel_consumption\n        return round(remaining_fuel, 2)\n    else:\n        return 'Insufficient fuel'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/29": [{"task_id": "EvoEval/29", "solution": "def find_palindrome_substrings(s: str):\n    \"\"\"\n    Given a string, find all unique substrings that are palindromes.\n    \n    A palindrome is a word, number, phrase, or other sequence of characters that reads the same forward and backward, ignoring spaces, punctuation, and capitalization.\n    \n    Return a list of all unique palindrome substrings, sorted in ascending order.\n\n    >>> find_palindrome_substrings('racecar')\n    ['a', 'aceca', 'c', 'cec', 'e', 'r', 'racecar']\n\n    >>> find_palindrome_substrings('madam')\n    ['a', 'ada', 'd', 'm', 'madam']\n\n    >>> find_palindrome_substrings('civic')\n    ['c', 'civic', 'i', 'ivi', 'v']\n\n    >>> find_palindrome_substrings('hello')\n    ['e', 'h', 'l', 'll', 'o']\n\n    >>> find_palindrome_substrings('hannah')\n    ['a', 'anna', 'h', 'hannah', 'n', 'nn']\n    \"\"\"\n    palindromes = set()\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substr = s[i:j]\n            if substr == substr[::-1]:\n                palindromes.add(substr)\n    return sorted(list(palindromes))", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/28": [{"task_id": "EvoEval/28", "solution": "def calculate_progressive_tax(income: float, deductions=0) -> float:\n    if deductions <= 1000:\n        income -= deductions\n    elif deductions <= 3000:\n        income -= 1000 + (deductions - 1000) * 2\n    else:\n        income -= 1000 + 2000 * 2 + (deductions - 3000) * 3\n    if income <= 10000:\n        tax = 0\n    elif income <= 35000:\n        tax = (income - 10000) * 0.15\n    elif income <= 80000:\n        tax = 25000 * 0.15 + (income - 35000) * 0.25\n    else:\n        tax = 25000 * 0.15 + 45000 * 0.25 + (income - 80000) * 0.3\n    return tax", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/7": [{"task_id": "EvoEval/7", "solution": "def find_shangri_la(code_sequence: list[int]) -> str:\n    \"\"\"\n    You are an explorer trying to find the mythical city of Shangri-La. According to an ancient text,\n    Shangri-La can be found by following a code sequence of numbers, each referring to the direction to move.\n    The directions correspond to 0: North, 1: East, 2: South, 3: West.\n    \n    Implement a function that takes a sequence of numbers as input and returns whether the sequence leads to Shangri-La.\n    Assume starting point is always (0,0). If the sequence leads back to the starting point, it has found Shangri-La and \n    function should return 'Shangri-La found'. Otherwise, return 'Shangri-La not found'.\n    Not moving is considered as not found.\n    \n    Note: Every move is considered as unit = 1.\n\n    Example:\n    >>> find_shangri_la([0, 1, 2, 3])\n    'Shangri-La found'\n    \n    >>> find_shangri_la([0, 1, 0, 3])\n    'Shangri-La not found'\n    \"\"\"\n    (x, y) = (0, 0)\n    for direction in code_sequence:\n        if direction == 0:\n            y += 1\n        elif direction == 1:\n            x += 1\n        elif direction == 2:\n            y -= 1\n        elif direction == 3:\n            x -= 1\n    if x == 0 and y == 0:\n        return 'Shangri-La found'\n    else:\n        return 'Shangri-La not found'", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[]]], "plus_fail_tests": []}], "EvoEval/13": [{"task_id": "EvoEval/13", "solution": "\nfrom typing import List\n\ndef find_rarest_element(elems: List[str]) -> str:\n    \"\"\" Find the rarest element in a list of strings. If there are multiple rarest elements, return the one that appears first. \n    If the list is empty, return None.\n\n    >>> find_rarest_element(['apple', 'banana', 'apple', 'orange', 'banana', 'orange', 'apple'])\n    'banana'\n    >>> find_rarest_element(['cat', 'dog', 'bird', 'cat', 'dog', 'cat'])\n    'bird'\n    >>> find_rarest_element([])\n    None\n    \"\"\"\n    if not elems:\n        return None\n    count = Counter(elems)\n    rarest = min(count.items(), key=lambda x: x[1])[0]\n    return rarest", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["apple", "apple", "apple", "banana", "banana", "orange", "orange"]]], "plus_fail_tests": []}], "EvoEval/95": [{"task_id": "EvoEval/95", "solution": "def matrixMystery(m):\n    \"\"\"Write a function that takes a 2D array of integers as input (a matrix m) and returns \n    the absolute difference between the sum of the diagonals. For the purpose of this problem, \n    the diagonals are defined as follows: \n\n    - The first diagonal starts at the top left corner and descends down to the right (i.e., along the line of m[i][i] for all i)\n    - The second diagonal starts at the top right corner and descends down to the left (i.e., along the line of m[i][len(m)-i-1] for all i)\n\n    If the matrix is not square, return 'Invalid Matrix'.\n\n    Example:\n    matrixMystery([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) => 0\n    matrixMystery([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) => 2\n    matrixMystery([[1, 2], [3, 4]]) => 0\n    \"\"\"\n    if len(m) != len(m[0]):\n        return 'Invalid Matrix'\n    diag1 = sum((m[i][i] for i in range(len(m))))\n    diag2 = sum((m[i][len(m) - i - 1] for i in range(len(m))))\n    return abs(diag1 - diag2)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/92": [{"task_id": "EvoEval/92", "solution": "def paint_fountain(n):\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    fountain = []\n    for i in range(n):\n        layer = [' '] * (2 * n - 1)\n        for j in range(i + 1):\n            layer[n - 1 - j] = layer[n - 1 + j] = alphabet[j % 26]\n        fountain.append(''.join(layer))\n    return '\\n'.join(fountain)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[3]], "plus_fail_tests": []}], "EvoEval/3": [{"task_id": "EvoEval/3", "solution": "from typing import List\n\ndef magical_alphabet(input_string: str) -> List[str]:\n    \"\"\" \n    Given a string where 'a' represents '1', 'b' represents '2', 'c' represents '3' ... 'z' represents '26'. \n    This function should return a list of all possible combinations based on the interpretation of the input string. \n    For example, if input is '123', it should return ['abc', 'lc', 'aw'] which represents ['1,2,3', '12,3', '1,23'].\n\n    >>> magical_alphabet('123')\n    ['abc', 'lc', 'aw']\n    \n    >>> magical_alphabet('111')\n    ['aaa', 'ak', 'ka']\n    \n    Note: Assume all input strings will only contain digits\n    \"\"\"\n\n    def helper(data, k, result):\n        if k == 0:\n            result.append(data)\n        else:\n            first = k[0]\n            if first != '0':\n                helper(data + chr(int(first) + 96), k[1:], result)\n            if len(k) > 1:\n                second = k[1]\n                if first != '0' and int(first + second) <= 26:\n                    helper(data + chr(int(first + second) + 96), k[2:], result)\n    result = []\n    helper('', input_string, result)\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["123"]], "plus_fail_tests": []}], "EvoEval/79": [{"task_id": "EvoEval/79", "solution": "def find_fruitful_days(prices, days):\n    max_profit = 0\n    for i in range(days):\n        for j in range(i + 1, days):\n            if prices[j] - prices[i] > max_profit:\n                max_profit = prices[j] - prices[i]\n    return max_profit", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/81": [{"task_id": "EvoEval/81", "solution": "def alien_language(word_list, alien_dictionary):\n    if not word_list:\n        return 'CORRECT'\n    alien_order = {char: i for (i, char) in enumerate(alien_dictionary)}\n    for i in range(len(word_list) - 1):\n        word1 = word_list[i]\n        word2 = word_list[i + 1]\n        for j in range(min(len(word1), len(word2))):\n            if word1[j] != word2[j]:\n                if alien_order[word1[j]] > alien_order[word2[j]]:\n                    return 'INCORRECT'\n                break\n        else:\n            if len(word1) > len(word2):\n                return 'INCORRECT'\n    return 'CORRECT'", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/25": [{"task_id": "EvoEval/25", "solution": "def word_frequency_analysis(text: str, word: str):\n    sentences = text.split('.')\n    word_frequency = text.lower().count(word.lower())\n    max_frequency_sentence = ''\n    max_frequency = 0\n    for sentence in sentences:\n        sentence_frequency = sentence.lower().count(word.lower())\n        if sentence_frequency > max_frequency:\n            max_frequency = sentence_frequency\n            max_frequency_sentence = sentence.strip()\n    return (word_frequency, max_frequency_sentence if max_frequency > 0 else '')", "base_status": "fail", "plus_status": null, "base_fail_tests": [["This is a test. Testing is fun.", "test"]], "plus_fail_tests": []}], "EvoEval/45": [{"task_id": "EvoEval/45", "solution": "def find_castle(arr):\n    max_hills = 0\n    for i in range(len(arr)):\n        left = i - 1\n        while left >= 0 and arr[left] <= arr[i]:\n            left -= 1\n        right = i + 1\n        while right < len(arr) and arr[right] <= arr[i]:\n            right += 1\n        max_hills = max(max_hills, right - left - 1)\n    return max_hills", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 2, 3, 2, 5, 3, 6, 4, 8, 2, 7]]], "plus_fail_tests": []}], "EvoEval/59": [{"task_id": "EvoEval/59", "solution": "def cooking_challenge(ingredient_dict):\n    \"\"\"\n    Given a dictionary where the keys are the main ingredients and the values are the number of recipes you can cook with this ingredient,\n    return a list of tuples where the first element of each tuple is an ingredient and the second is a number of recipes. The list should be \n    sorted in descending order based on the number of recipes. If two ingredients can be used in the same number of recipes, sort them in ascending \n    alphabetical order.\n    The function should return an empty list if the given dictionary is empty.\n    \n    Examples:\n    cooking_challenge({\"Chicken\": 5, \"Beef\": 10, \"Fish\": 2}) should return [('Beef', 10), ('Chicken', 5), ('Fish', 2)].\n    cooking_challenge({\"Tomato\": 10, \"Potato\": 10, \"Onion\": 5}) should return [('Potato', 10), ('Tomato', 10), ('Onion', 5)].\n    cooking_challenge({\"Eggs\": 3, \"Milk\": 0, \"Flour\": 2}) should return [('Eggs', 3), ('Flour', 2), ('Milk', 0)].\n    cooking_challenge({}) should return [].\n    \"\"\"\n    ingredient_list = list(ingredient_dict.items())\n    ingredient_list.sort(key=lambda x: (-x[1], x[0]))\n    return ingredient_list", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/63": [{"task_id": "EvoEval/63", "solution": "def create_pyramid(p):\n    \"\"\"\n    Given a positive integer p, your objective is to construct a pyramid. The base of the pyramid has p blocks. \n    The number of blocks in the next layer depends upon whether the number of blocks in the previous layer is even or odd.\n    The rules are as follows:\n        - If the number of blocks in the previous layer is even, the next layer contains 2 blocks less.\n        - If the number of blocks in the previous layer is odd, the next layer contains 3 blocks less.\n    Before the number of blocks in the next layer is less than or equal to zero, the pyramid is complete. Your function should return \n    a list containing the number of blocks in each layer from bottom to top. The element at index i in the list represents \n    the number of blocks in the (i+1)th layer from the bottom. \n\n    Examples:\n    >>> create_pyramid(10)\n    [10, 8, 6, 4, 2]\n    \n    >>> create_pyramid(9)\n    [9, 6, 4, 2]\n    \"\"\"\n    pyramid = []\n    while p > 0:\n        pyramid.append(p)\n        if p % 2 == 0:\n            p -= 2\n        else:\n            p -= 3\n    return pyramid", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/68": [{"task_id": "EvoEval/68", "solution": "def magical_sorting(arr):\n    if not arr:\n        return True\n    out_of_order = sum((arr[i] > arr[i + 1] for i in range(len(arr) - 1)))\n    if out_of_order == 0 or out_of_order == 2:\n        return True\n    return False", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[3, 4, 5, 1, 2]]], "plus_fail_tests": []}], "EvoEval/72": [{"task_id": "EvoEval/72", "solution": "def string_fairy_tale(lst):\n    \"\"\"Given a list of strings, where each string consists of a mix of letters and numbers, return a list.\n    Each element of the output should be a fairy tale inspired story. The story should be \"Once upon a time, \n    in a kingdom far away, lived a magical creature with the name of 'i' who was known for telling 'j' tales a day,\n    where 'i' is the i'th string of the input and 'j' is the count of digits in that string.\n    \"\"\"\n    result = []\n    for i in lst:\n        count = sum((c.isdigit() for c in i))\n        result.append(f\"Once upon a time, in a kingdom far away, lived a magical creature with the name of '{i}' who was known for telling {count} tales a day\")\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/39": [{"task_id": "EvoEval/39", "solution": "def asciiArt(n, s):\n    repeated_s = ''.join([char * n for char in s])\n    ascii_art = ['*' + repeated_s + '*'] * n\n    ascii_art.append('*' * len(ascii_art[0]))\n    ascii_art_str = '\\n'.join(ascii_art)\n    return ascii_art_str", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/52": [{"task_id": "EvoEval/52", "solution": "def magic_cookie_baker(n, m, orders):\n    orders.sort()\n    count = 0\n    for order in orders:\n        if order <= n and count < m:\n            count += 1\n        else:\n            break\n    return count", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/73": [{"task_id": "EvoEval/73", "solution": "def treasure_hunt(grid, bag_capacity):\n    import math\n    '\\n    You are an intrepid treasure hunter in a mysterious pyramid. The pyramid is represented by a rectangular grid, \\n    where each row represents a different chamber and each 1 represents a single treasure chest. \\n    Each chamber has a certain number of treasures and you have a bag that can carry a limited number of chests at a time. \\n    Your task is to collect as many treasures as possible. \\n    Output the number of trips you need to collect all treasures.\\n    A trip is defined as a going in or out of the pyramid (i.e., enter is a separate trip to exist)\\n\\n    Example 1:\\n        Input: \\n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\\n            bag_capacity : 1\\n        Output: 12\\n\\n    Example 2:\\n        Input: \\n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\\n            bag_capacity : 2\\n        Output: 10\\n    \\n    Example 3:\\n        Input: \\n            grid : [[0,0,0], [0,0,0]]\\n            bag_capacity : 5\\n        Output: 0\\n\\n    Constraints:\\n        * all chambers have the same number of chests\\n        * grid[i][j] -> 0 | 1\\n    '\n    total_treasures = sum((sum(row) for row in grid))\n    trips = math.ceil(total_treasures / bag_capacity) * 2\n    return trips", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/94": [{"task_id": "EvoEval/94", "solution": "def spell_casting(strings):\n    \"\"\"\n    You're a wizard and you have a list of spells represented as strings. Each of these spells consists \n    of several words. However, you can't just cast them in the order they are given. You have to sort \n    the words in each spell based on their length. If two words have the same length, keep them in the \n    original order.\n\n    Write a function that accepts a list of strings (spells) and returns a list where each spell string \n    has its words sorted as per the rule outlined above.\n\n    Example:\n    >>> spell_casting([\"hocus pocus\", \"wingardium leviosa\", \"expecto patronum\"])\n    ['hocus pocus', 'leviosa wingardium', 'expecto patronum']\n\n    >>> spell_casting([\"accio\", \"expelliarmus\", \"stupefy\"])\n    ['accio', 'expelliarmus', 'stupefy']\n\n    Note: You can assume that all words in the spells are separated by a single space and there are no punctuation marks.\n    \"\"\"\n    sorted_spells = []\n    for spell in strings:\n        words = spell.split()\n        sorted_words = sorted(words, key=len)\n        sorted_spells.append(' '.join(sorted_words))\n    return sorted_spells", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/20": [{"task_id": "EvoEval/20", "solution": "def generate_pattern(n: int):\n    \"\"\"\n    Given an integer 'n', return a list of strings where each string represents a pattern. \n    The pattern is composed of the numbers from 1 to n in ascending order, then descending back to 1, \n    with each number separated by a comma. If n is 0 or negative, return an empty list.\n\n    >>> generate_pattern(3)\n    ['1', '1,2', '1,2,3', '3,2,1', '2,1', '1']\n\n    >>> generate_pattern(0)\n    []\n    \"\"\"\n    if n <= 0:\n        return []\n    pattern = []\n    for i in range(1, n + 1):\n        pattern.append(','.join((str(j) for j in range(1, i + 1))))\n    for i in range(n, 0, -1):\n        pattern.append(','.join((str(j) for j in range(i, 0, -1))))\n    return pattern", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/83": [{"task_id": "EvoEval/83", "solution": "def reverse_vowels(s):\n    vowels = 'aeiouAEIOU'\n    s = list(s)\n    (i, j) = (0, len(s) - 1)\n    while i < j:\n        if s[i] not in vowels:\n            i += 1\n        elif s[j] not in vowels:\n            j -= 1\n        else:\n            (s[i], s[j]) = (s[j], s[i])\n            (i, j) = (i + 1, j - 1)\n    return ''.join(s)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/48": [{"task_id": "EvoEval/48", "solution": "def wizard_inventory(inventory_logs):\n    inventory = {}\n    for log in inventory_logs:\n        item = log['item']\n        quantity = log['quantity']\n        if item in inventory:\n            inventory[item] += quantity\n        else:\n            inventory[item] = quantity\n        if inventory[item] <= 0:\n            del inventory[item]\n    return inventory", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/38": [{"task_id": "EvoEval/38", "solution": "def translate_emoticons(sentence):\n    \"\"\"Convert text-based emoticons in a string to their corresponding Unicode emojis and return the result as a string.\n\n    If the sentence doesn't contain any text-based emoticons, return the original sentence.\n    Some examples of text-based emoticons and their corresponding emojis are \":)\" corresponds to \"\ud83d\ude0a\", \n    \":(\" corresponds to \"\u2639\ufe0f\", \":D\" corresponds to \"\ud83d\ude00\", \";)\" corresponds to \"\ud83d\ude09\". \n    \n    Examples:\n    >>> translate_emoticons(\"Hello :) Have a nice day! :D\")\n    \"Hello \ud83d\ude0a Have a nice day! \ud83d\ude00\"\n    >>> translate_emoticons(\"Oh no, it's raining! :(\")\n    \"Oh no, it's raining! \u2639\ufe0f\"\n    >>> translate_emoticons(\"No emoticons here\")\n    \"No emoticons here\"\n    \"\"\"\n    emoticons = {':)': '\ud83d\ude0a', ':(': '\u2639\ufe0f', ':D': '\ud83d\ude00', ';)': '\ud83d\ude09'}\n    for (emoticon, emoji) in emoticons.items():\n        sentence = sentence.replace(emoticon, emoji)\n    return sentence", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/51": [{"task_id": "EvoEval/51", "solution": "def alien_encoding(string, list_of_alphabets):\n    if not string:\n        return ''\n    if not list_of_alphabets:\n        return string\n    encoded_string = ''\n    for i in range(len(string)):\n        encoded_string += list_of_alphabets[i % len(list_of_alphabets)]\n    return encoded_string", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/50": [{"task_id": "EvoEval/50", "solution": "def text_to_morse(text):\n    morse_code_dict = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', ' ': ' '}\n    morse_code = ''\n    for char in text:\n        morse_code += morse_code_dict[char.upper()] + ' '\n    return morse_code.strip()", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/14": [{"task_id": "EvoEval/14", "solution": "def create_alias(name: str) -> str:\n    \"\"\" For a given name, create an alias following these rules:\n        If the name includes a vowel, replace it with the next vowel in the cycle a->e->i->o->u->a. \n        If the name includes a consonant, replace it with the next consonant in alphabetical order, once 'z' is reached, loop back to 'b'.\n        The alias should maintain the original names case (upper or lower)\n        Ignore any non-alphabetical characters.\n\n    >>> create_alias('John Doe')\n    'Kujp Fui'\n    \"\"\"\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    alias = ''\n    for char in name:\n        if char.lower() in vowels:\n            next_vowel = vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n            alias += next_vowel.upper() if char.isupper() else next_vowel\n        elif char.lower() in consonants:\n            next_consonant = consonants[(consonants.index(char.lower()) + 1) % len(consonants)]\n            alias += next_consonant.upper() if char.isupper() else next_consonant\n        else:\n            alias += char\n    return alias", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/70": [{"task_id": "EvoEval/70", "solution": "def planet_path(planets, path):\n    if not path or not planets:\n        return False\n    for i in range(len(path) - 1):\n        if path[i] not in planets or path[i + 1] not in planets[path[i]]:\n            return False\n    return True", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/2": [{"task_id": "EvoEval/2", "solution": "from typing import List, Union\n\ndef encrypt_message(words: List[str], key: Union[str, int]) -> List[Union[str, int]]:\n    \"\"\"\n    Given a list of words, first turn words into lowercase and then encrypt each word using a simple Caesar cipher. \n    The key for the cipher is either a string or an integer.\n    If the key is a string, convert it to an integer by summing the ASCII values \n    of its characters. If the key is an integer, use it as-is.\n\n    The Caesar cipher works by shifting each letter in the word by the \n    value of the key. If the letter after shifting exceeds 'z', it wraps \n    around to the start of the alphabet.\n\n    If the word contains any non-alphabetical characters, leave them as-is.\n\n    >>> encrypt_message([], \"abc\")\n    []\n    >>> encrypt_message([\"hello\", \"world\"], 3)\n    [\"khoor\", \"zruog\"]\n    >>> encrypt_message([\"hello\", \"world\"], \"abc\")\n    [\"pmttw\", \"ewztl\"]\n    \"\"\"\n    if isinstance(key, str):\n        key = sum((ord(c) for c in key))\n    encrypted_words = []\n    for word in words:\n        encrypted_word = ''\n        for char in word.lower():\n            if char.isalpha():\n                shift = ord(char) + key\n                while shift > ord('z'):\n                    shift -= 26\n                encrypted_word += chr(shift)\n            else:\n                encrypted_word += char\n        encrypted_words.append(encrypted_word)\n    return encrypted_words", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/21": [{"task_id": "EvoEval/21", "solution": "def crossword_validator(grid: list, words: list) -> bool:\n    n = len(grid)\n    for word in words:\n        found = False\n        for i in range(n):\n            if ''.join(grid[i]) == word or ''.join(grid[i][::-1]) == word:\n                found = True\n                break\n            if ''.join([grid[j][i] for j in range(n)]) == word or ''.join([grid[j][i] for j in range(n)][::-1]) == word:\n                found = True\n                break\n        if not found:\n            return False\n    return True", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[["a", "n", "t", "j", "u"], ["m", "o", "p", "k", "v"], ["r", "a", "c", "e", "w"], ["t", "i", "g", "h", "x"], ["j", "u", "m", "p", "z"]], ["ant", "race", "jump", "mop", "tig"]]], "plus_fail_tests": []}], "EvoEval/16": [{"task_id": "EvoEval/16", "solution": "def fibonacci_sum(n):\n    \"\"\"\n    Given a positive integer n, return the sum of the first n numbers in the Fibonacci sequence.\n    The Fibonacci sequence is a series of numbers where a number is the sum of the two preceding ones, starting with 0 and 1.\n    \n    >>> fibonacci_sum(1)\n    0\n    >>> fibonacci_sum(2)\n    1\n    >>> fibonacci_sum(3)\n    2\n    >>> fibonacci_sum(10)\n    88\n    >>> fibonacci_sum(20)\n    10945\n    >>> fibonacci_sum(30)\n    1346268\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        fib = [0, 1]\n        for i in range(2, n):\n            fib.append(fib[i - 1] + fib[i - 2])\n        return sum(fib)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/64": [{"task_id": "EvoEval/64", "solution": "def magical_sequence(start, end, divisor):\n    \"\"\"This function takes three positive integers: 'start', 'end', and 'divisor'. It returns a list of all \n    the numbers in the range ['start', 'end'] inclusive, that are divisible by 'divisor' and are prime numbers. \n    If no such number exists, the function should return an empty list.\n    \"\"\"\n    return [i for i in range(start, end + 1) if i % divisor == 0 and is_prime(i)]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[10, 20, 2]], "plus_fail_tests": []}], "EvoEval/71": [{"task_id": "EvoEval/71", "solution": "def letter_shift_cipher(s, n):\n    vowels = 'aeiou'\n    result = ''\n    vowel_count = 0\n    for char in s:\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            shifted_char = chr((ord(char) - ascii_offset + n) % 26 + ascii_offset)\n            result += shifted_char\n            if shifted_char.lower() in vowels:\n                vowel_count += 1\n        else:\n            result += char\n    return (result, vowel_count)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/55": [{"task_id": "EvoEval/55", "solution": "def treasure_map(message, shift):\n    encrypted_message = ''\n    for i in range(len(message)):\n        char = message[i]\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            new_char = chr((ord(char) - ascii_offset + shift + i) % 26 + ascii_offset)\n            encrypted_message += new_char\n        else:\n            encrypted_message += char\n    return encrypted_message", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/61": [{"task_id": "EvoEval/61", "solution": "def transform_string(s):\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    transformed = ''\n    for (i, char) in enumerate(s):\n        if char.lower() in vowels:\n            next_vowel = vowels[(vowels.index(char.lower()) + 1) % len(vowels)]\n            transformed += next_vowel.upper() if char.isupper() else next_vowel\n        elif char.lower() in consonants:\n            prev_consonant = consonants[(consonants.index(char.lower()) - 1) % len(consonants)]\n            if i % 2 == 1:\n                transformed += prev_consonant.upper() if char.isupper() else prev_consonant\n            else:\n                transformed += char\n        else:\n            transformed += char\n    return transformed", "base_status": "fail", "plus_status": null, "base_fail_tests": [["Hello World"]], "plus_fail_tests": []}], "EvoEval/82": [{"task_id": "EvoEval/82", "solution": "def zodiac_element(birthdays):\n    if not birthdays:\n        return None\n    zodiac_elements = {'Fire': [('03-21', '04-19'), ('07-23', '08-22'), ('11-22', '12-21')], 'Earth': [('04-20', '05-20'), ('08-23', '09-22'), ('12-22', '01-19')], 'Air': [('05-21', '06-20'), ('09-23', '10-22'), ('01-20', '02-18')], 'Water': [('06-21', '07-22'), ('10-23', '11-21'), ('02-19', '03-20')]}\n    result = {}\n    for birthday in birthdays:\n        month_day = birthday[5:]\n        for (element, ranges) in zodiac_elements.items():\n            for date_range in ranges:\n                if date_range[0] <= month_day <= date_range[1] or (date_range[0] > date_range[1] and (month_day >= date_range[0] or month_day <= date_range[1])):\n                    result[element] = result.get(element, 0) + 1\n                    break\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/91": [{"task_id": "EvoEval/91", "solution": "def spaceship_trajectory(spaceship_data):\n    \"\"\"Create a function which takes a list of tuples representing a spaceship's flight data,\n    and returns a string indicating the spaceship's final status.\n    Each tuple in the list represents a single action, where:\n    - The first element is a string indicating the action ('Launch', 'Move', 'Land')\n    - The second element is an integer indicating the distance moved in that action \n    (negative for backwards, positive for forwards)\n    The spaceship's status is determined by the following rules:\n    - Initially, the spaceship is 'On Ground'\n    - 'Launch' action can only be performed when the spaceship is 'On Ground' and will change the status to 'In Space'\n    - 'Move' action can only be performed when the spaceship is 'In Space' and will not change the status\n    - 'Land' action can only be performed when the spaceship is 'In Space', it will change the status back to 'On Ground'\n    - If any action is invalid according to these rules, return 'Invalid Action Sequence'. Otherwise, return the final status.\n    Examples:\n    spaceship_trajectory([('Launch', 1), ('Move', 2), ('Land', -1)]) # => 'On Ground'\n    spaceship_trajectory([('Launch', 1), ('Move', 2), ('Land', -1), ('Move', 3)]) # => 'Invalid Action Sequence'\n    \"\"\"\n    status = 'On Ground'\n    for (action, distance) in spaceship_data:\n        if action == 'Launch':\n            if status == 'On Ground':\n                status = 'In Space'\n            else:\n                return 'Invalid Action Sequence'\n        elif action == 'Move':\n            if status == 'In Space':\n                continue\n            else:\n                return 'Invalid Action Sequence'\n        elif action == 'Land':\n            if status == 'In Space':\n                status = 'On Ground'\n            else:\n                return 'Invalid Action Sequence'\n    return status", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/40": [{"task_id": "EvoEval/40", "solution": "def potion_mixing(potions, target):\n    potions_with_power = [(potion, int(potion.split()[-1])) for potion in potions]\n    possible_combinations = []\n    for r in range(1, len(potions_with_power) + 1):\n        for combination in itertools.combinations(potions_with_power, r):\n            if sum((power for (_, power) in combination)) == target:\n                possible_combinations.append(combination)\n    if not possible_combinations:\n        return []\n    min_length = min((len(combination) for combination in possible_combinations))\n    possible_combinations = [combination for combination in possible_combinations if len(combination) == min_length]\n    possible_combinations.sort(key=lambda combination: ''.join((potion for (potion, _) in combination)))\n    return [potion for (potion, _) in possible_combinations[0]]", "base_status": "fail", "plus_status": null, "base_fail_tests": [[["Healing Potion 10", "Strength Potion 5", "Invisibility Potion 7"], 15]], "plus_fail_tests": []}], "EvoEval/27": [{"task_id": "EvoEval/27", "solution": "def split_strings(s: str, n: int):\n    \"\"\"Return a list of n-character long strings created from the input string s.\n    If the length of s isn't a multiple of n, the remaining characters are added as the \n    last element of the returned list.\n\n    >>> split_strings('HelloWorld', 3)\n    ['Hel', 'loW', 'orl', 'd']\n    >>> split_strings('CodingIsFun', 5)\n    ['Codin', 'gIsFu', 'n']\n    \"\"\"\n    return [s[i:i + n] for i in range(0, len(s), n)]", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/80": [{"task_id": "EvoEval/80", "solution": "def adventure_game(map, instructions):\n    start_position = [(i, j) for i in range(len(map)) for j in range(len(map[i])) if map[i][j] == 'S'][0]\n    path = [start_position]\n    current_position = start_position\n    moves = {'up': (-1, 0), 'down': (1, 0), 'left': (0, -1), 'right': (0, 1)}\n    for instruction in instructions:\n        new_position = (current_position[0] + moves[instruction][0], current_position[1] + moves[instruction][1])\n        if 0 <= new_position[0] < len(map) and 0 <= new_position[1] < len(map[0]) and (map[new_position[0]][new_position[1]] != 'X'):\n            current_position = new_position\n            path.append(current_position)\n        if map[current_position[0]][current_position[1]] == 'E':\n            break\n    return path", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[".", ".", "S"], [".", "X", "X"], ["E", "X", "."]], ["left", "left", "up"]]], "plus_fail_tests": []}], "EvoEval/36": [{"task_id": "EvoEval/36", "solution": "def calculate_integral_coefficients(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    Return indefinite integral of this polynomial in the same form, with the constant of integration set to zero,\n    i.e. you should generate the coefficients for the polynomial representing the integral of the input polynomial.\n    So for example, if the input is [3, 2, 1], then the output would represent the polynomial 3*x + x^2 + x^3/3\n    >>> calculate_integral_coefficients([3, 2, 1])\n    [0, 3.0, 1.0, 0.3333333333333333]\n    >>> calculate_integral_coefficients([1, 3, 3, 1])\n    [0, 1.0, 1.5, 1.0, 0.25]\n    \"\"\"\n    integral_coefficients = [0]\n    for i in range(len(xs)):\n        integral_coefficients.append(xs[i] / (i + 1))\n    return integral_coefficients", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/85": [{"task_id": "EvoEval/85", "solution": "def princess_rescue(coord, grid):\n    (rows, cols) = (len(grid), len(grid[0]))\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque([(0, 0, 0)])\n    directions = [(0, 1), (1, 0)]\n    while queue:\n        (r, c, steps) = queue.popleft()\n        if r == coord[0] and c == coord[1]:\n            return steps\n        for (dr, dc) in directions:\n            (nr, nc) = (r + dr, c + dc)\n            if 0 <= nr < rows and 0 <= nc < cols and (not visited[nr][nc]) and (grid[nr][nc] == 0):\n                visited[nr][nc] = True\n                queue.append((nr, nc, steps + 1))\n    return -1", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[2, 2], [[0, 0, 0], [0, 1, 0], [0, 0, 0]]]], "plus_fail_tests": []}], "EvoEval/60": [{"task_id": "EvoEval/60", "solution": "def happy_ants(path_length, sugar_locations, ant_positions):\n    happy_ants = 0\n    for ant in ant_positions:\n        if ant[1] == 'right':\n            for sugar in sugar_locations:\n                if sugar >= ant[0]:\n                    happy_ants += 1\n                    break\n        else:\n            for sugar in sugar_locations:\n                if sugar <= ant[0]:\n                    happy_ants += 1\n                    break\n    return happy_ants", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/1": [{"task_id": "EvoEval/1", "solution": "from typing import List, Union\n\ndef calculate_shipping_cost(items: List[Union[str, float]], location: str) -> float:\n    location_factor = {'Local': 1.0, 'National': 1.5, 'International': 2.5}\n    total_cost = 0.0\n    for item in items:\n        if isinstance(item, str):\n            weight = 1.0\n        else:\n            weight = item\n        cost = 5.0\n        if weight > 5.0:\n            cost += 10.0\n        total_cost += cost\n    factor = location_factor.get(location, 1.0)\n    total_cost *= factor\n    return round(total_cost, 2)", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/57": [{"task_id": "EvoEval/57", "solution": "def magical_cafe(menu, magic_spell):\n    new_menu = {}\n    for (dish, price) in menu.items():\n        transformed_dish = ''\n        for i in range(len(dish)):\n            transformed_dish += magic_spell[i % len(magic_spell)]\n        new_menu[transformed_dish] = price\n    return new_menu", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/10": [{"task_id": "EvoEval/10", "solution": "from typing import List\n\ndef count_animals(animal_string: str) -> List[int]:\n    \"\"\" \n    Input to this function is a string representing animals and their sounds in a special ASCII format. \n    Your task is to parse this string and return a list of integers corresponding to how many times each \n    animal made a sound.\n\n    Here is a legend:\n    'C' - Cat, makes sound 'meow'\n    'D' - Dog, makes sound 'woof'\n    'B' - Bird, makes sound 'chirp'\n\n    Each sound is represented by a '|', and each animal-sound pair is separated by a space.\n\n    For example, a 'Cat' making sound 3 times will be represented as 'C|||'.\n\n    The function should return a list of integers representing how many sounds each animal made, in the order \n    they appear in the string. Skip invalid animals and also skip animals that has already appeared twice before. Furthermore, skip any animals after total animals (invalid and valid) has reached 5\n\n    >>> count_animals('C||| D|| B| C| B||| D|||')\n    [3, 2, 1, 1, 3]\n    \"\"\"\n    animal_counts = {'C': 0, 'D': 0, 'B': 0}\n    total_animals = 0\n    result = []\n    for animal_sound in animal_string.split():\n        if total_animals >= 5:\n            break\n        animal = animal_sound[0]\n        sound = animal_sound[1:]\n        if animal in animal_counts and animal_counts[animal] < 2:\n            animal_counts[animal] += 1\n            total_animals += 1\n            result.append(sound.count('|'))\n    return result", "base_status": "fail", "plus_status": null, "base_fail_tests": [["C||| D|| B| C| K||| B|||"]], "plus_fail_tests": []}], "EvoEval/49": [{"task_id": "EvoEval/49", "solution": "def morse_decoder(msg):\n    morse_code = {'01': 'A', '1000': 'B', '1010': 'C', '100': 'D', '0': 'E', '0010': 'F', '110': 'G', '0000': 'H', '00': 'I', '0111': 'J', '101': 'K', '0100': 'L', '11': 'M', '10': 'N', '111': 'O', '0110': 'P', '1101': 'Q', '010': 'R', '000': 'S', '1': 'T', '001': 'U', '0001': 'V', '011': 'W', '1001': 'X', '1011': 'Y', '1100': 'Z', '01111': '1', '00111': '2', '00011': '3', '00001': '4', '00000': '5', '10000': '6', '11000': '7', '11100': '8', '11110': '9', '11111': '0'}\n    words = msg.split('/')\n    decoded_msg = []\n    for word in words:\n        letters = word.split(' ')\n        decoded_word = ''.join((morse_code[letter] for letter in letters if letter))\n        decoded_msg.append(decoded_word)\n    return ' '.join(decoded_msg)", "base_status": "fail", "plus_status": null, "base_fail_tests": [["010101/01 1010 0 110 0"]], "plus_fail_tests": []}], "EvoEval/26": [{"task_id": "EvoEval/26", "solution": "def pathfinder(maze, start, end):\n    if start == end:\n        return []\n    (rows, cols) = (len(maze), len(maze[0]))\n    visited = [[False] * cols for _ in range(rows)]\n    queue = deque([(start, [])])\n    directions = [(0, 1, 'right'), (0, -1, 'left'), (1, 0, 'down'), (-1, 0, 'up')]\n    while queue:\n        ((x, y), path) = queue.popleft()\n        if (x, y) == end:\n            return path\n        for (dx, dy, direction) in directions:\n            (nx, ny) = (x + dx, y + dy)\n            if 0 <= nx < rows and 0 <= ny < cols and (not visited[nx][ny]) and (maze[nx][ny] == 0):\n                visited[nx][ny] = True\n                queue.append(((nx, ny), path + [direction]))\n    return []", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[[0, 0, 0], [1, 1, 0], [1, 1, 0]], [0, 0], [2, 2]]], "plus_fail_tests": []}], "EvoEval/19": [{"task_id": "EvoEval/19", "solution": "def vampires_in_matrix(m: list):\n    \"\"\"\n    vampires_in_matrix takes a 2D list of integers as an input,\n    where 0 represents an empty cell, 1 represents a human, and 2 represents a vampire.\n    The function will return the number of humans that are in danger of being bitten.\n    A human is considered in danger if they share a row or a column with a vampire.\n\n    >>> vampires_in_matrix([[0, 1, 0], [2, 0, 1], [1, 1, 0]])\n    2\n    >>> vampires_in_matrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]])\n    0\n    >>> vampires_in_matrix([[1, 2, 1], [1, 1, 1], [2, 1, 1]])\n    6\n    >>> vampires_in_matrix([[1, 1, 1], [0, 0, 0], [2, 2, 2]])\n    3\n    >>> vampires_in_matrix([[2]])\n    0\n    \"\"\"\n    rows_with_vampires = set()\n    cols_with_vampires = set()\n    for i in range(len(m)):\n        for j in range(len(m[i])):\n            if m[i][j] == 2:\n                rows_with_vampires.add(i)\n                cols_with_vampires.add(j)\n    humans_in_danger = 0\n    for i in range(len(m)):\n        for j in range(len(m[i])):\n            if m[i][j] == 1 and (i in rows_with_vampires or j in cols_with_vampires):\n                humans_in_danger += 1\n    return humans_in_danger", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/67": [{"task_id": "EvoEval/67", "solution": "def meal_calculator(customers, meals):\n    result = {}\n    for customer in customers:\n        if customer in meals:\n            total_calories = sum((meal['calories'] for meal in meals[customer]))\n            result[customer] = total_calories\n        else:\n            result[customer] = 0\n    return result", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/6": [{"task_id": "EvoEval/6", "solution": "from typing import List, Tuple\n\ndef minesweeper_clicked(grid: List[List[int]], position: Tuple[int, int]) -> List[List[int]]:\n    (x, y) = position\n    (rows, cols) = (len(grid), len(grid[0]))\n    if not (0 <= x < rows and 0 <= y < cols) or grid[x][y] == 0:\n        return grid\n    if grid[x][y] == 1:\n        return grid\n    for i in range(max(0, x - 1), min(rows, x + 2)):\n        for j in range(max(0, y - 1), min(cols, y + 2)):\n            if grid[i][j] != 1:\n                grid[i][j] = 0\n    return grid", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/37": [{"task_id": "EvoEval/37", "solution": "def string_transform(s):\n    vowels_lower = 'aeiou'\n    vowels_upper = 'AEIOU'\n    consonants_lower = 'bcdfghjklmnpqrstvwxyz'\n    consonants_upper = 'BCDFGHJKLMNPQRSTVWXYZ'\n    transformed = ''\n    for char in s:\n        if char in vowels_lower:\n            transformed += vowels_lower[(vowels_lower.index(char) + 1) % 5]\n        elif char in vowels_upper:\n            transformed += vowels_upper[(vowels_upper.index(char) + 1) % 5]\n        elif char in consonants_lower:\n            transformed += consonants_lower[(consonants_lower.index(char) + 1) % 21]\n        elif char in consonants_upper:\n            transformed += consonants_upper[(consonants_upper.index(char) + 1) % 21]\n        else:\n            transformed += char\n    return transformed", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/18": [{"task_id": "EvoEval/18", "solution": "def magical_seven(n: int) -> int:\n    \"\"\"\n    magical_seven returns the n-th number that is a multiple of 7 and its digits sum up to 7.\n    \n    >>> magical_seven(1)\n    7\n    >>> magical_seven(2)\n    70\n    >>> magical_seven(3)\n    133\n    >>> magical_seven(4)\n    322\n    >>> magical_seven(5)\n    511\n    \"\"\"\n\n    def sum_of_digits(num: int) -> int:\n        return sum((int(digit) for digit in str(num)))\n    count = 0\n    num = 0\n    while count < n:\n        num += 7\n        if sum_of_digits(num) == 7:\n            count += 1\n    return num", "base_status": "pass", "plus_status": null, "base_fail_tests": [], "plus_fail_tests": []}], "EvoEval/77": [{"task_id": "EvoEval/77", "solution": "def magical_sequence(sequence, k):\n    \"\"\"\n    Imagine a magical sequence where each number is associated with a certain number of points. \n    The points for each number are equivalent to the number of times the number can be divided by k until it reaches 1. \n    Now, given a sequence of positive integers and a positive integer k, \n    return a list sorted in decreasing order of the total points each number in the sequence can achieve.\n\n    Example 1:\n\n        Input: sequence = [8, 5, 3], k = 2\n        Output: [3, 0, 0]\n\n    Example 2:\n\n        Input: sequence = [25, 10, 5], k = 5\n        Output: [2, 1, 1]\n\n    Example 3:\n\n        Input: sequence = [12, 8, 6, 4], k = 2\n        Output: [3, 2, 2, 1]\n    \"\"\"\n    points = []\n    for num in sequence:\n        point = 0\n        while num >= k:\n            if num % k == 0:\n                num = num / k\n                point += 1\n            else:\n                break\n        points.append(point)\n    points.sort(reverse=True)\n    return points", "base_status": "fail", "plus_status": null, "base_fail_tests": [[[1, 1, 1, 1, 1, 1], 1]], "plus_fail_tests": []}], "EvoEval/66": [{"task_id": "EvoEval/66", "solution": "def prime_anagram_pairs(n):\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    primes = [i for i in range(2, n) if is_prime(i)]\n    anagram_pairs = []\n    for i in range(len(primes)):\n        for j in range(i + 1, len(primes)):\n            if sorted(str(primes[i])) == sorted(str(primes[j])):\n                anagram_pairs.append((primes[i], primes[j]))\n    return sorted(anagram_pairs)", "base_status": "fail", "plus_status": null, "base_fail_tests": [[8741]], "plus_fail_tests": []}]}}